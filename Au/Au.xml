<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Au</name>
    </assembly>
    <members>
        <member name="M:Au.Types.Api.SizeOf``1(``0)">
            <summary>
            Gets the native size of a struct variable.
            Returns Marshal.SizeOf(typeof(T)).
            Speed: the same (in Release config) as Marshal.SizeOf(typeof(T)), and 2 times faster than Marshal.SizeOf(v).
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1">
            <summary>
            Gets the native size of a type.
            Returns Marshal.SizeOf(typeof(T)).
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetProcAddress(System.String,System.String)">
            <summary>
            Gets dll module handle (Api.GetModuleHandle) or loads dll (Api.LoadLibrary), and returns unmanaged exported function address (Api.GetProcAddress).
            See also: GetDelegate.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Types.Api.GetProcAddress(System.String,System.String)"/> (loads dll or gets handle) and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.IntPtr,System.String)">
            <summary>
            Calls API <see cref="M:Au.Types.Api.GetProcAddress(System.IntPtr,System.String)"/> and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.ReleaseComObject``1(``0)">
            <summary>
            If o is not null, calls <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SetDIBitsToDevice(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Void*,System.UInt32)">
            <summary>
            lpbmi can be BITMAPINFOHEADER/BITMAPV5HEADER or BITMAPCOREHEADER.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SECURITY_ATTRIBUTES.#ctor(System.String)">
            <summary>
            Creates SECURITY_ATTRIBUTES from string security descriptor.
            securityDescriptor can be null; then lpSecurityDescriptor will be null;
            </summary>
        </member>
        <member name="F:Au.Types.Api.SECURITY_ATTRIBUTES.ForLowIL">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC low IL processes to open the kernel object.
            </summary>
        </member>
        <member name="F:Au.Types.Api.SECURITY_ATTRIBUTES.ForPipes">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC medium IL processes to open the pipe.
            Like of PipeSecurity that allows ReadWrite for AuthenticatedUserSid.
            </summary>
        </member>
        <member name="M:Au.Types.Api.NOTIFYICONDATA.#ctor(Au.wnd,System.UInt32)">
            <summary>
            Sets cbSize, hWnd and uFlags.
            </summary>
            <param name="wNotify"></param>
            <param name="nifFlags"></param>
        </member>
        <member name="M:Au.Types.Api.SetWindowSubclass(Au.wnd,Au.Types.Api.SUBCLASSPROC,System.IntPtr,System.IntPtr)">
            <summary>API <msdn>SetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Types.Api.GetWindowSubclass(Au.wnd,Au.Types.Api.SUBCLASSPROC,System.IntPtr,System.IntPtr@)">
            <summary>API <msdn>GetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Types.Api.RemoveWindowSubclass(Au.wnd,Au.Types.Api.SUBCLASSPROC,System.IntPtr)">
            <summary>API <msdn>RemoveWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Types.Api.DefSubclassProc(Au.wnd,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>API <msdn>DefSubclassProc</msdn></summary>
        </member>
        <member name="T:Au.Types.Api.SUBCLASSPROC">
            <summary>API <msdn>SUBCLASSPROC</msdn></summary>
        </member>
        <member name="M:Au.Types.Api.GetFullPathName(System.String,System.String@)">
            <summary>
            Calls API GetFullPathName.
            Returns false if failed or result is same; then r is s.
            r can be same variable as s.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetLongPathName(System.String,System.String@)">
            <summary>
            Calls API GetFullPathName.
            Returns false if failed or result is same; then r is s.
            r can be same variable as s.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SearchPath(System.String,System.String,System.String)">
            <summary>
            Calls API SearchPath. Returns full path, or null if not found.
            </summary>
            <param name="lpPath">Parent directory or null.</param>
            <param name="lpFileName"></param>
            <param name="lpExtension">null or extension like ".ext" to add if lpFileName is without extension.</param>
        </member>
        <member name="M:Au.Types.Api.GetEnvironmentVariable(System.String)">
            <summary>
            Calls API GetEnvironmentVariable.
            Returns null if variable not found.
            Does not support folders.X.
            </summary>
            <param name="name">Case-insensitive name. Without %.</param>
        </member>
        <member name="M:Au.Types.Api.EnvironmentVariableExists(System.String)">
            <summary>
            Returns true if environment variable exists.
            </summary>
        </member>
        <member name="M:Au.Types.Api.ExpandEnvironmentStrings(System.String,System.String@)">
            <summary>
            Calls API ExpandEnvironmentStrings.
            Returns false if failed or result is same; then r is s.
            r can be same variable as s.
            </summary>
        </member>
        <member name="M:Au.Types.Api.WNDCLASSEX.#ctor(Au.Types.RWCEtc)">
            <summary>
            If ex null, sets arrow cursor and style CS_VREDRAW | CS_HREDRAW.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetCursorPos(Au.Types.POINT@)">
            <summary>
            GetPhysicalCursorPos.
            </summary>
            <remarks>
            Gets DPI physical cursor pos, ie always in pixels.
            The classic GetCursorPos API behavior is undefined. Sometimes physical, sometimes logical.
            Make sure the process is fully DPI-aware.
            </remarks>
        </member>
        <member name="F:Au.Types.Api.WINDOWPLACEMENT.flags">
            <summary> WPF_ </summary>
        </member>
        <member name="M:Au.Types.Api.SystemParametersInfo(System.UInt32,System.Int32,System.Void*,System.UInt32)">
            <summary>
            Gets or sets any value. This is the direct API call.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SystemParametersInfo(System.UInt32,System.Int32)">
            <summary>
            Gets 32-bit integer value. Returns <i>def</i> if failed.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SystemParametersInfo(System.UInt32)">
            <summary>
            Gets BOOL value. Returns false if failed.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SystemParametersInfo(System.UInt32,System.Int32,System.Void*,System.Boolean,System.Boolean)">
            <summary>
            Sets value.
            </summary>
        </member>
        <member name="M:Au.Types.Api.WindowFromPoint(Au.Types.POINT)">
            <summary>
            WindowFromPhysicalPoint.
            </summary>
        </member>
        <member name="F:Au.Types.Api.AuExtraInfo">
            <summary>
            Extra info value of key and mouse events sent by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.IsInjected">
            <summary>
            true if the event was generated by software.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.BlockEvent">
            <summary>
            The 'set' function adds or removes flag 0x80000000.
            The 'get' function returns true if flag 0x80000000 is set.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.IsInjected">
            <summary>
            true if the event was generated by software.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.BlockEvent">
            <summary>
            The 'set' function adds or removes flag 0x80000000.
            The 'get' function returns true if flag 0x80000000 is set.
            </summary>
        </member>
        <member name="M:Au.Types.Api.CalculatePopupWindowPosition(Au.Types.POINT@,Au.Types.SIZE@,System.UInt32,Au.Types.RECT@,Au.Types.RECT@)">
            <param name="flags">Au.Controls.PopupAlignment</param>
        </member>
        <member name="M:Au.Types.Api.PROPVARIANT.Dispose">
            <summary>
            Calls PropVariantClear.
            </summary>
        </member>
        <member name="T:Au.Types.WS">
            <summary>
            Window styles.
            </summary>
            <remarks>
            Reference: <msdn>Window Styles</msdn>.
            Here names are without prefix WS_. For example, instead of WS_BORDER use WS.BORDER. Not included constants that are 0 (eg WS_TILED) or are duplicate (eg WS_SIZEBOX is same as WS_THICKFRAME) or consist of multiple other constants (eg WS_TILEDWINDOW).
            </remarks>
        </member>
        <member name="T:Au.Types.WSE">
            <summary>
            Window extended styles.
            </summary>
            <remarks>
            Reference: <msdn>Extended Window Styles</msdn>.
            Here names are without prefix WS_EX_. For example, instead of WS_EX_TOOLWINDOW use WSE.TOOLWINDOW. Not included constants that are 0 (eg WS_EX_LEFT).
            </remarks>
        </member>
        <member name="T:Au.Types.MSG">
            <summary>API <msdn>MSG</msdn></summary>
        </member>
        <member name="T:Au.Types.GTIFlags">
            <summary><see cref="T:Au.Types.GUITHREADINFO"/> flags.</summary>
        </member>
        <member name="T:Au.Types.GUITHREADINFO">
            <summary>API <msdn>GUITHREADINFO</msdn></summary>
        </member>
        <member name="T:Au.Types.CREATESTRUCT">
            <summary>API <msdn>CREATESTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.CREATESTRUCT.ClassName">
            <summary>
            If lpszClass is atom, returns string with # prefix and atom value, like "#32770".
            </summary>
        </member>
        <member name="T:Au.Types.SIGDN">
            <summary>API <msdn>SIGDN</msdn></summary>
        </member>
        <member name="T:Au.Types.SWPFlags">
            <summary>API <msdn>SetWindowPos</msdn> flags. Can be used with <see cref="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)"/>.</summary>
            <remarks>The _X flags are undocumented.</remarks>
        </member>
        <member name="T:Au.Types.SpecHWND">
            <summary>
            Special window handle values. Can be used with <see cref="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)"/>.
            See API <msdn>SetWindowPos</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.GWL">
            <summary>
            Window long constants. Used with <see cref="M:Au.wnd.GetWindowLong(System.Int32)"/> and <see cref="M:Au.wnd.SetWindowLong(System.Int32,System.IntPtr)"/>.
            See API <msdn>GetWindowLong</msdn>. See also API <msdn>SetWindowSubclass</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.GCL">
            <summary>
            Window class long constants. Used with <see cref="M:Au.wnd.more.getClassLong(Au.wnd,System.Int32)"/>.
            See API <msdn>WNDCLASSEX</msdn>, <msdn>GetClassLong</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.WNDPROC">
            <summary>API <msdn>WNDPROC</msdn></summary>
        </member>
        <member name="T:Au.Types.SMTFlags">
            <summary>API <msdn>SendMessageTimeout</msdn> flags. Used with <see cref="M:Au.wnd.SendTimeout(System.Int32,System.IntPtr@,System.Int32,System.IntPtr,System.IntPtr,Au.Types.SMTFlags)"/>.</summary>
        </member>
        <member name="T:Au.Types.TFFlags">
            <summary>API <msdn>DrawTextEx</msdn> format flags.</summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_AccFromWindow(System.Int32,Au.wnd,Au.Types.EObjid,Au.Types.Cpp.Cpp_Acc@,Au.Types.BSTR@)">
            <summary>
            flags: 1 not inproc, 2 get only name.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexCompile(System.String,System.IntPtr,Au.Types.RXFlags,System.Int32@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.Cpp.RegexMatch">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexMatch(System.Runtime.InteropServices.HandleRef,System.String,System.IntPtr,System.IntPtr,Au.Types.RXMatchFlags,Au.Types.Cpp.PcreCalloutT,Au.Types.Cpp.RegexMatch@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.ExtMisc">
            <summary>
            Adds extension methods for some .NET types.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToInt(System.Double)">
            <summary>
            Converts to int with rounding.
            Calls <see cref="M:System.Convert.ToInt32(System.Double)"/>.
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.ToInt(System.Single)">
            <summary>
            Converts to int with rounding.
            Calls <see cref="M:System.Convert.ToInt32(System.Single)"/>.
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.ToInt(System.Decimal)">
            <summary>
            Converts to int with rounding.
            Calls <see cref="M:System.Convert.ToInt32(System.Decimal)"/>.
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.ToColor_(System.Int32,System.Boolean)">
            <summary>
            Converts to System.Drawing.Color. Makes opaque (alpha 0xff).
            Can be used like <c>0x123456.ToColor_()</c> instead of <c>Color.FromArgb(unchecked((int)0xff123456))</c>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.Double,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.Single,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Single.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.Decimal,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Decimal.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.Int32,System.String)">
            <summary>
            Converts int to string.
            Uses invariant culture, therefore minus sign is always ASCII '-', not '−' etc.
            Calls <see cref="M:System.Int32.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.Int64,System.String)">
            <summary>
            Converts long to string.
            Uses invariant culture, therefore minus sign is always ASCII '-', not '−' etc.
            Calls <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToS(System.IntPtr,System.String)">
            <summary>
            Converts nint to string.
            Uses invariant culture, therefore minus sign is always ASCII '-', not '−' etc.
            Calls <see cref="M:System.IntPtr.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.GetStartEnd(System.Range,System.Int32)">
            <summary>
            Calls <see cref="M:System.Range.GetOffsetAndLength(System.Int32)"/> and returns start and end instead of start and length.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.GetStartEnd(System.Nullable{System.Range},System.Int32)">
            <summary>
            If this is null, returns <c>(0, length)</c>. Else calls <see cref="M:System.Range.GetOffsetAndLength(System.Int32)"/> and returns start and end instead of start and length.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.GetOffsetAndLength(System.Nullable{System.Range},System.Int32)">
            <summary>
            If this is null, returns <c>(0, length)</c>. Else calls <see cref="M:System.Range.GetOffsetAndLength(System.Int32)"/>.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.Has``1(``0,``0)">
            <summary>
            Returns true if this enum variable has all flag bits specified in <i>flag</i>.
            </summary>
            <param name="t"></param>
            <param name="flag">One or more flags.</param>
            <remarks>
            The same as code <c>(t &amp; flag) == flag</c> or <b>Enum.HasFlag</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtMisc.HasAny``1(``0,``0)">
            <summary>
            Returns true if this enum variable has one or more flag bits specified in <i>flags</i>.
            </summary>
            <param name="t"></param>
            <param name="flags">One or more flags.</param>
        </member>
        <member name="M:Au.Types.ExtMisc.SetFlag``1(``0@,``0,System.Boolean)">
            <summary>
            Adds or removes a flag.
            </summary>
            <param name="t"></param>
            <param name="flag">One or more flags to add or remove.</param>
            <param name="add">If true, adds flag, else removes flag.</param>
        </member>
        <member name="M:Au.Types.ExtMisc.IsAsciiDigit(System.Char)">
            <summary>
            Returns true if character is ASCII '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.IsAsciiAlpha(System.Char)">
            <summary>
            Returns true if character is ASCII 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.IsAsciiAlphaDigit(System.Char)">
            <summary>
            Returns true if character is ASCII 'A' to 'Z' or 'a' to 'z' or '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.RemoveAt``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a copy of this array with one or more removed elements.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index"></param>
            <param name="count"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.InsertAt``1(``0[],System.Int32,``0)">
            <summary>
            Creates a copy of this array with one inserted element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index">Where to insert. If -1, adds to the end.</param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.InsertAt``1(``0[],System.Int32,``0[])">
            <summary>
            Creates a copy of this array with several inserted elements.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index"></param>
            <param name="values"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Types.ExtMisc.RemoveWhere``2(System.Collections.Generic.Dictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            Removes items based on a predicate. For example, all items that have certain value.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="t"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:Au.Types.ExtMisc.Lenn_``1(``0[])">
            <summary>
            Returns <b>Length</b>, or 0 if null.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.Lenn_``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns <b>Count</b>, or 0 if null.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.NE_``1(``0[])">
            <summary>
            Returns true if null or <b>Length</b> == 0.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.NE_``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns true if null or <b>Count</b> == 0.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.Descendants_``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Efficiently recursively gets descendants of this tree.
            <see href="https://stackoverflow.com/a/30441479/2547338"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="childSelector"></param>
        </member>
        <member name="M:Au.Types.ExtMisc.Descendants_(System.Collections.IEnumerable,System.Func{System.Object,System.Collections.IEnumerable})">
            <summary>
            Efficiently recursively gets descendants of this tree.
            <see href="https://stackoverflow.com/a/30441479/2547338"/>
            </summary>
            <param name="t"></param>
            <param name="childSelector"></param>
        </member>
        <member name="M:Au.Types.ExtMisc.AppendSentence(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            Appends string as new correctly formatted sentence.
            Returns this.
            </summary>
            <param name="t"></param>
            <param name="s"></param>
            <param name="noUcase">Don't make the first character uppercase.</param>
            <remarks>
            If s is null or "", does nothing.
            If this is not empty, appends space.
            If s starts with a lowercase character, makes it uppercase, unless this ends with a character other than '.'.
            Appends '.' if s does not end with '.', ';', ':', ',', '!' or '?'.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtMisc.Hwnd(System.Windows.Forms.Control,System.Boolean)">
            <summary>
            Gets window handle as <see cref="T:Au.wnd"/>.
            </summary>
            <param name="t">A <b>Control</b> or <b>Form</b> etc. Cannot be null.</param>
            <param name="create">
            Create handle if still not created. Default false (return default(wnd)).
            Unlike <see cref="M:System.Windows.Forms.Control.CreateControl"/>, creates handle even if invisible. Does not create child control handles.
            </param>
            <remarks>
            Should be called in control's thread. Calls <see cref="P:System.Windows.Forms.Control.IsHandleCreated"/> and <see cref="P:System.Windows.Forms.Control.Handle"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtMisc.DrawRectangleInset(System.Drawing.Graphics,System.Drawing.Pen,Au.Types.RECT)">
            <summary>
            Draws inset rectangle.
            </summary>
            <param name="t"></param>
            <param name="pen">Pen with integer width and default alignment.</param>
            <param name="r"></param>
            <remarks>
            Calls <see cref="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)"/> with arguments corrected so that it draws inside r. Does not use <see cref="F:System.Drawing.Drawing2D.PenAlignment.Inset"/>, it is unreliable.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtMisc.DrawRectangleInset(System.Drawing.Graphics,System.Drawing.Color,System.Int32,Au.Types.RECT)">
            <summary>
            Draws inset rectangle of specified pen color and width.
            </summary>
            <remarks>
            Creates pen and calls other overload.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtMisc.FillRectangle(System.Drawing.Graphics,System.Drawing.Color,Au.Types.RECT)">
            <summary>
            Creates solid brush and calls <see cref="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtMisc.ToStringWithoutStack(System.Exception)">
            <summary>
            Returns string containing exception type name and message.
            </summary>
        </member>
        <member name="T:Au.Types.ExtWpf">
            <summary>
            Adds extension methods for some WPF classes.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.Hwnd(System.Windows.DependencyObject)">
            <summary>
            Gets native window handle of this <b>Window</b> or <b>Popup</b>, or container window handle of this child object.
            Returns <c>default(wnd)</c> if: called before creating or after closing real window; failed; <i>t</i> is null.
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Au.Types.ExtWpf.FindVisualDescendant(System.Windows.DependencyObject,System.Func{System.Windows.DependencyObject,System.Boolean},System.Boolean)">
            <summary>
            Enumerates visual descendant objects, including parts of composite controls, and calls callback function <i>f</i> for each.
            When <i>f</i> returns true, stops and returns that object. Returns null if <i>f</i> does not return true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.VisualDescendants(System.Windows.DependencyObject)">
            <summary>
            Enumerates visual descendant objects, including parts of composite controls, and calls callback function <i>f</i> for each.
            When <i>f</i> returns true, stops and returns that object. Returns null if <i>f</i> does not return true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.LogicalDescendants(System.Windows.DependencyObject)">
            <summary>
            Enumerates visual descendant objects, including parts of composite controls, and calls callback function <i>f</i> for each.
            When <i>f</i> returns true, stops and returns that object. Returns null if <i>f</i> does not return true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.VisualAncestors(System.Windows.DependencyObject,System.Boolean,System.Object)">
            <summary>
            Gets visual ancestors (<see cref="M:System.Windows.Media.VisualTreeHelper.GetParent(System.Windows.DependencyObject)"/>).
            </summary>
            <param name="t"></param>
            <param name="andThis">Include this object.</param>
            <param name="last">Last ancestor to get.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.FindVisualAncestor(System.Windows.DependencyObject,System.Boolean,System.Func{System.Windows.DependencyObject,System.Boolean},System.Object,System.Boolean)">
            <summary>
            Calls callback function <i>f</i> for each visual ancestor (<see cref="M:System.Windows.Media.VisualTreeHelper.GetParent(System.Windows.DependencyObject)"/>).
            Returns ancestor for which <i>f</i> returns true. Also can return <i>last</i> or null.
            </summary>
            <param name="t"></param>
            <param name="andThis">Include this object.</param>
            <param name="f"></param>
            <param name="last">When found this ancestor, stop and return <i>last</i> if <i>andLast</i> true or null if false.</param>
            <param name="andLast">If <i>last</i> found, return <i>last</i> instead of null.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.FindVisualAncestor``1(System.Windows.DependencyObject,System.Boolean,System.Object,System.Boolean)">
            <summary>
            Returns visual ancestor (<see cref="M:System.Windows.Media.VisualTreeHelper.GetParent(System.Windows.DependencyObject)"/>) of type <i>T</i>.
            Also can return <i>last</i> or null.
            </summary>
            <param name="t"></param>
            <param name="andThis">Include this object.</param>
            <param name="last">When found this ancestor, stop and return <i>last</i> if <i>andLast</i> true or null if false.</param>
            <param name="andLast">If <i>last</i> found, return <i>last</i> instead of null.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.RectInScreen(System.Windows.FrameworkElement)">
            <summary>
            Gets rectangle of this element in screen coordinates.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.True(System.Windows.Controls.CheckBox)">
            <summary>
            Returns true if <see cref="P:System.Windows.Controls.Primitives.ToggleButton.IsChecked"/> == true.
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Au.Types.ExtWpf.SetXY(System.Windows.Window,System.Int32,System.Int32)">
            <summary>
            Sets window startup location before showing it first time. Also can move already loaded window.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in screen. Physical pixels.</param>
            <param name="y">Y coordinate in screen. Physical pixels.</param>
            <remarks>
            The unit is physical pixels. WPF provides <b>Left</b> and <b>Top</b> properties, but the unit is logical pixels, therefore cannot set exact location on high DPI screens, especially if there are mutiple screens with different DPI.
            
            If the window is already loaded, just ensures it is not maximized/minimized and calls <see cref="M:Au.wnd.MoveL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.SWPFlags)"/>.
            
            Else sets window location for normal state (not minimized/maximized). Temporarily changes <b>Title</b>. Clears <b>WindowStartupLocation</b>, <b>Left</b>, <b>Top</b>. Clears <b>ShowActivated</b> if minimized. Does not change <b>SizeToContent</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtWpf.SetRect(System.Windows.Window,Au.Types.RECT)">
            <summary>
            Sets window startup rectangle (location and size) before showing it first time. Also can move/resize already loaded window.
            </summary>
            <param name="t"></param>
            <param name="r">Rectangle in screen. Physical pixels.</param>
            <remarks>
            The unit is physical pixels. WPF provides <b>Left</b>, <b>Top</b>, <b>Width</b> and <b>Height</b> properties, but the unit is logical pixels, therefore cannot set exact rectangle on high DPI screens, especially if there are mutiple screens with different DPI.
            
            If the window is already loaded, just ensures it is not maximized/minimized and calls <see cref="M:Au.wnd.MoveL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.SWPFlags)"/>.
            
            Else sets window rectangle for normal state (not minimized/maximized). Temporarily changes <b>Title</b>. Clears <b>WindowStartupLocation</b>, <b>Left</b>, <b>Top</b>, <b>Width</b>, <b>Height</b>. Clears <b>ShowActivated</b> if minimized. Does not change <b>SizeToContent</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.ExtWpf.InsertRow(System.Windows.Controls.Grid,System.Int32,System.Windows.Controls.RowDefinition)">
            <summary>
            Inserts row and adjusts row indices of children that are in other rows.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.InsertColumn(System.Windows.Controls.Grid,System.Int32,System.Windows.Controls.ColumnDefinition)">
            <summary>
            Inserts column and adjusts column indices of children that are in other columns.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.RemoveRow(System.Windows.Controls.Grid,System.Int32,System.Boolean)">
            <summary>
            Removes row and adjusts row indices of children that are in other rows.
            </summary>
            <param name="t"></param>
            <param name="index"></param>
            <param name="removeChildren">Remove children that are in that row.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.RemoveColumn(System.Windows.Controls.Grid,System.Int32,System.Boolean)">
            <summary>
            Removes column and adjusts column indices of children that are in other columns.
            </summary>
            <param name="t"></param>
            <param name="index"></param>
            <param name="removeChildren">Remove children that are in that column.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.RemoveRow(System.Windows.Controls.Grid,System.Windows.UIElement,System.Boolean)">
            <summary>
            Removes a child element and its row from this grid. Adjusts row indices of children that are in other rows.
            </summary>
            <param name="t"></param>
            <param name="e"></param>
            <param name="removeOtherElements">Also remove other elements that are in that row.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.RemoveColumn(System.Windows.Controls.Grid,System.Windows.UIElement,System.Boolean)">
            <summary>
            Removes a child element and its column from this grid. Adjusts column indices of children that are in other columns.
            </summary>
            <param name="t"></param>
            <param name="e"></param>
            <param name="removeOtherElements">Also remove other elements that are in that column.</param>
        </member>
        <member name="M:Au.Types.ExtWpf.AddChild(System.Windows.Controls.Grid,System.Windows.UIElement,System.Int32,System.Int32)">
            <summary>
            Adds a child element in specified row/column.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.DpiChangedWorkaround(System.Windows.Window)">
            <summary>
            Workaround for WPF bug: on DPI change tries to activate window.
            Call on WM_DPICHANED message or in OnDpiChanged override.
            </summary>
        </member>
        <member name="M:Au.Types.ExtWpf.DpiChangedWorkaround(System.Windows.Interop.HwndSource)">
            <summary>
            Workaround for WPF bug: on DPI change tries to activate window.
            Call on WM_DPICHANED message or in OnDpiChanged override. Only if top-level window.
            </summary>
        </member>
        <member name="T:Au.Types.ExtXml">
            <summary>
            Adds extension methods for <see cref="T:System.Xml.Linq.XElement"/> and <see cref="T:System.Xml.Linq.XDocument"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns null.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.String@,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, sets value=null and returns false.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets attribute value converted to int number.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or does not begin with a valid number, returns 0.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Int32@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to int number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Int64@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to long number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Double@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to double number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or is not a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr(System.Xml.Linq.XElement,System.Single@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to float number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or is not a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Attr``1(System.Xml.Linq.XElement,``0@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value as enum type T.
            If the attribute does not exist, sets value=default(T) and returns false.
            If the attribute value is not a valid enum member name, sets value=default(T) and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.HasAttr(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Returns true if this element has the specified attribute.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Desc(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found descendant element.
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.Desc(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Finds the first descendant element that has the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtXml.Descs(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Finds all descendant elements that have the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtXml.Elem(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtXml.Elems(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets all direct child elements that have the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtXml.ElemOrAdd(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found direct child element. If not found, adds new empty child element.
            Returns the found or added element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.ElemOrAdd(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute. If not found, adds new child element with the attribute.
            Returns the found or added element.
            More info: <see cref="M:Au.Types.ExtXml.Elem(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.PrevElem(System.Xml.Linq.XElement)">
            <summary>
            Gets previous sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.NextElem(System.Xml.Linq.XElement)">
            <summary>
            Gets next sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtXml.SaveElem(System.Xml.Linq.XElement,System.String,System.Boolean,System.Nullable{System.Xml.Linq.SaveOptions})">
            <summary>
            Saves XML to a file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)"/> and <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XElement.Save(System.IO.Stream)"/> and <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtXml.SaveDoc(System.Xml.Linq.XDocument,System.String,System.Boolean,System.Nullable{System.Xml.Linq.SaveOptions})">
            <summary>
            Saves XML to a file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XDocument.Save(System.String)"/> and <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)"/> and <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="T:Au.Types.FileIs_">
            <summary>
            File system entry type - file, directory, symbolic link, whether it exists and is accessible.
            The enum value NotFound is 0; AccessDenied is negative ((int)0x80000000); other values are greater than 0.
            </summary>
        </member>
        <member name="F:Au.Types.FileIs_.NotFound">
            <summary>Does not exist.</summary>
        </member>
        <member name="F:Au.Types.FileIs_.File">
            <summary>Is file. Attributes: Directory no, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileIs_.Directory">
            <summary>Is directory. Attributes: Directory yes, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileIs_.SymLinkFile">
            <summary>Is symbolic link to a file. Attributes: Directory no, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileIs_.SymLinkDirectory">
            <summary>Is symbolic link to a directory, or is a mounted folder. Attributes: Directory yes, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileIs_.AccessDenied">
            <summary>Exists but this process cannot access it and get attributes.</summary>
        </member>
        <member name="T:Au.Types.FAttr">
            <summary>
            Contains file or directory attributes. Tells whether it exists, is directory, symbolic link, readonly, hidden, system.
            See <see cref="M:Au.filesystem.exists(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.FAttr.#ctor(System.IO.FileAttributes,System.Nullable{System.Boolean})">
            <param name="attributes">Attributes, or 0 if does not exist or can't get attributes.</param>
            <param name="exists">True if exists and can get attributes. False if does not exist. null if exists but can't get attributes.</param>
        </member>
        <member name="P:Au.Types.FAttr.attr">
            <summary>
            Returns file or directory attributes. Returns 0 if <see cref="P:Au.Types.FAttr.exists"/> false.
            </summary>
        </member>
        <member name="M:Au.Types.FAttr.op_Implicit(Au.Types.FAttr)~System.Boolean">
            <summary>
            Returns <see cref="P:Au.Types.FAttr.exists"/>.
            </summary>
        </member>
        <member name="M:Au.Types.FAttr.op_Implicit(Au.Types.FAttr)~System.Int32">
            <summary>
            Returns 0 if !<see cref="P:Au.Types.FAttr.exists"/>, 1 if <see cref="P:Au.Types.FAttr.isFile"/>, 2 if <see cref="P:Au.Types.FAttr.isDir"/>. Can be used with switch.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.exists">
            <summary>
            Exists and is accessible (<see cref="P:Au.Types.FAttr.unknown"/> false).
            See also <see cref="P:Au.Types.FAttr.isFile"/>, <see cref="P:Au.Types.FAttr.isDir"/>.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.unknown">
            <summary>
            Exists but this process cannot access it and get attributes (error "access denied"). Then other bool properties return false.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isFile">
            <summary>
            Is file (not directory), or symbolic link to a file (if <see cref="P:Au.Types.FAttr.isSymlink"/> true).
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isDir">
            <summary>
            Is directory, or symbolic link to a directory (if <see cref="P:Au.Types.FAttr.isSymlink"/> true).
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isSymlink">
            <summary>
            Has <see cref="F:System.IO.FileAttributes.ReparsePoint"/>.
            If <see cref="P:Au.Types.FAttr.isFile"/> true, it is symbolic link to a file. If <see cref="P:Au.Types.FAttr.isDir"/> true, it is symbolic link to a directory or is a mounted folder.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isReadonly">
            <summary>
            Has <see cref="F:System.IO.FileAttributes.ReadOnly"/>.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isHidden">
            <summary>
            Has <see cref="F:System.IO.FileAttributes.Hidden"/>.
            </summary>
        </member>
        <member name="P:Au.Types.FAttr.isSystem">
            <summary>
            Has <see cref="F:System.IO.FileAttributes.System"/>.
            </summary>
        </member>
        <member name="M:Au.Types.FAttr.ToString">
            
        </member>
        <member name="T:Au.Types.FAFlags">
            <summary>
            Flags for <see cref="M:Au.filesystem.getAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.FAFlags.UseRawPath">
            <summary>Pass path to the API as it is, without any normalizing and validating.</summary>
        </member>
        <member name="F:Au.Types.FAFlags.DontThrow">
            <summary>
            If failed, return false and don't throw exception.
            Then, if you need error info, you can use <see cref="T:Au.lastError"/>. If the file/directory does not exist, it will return ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND or ERROR_NOT_READY.
            If failed and the native error code is ERROR_ACCESS_DENIED or ERROR_SHARING_VIOLATION, the returned attributes will be (FileAttributes)(-1). The file probably exists but is protected so that this process cannot access and use it. Else attributes will be 0.
            </summary>
        </member>
        <member name="T:Au.Types.FileProperties">
            <summary>
            File or directory properties. Used with <see cref="M:Au.filesystem.getProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileProperties.Attributes">
            
        </member>
        <member name="F:Au.Types.FileProperties.Size">
            <summary>File size. For directories it is usually 0.</summary>
        </member>
        <member name="F:Au.Types.FileProperties.LastWriteTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.CreationTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.LastAccessTimeUtc">
            <summary>Note: this is unreliable. The operating system may not record this time automatically.</summary>
        </member>
        <member name="T:Au.Types.FEFlags">
            <summary>
            flags for <see cref="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSubdirectories">
            <summary>
            Enumerate subdirectories too.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSymbolicLinkSubdirectories">
            <summary>
            Also enumerate symbolic link and mounted folder target directories. Use with AndSubdirectories.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHidden">
            <summary>
            Skip files and subdirectories that have Hidden attribute.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHiddenSystem">
            <summary>
            Skip files and subdirectories that have Hidden and System attributes (both).
            These files/directories usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: <c>"$Recycle.Bin"</c>, <c>"System Volume Information"</c>, <c>"Recovery"</c>. If you want to include them too, use network path of the drive, for example <c>@"\\localhost\D$\"</c> for D drive.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.IgnoreInaccessible">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, assume that the [sub]directory is empty.
            Without this flag then throws exception or calls errorHandler.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.DisableRedirection">
            <summary>
            Temporarily disable file system redirection in this thread of this 32-bit process running on 64-bit Windows.
            Then you can enumerate the 64-bit System32 folder in your 32-bit process.
            Uses API <msdn>Wow64DisableWow64FsRedirection</msdn>.
            For vice versa (in 64-bit process enumerate the 32-bit System folder), instead use path folders.SystemX86.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.UseRawPath">
            <summary>
            Don't call <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>(directoryPath) and don't throw exception for non-full path.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.NeedRelativePaths">
            <summary>
            Let <see cref="P:Au.Types.FEFile.Name"/> be path relative to the specified directory path. Like <c>@"\name.txt"</c> or <c>@"\subdirectory\name.txt"</c> instead of "name.txt".
            </summary>
        </member>
        <member name="T:Au.Types.FCFlags">
            <summary>
            flags for <see cref="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> and some other similar functions.
            Used only when copying directory.
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.SkipHiddenSystem">
            <summary>
            Skip descendant files and directories that have Hidden and System attributes (both).
            They usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            They often are protected and would fail to copy, ruining whole copy operation.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery".
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.IgnoreInaccessible">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, don't throw exception but assume that the [sub]directory is empty.
            </summary>
        </member>
        <member name="T:Au.Types.FEFile">
            <summary>
            Contains name and other main properties of a file or subdirectory retrieved by <see cref="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            The values are not changed after creating the variable.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.#ctor(System.String,System.String,Au.Types.Api.WIN32_FIND_DATA@,System.Int32)">
            
        </member>
        <member name="P:Au.Types.FEFile.Name">
            
        </member>
        <member name="P:Au.Types.FEFile.FullPath">
            
        </member>
        <member name="P:Au.Types.FEFile.Size">
            <summary>
            Returns file size. For directories it is usually 0.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.LastWriteTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.CreationTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.Attributes">
            
        </member>
        <member name="P:Au.Types.FEFile.IsDirectory">
            <summary>
            Returns true if is directory or symbolic link to a directory or mounted folder.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.Level">
            <summary>
            Descendant level.
            0 if direct child of directoryPath, 1 if child of child, and so on.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.SkipThisDirectory">
            <summary>
            Call this function if don't want to enumerate children of this subdirectory.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.ToString">
            <summary>
            Returns FullPath.
            </summary>
        </member>
        <member name="T:Au.Types.FIfExists">
            <summary>
            What to do if the destination directory contains a file or directory with the same name as the source file or directory when copying, moving or renaming.
            Used with <see cref="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>, <see cref="M:Au.filesystem.move(System.String,System.String,Au.Types.FIfExists)"/> and similar functions.
            When renaming or moving, if the destination is the same as the source, these options are ignored and the destination is simply renamed. For example when renaming "file.txt" to "FILE.TXT".
            </summary>
        </member>
        <member name="F:Au.Types.FIfExists.Fail">
            <summary>Throw exception. Default.</summary>
        </member>
        <member name="F:Au.Types.FIfExists.Delete">
            <summary>Delete destination.</summary>
        </member>
        <member name="F:Au.Types.FIfExists.RenameExisting">
            <summary>Rename (backup) destination.</summary>
        </member>
        <member name="F:Au.Types.FIfExists.MergeDirectory">
            <summary>
            If destination directory exists, merge the source directory into it, replacing existing files.
            If destination file exists, deletes it.
            If destination directory exists and source is file, fails.
            </summary>
        </member>
        <member name="T:Au.Types.FileId">
            <summary>
            Contains file properties that can be used to uniquely identify the file on a single computer.
            </summary>
            <remarks>
            Can be used with files and directories.
            To get it, use <see cref="M:Au.filesystem.more.getFileId(System.String,Au.Types.FileId@)"/>.
            There are many different ways to specify path to the same file or directory. To determine whether two paths represent the same file, get and compare their <b>FileId</b>.
            </remarks>
        </member>
        <member name="F:Au.Types.FileId.VolumeSerialNumber">
            <summary>The serial number of the volume (aka disk drive) that contains the file.</summary>
        </member>
        <member name="F:Au.Types.FileId.FileIndex">
            <summary>An identifier that is associated with the file. It is unique in that volume.</summary>
        </member>
        <member name="T:Au.Types.FolderPath">
            <summary>
            Most functions of <see cref="T:Au.folders"/> class return a value of this type.
            Contains folder path (string) and has operator + to append a string with backslash if need. Has implicit conversions from/to string.
            </summary>
        </member>
        <member name="M:Au.Types.FolderPath.op_Addition(Au.Types.FolderPath,System.String)">
            <summary>
            Calls <see cref="M:Au.pathname.combine(System.String,System.String,System.Boolean,System.Boolean)"/>(fp, append).
            Example: <c>string s = folders.Desktop + "file.txt";</c>
            </summary>
            <exception cref="T:Au.Types.AuException">fp is empty. Most likely, used code <c>folders.X + "append"</c> and folders.X failed to get folder path.</exception>
        </member>
        <member name="T:Au.Types.IconGetFlags">
            <summary>
            Flags for <see cref="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.IconGetFlags.LiteralPath">
            <summary>
            The <i>file</i> argument is literal full path. Don't parse "path,index", don't support ".ext" (file type icon), don't make fully-qualified, etc.
            </summary>
        </member>
        <member name="F:Au.Types.IconGetFlags.DontSearch">
            <summary>
            Don't call <see cref="M:Au.filesystem.searchPath(System.String,System.String[])"/>.
            </summary>
        </member>
        <member name="T:Au.Types.StockIcon">
            <summary>See <see cref="M:Au.icon.stock(Au.Types.StockIcon,System.Int32)"/>, <msdn>SHSTOCKICONID</msdn>.</summary>
        </member>
        <member name="T:Au.Types.PNFlags">
            <summary>
            flags for <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontExpandDosPath">
            <summary>Don't call API <msdn>GetLongPathName</msdn>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontPrefixLongPath">
            <summary>Don't call <see cref="M:Au.pathname.prefixLongPathIfNeed(System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontRemoveEndSeparator">
            <summary>Don't remove <c>\</c> character at the end.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.CanBeUrlOrShell">
            <summary>If path is not a file-system path but looks like URL (eg <c>"http:..."</c> or <c>"file:..."</c>) or starts with <c>"::"</c>, don't throw exception and don't process more (only expand environment variables).</summary>
        </member>
        <member name="T:Au.Types.Pidl">
            <summary>
            Manages an ITEMIDLIST structure that is used to identify files and other shell objects instead of a file-system path.
            </summary>
            <remarks>
            Wraps an ITEMIDLIST*, also known as PIDL or LPITEMIDLIST.
            
            When calling native shell API, virtual objects can be identified only by ITEMIDLIST*. Some API also support "parsing name", which may look like <c>"::{CLSID-1}\::{CLSID-2}"</c>. File-system objects can be identified by path as well as by ITEMIDLIST*. URLs can be identified by URL as well as by ITEMIDLIST*.
            
            The ITEMIDLIST structure is in unmanaged memory. You can dispose <b>Pidl</b> variables, or GC will do it later.
            
            This class has only ITEMIDLIST functions that are used in this library. Look for other functions in the MSDN library. Many of them are named with IL prefix, like ILClone, ILGetSize, ILFindLastID.
            </remarks>
        </member>
        <member name="P:Au.Types.Pidl.UnsafePtr">
            <summary>
            Gets the ITEMIDLIST* (PIDL).
            </summary>
            <remarks>
            The ITEMIDLIST memory is managed by this variable and will be freed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.Types.Pidl.HandleRef">
            <summary>
            Gets the ITEMIDLIST* (PIDL).
            </summary>
            <remarks>
            Use to pass to API where the parameter type is <b>HandleRef</b>. It is safer than <see cref="P:Au.Types.Pidl.UnsafePtr"/> because ensures that this variable will not be GC-collected during API call even if not referenced after the call.
            </remarks>
        </member>
        <member name="P:Au.Types.Pidl.IsNull">
            <summary>
            Returns true if the PIDL is null.
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.#ctor(System.IntPtr)">
            <summary>
            Assigns an ITEMIDLIST to this variable.
            </summary>
            <param name="pidl">
            ITEMIDLIST* (PIDL).
            It can be created by any API that creates ITEMIDLIST. They allocate the memory with API CoTaskMemAlloc. This variable will finally free it with Marshal.FreeCoTaskMem which calls API CoTaskMemFree.
            </param>
        </member>
        <member name="M:Au.Types.Pidl.#ctor(System.IntPtr,System.IntPtr)">
            <summary>
            Combines two ITEMIDLIST (parent and child) and assigns the result to this variable.
            </summary>
            <param name="pidlAbsolute">Absolute PIDL (parent folder).</param>
            <param name="pidlRelative">Relative PIDL (child object).</param>
            <remarks>
            Does not free <i>pidlAbsolute</i> and <i>pidlRelative</i>.
            </remarks>
        </member>
        <member name="M:Au.Types.Pidl.Dispose">
            <summary>
            Frees the ITEMIDLIST with Marshal.FreeCoTaskMem and clears this variable.
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.Types.Pidl.Finalize">
            
        </member>
        <member name="M:Au.Types.Pidl.Detach">
            <summary>
            Gets the ITEMIDLIST and clears this variable so that it cannot be used and will not free the ITEMIDLIST memory. To free it use Marshal.FreeCoTaskMem.
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.FromString(System.String,System.Boolean)">
            <summary>
            Converts string to ITEMIDLIST and creates new Pidl variable that holds it.
            Returns null if failed.
            </summary>
            <param name="s">A file-system path or URL or shell object parsing name (see <see cref="M:Au.Types.Pidl.ToShellString(Au.Types.SIGDN,System.Boolean)"/>) or ":: ITEMIDLIST" (see <see cref="M:Au.Types.Pidl.ToHexString"/>). Supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>).</param>
            <param name="throwIfFailed">Throw exception if failed.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true. Probably invalid s.</exception>
            <remarks>
            Calls <msdn>SHParseDisplayName</msdn>, except when string is ":: ITEMIDLIST".
            When ":: ITEMIDLIST", does not check whether the shell object exists.
            Note: Pidl is disposable.
            </remarks>
        </member>
        <member name="M:Au.Types.Pidl.FromString_(System.String,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Types.Pidl.FromString(System.String,System.Boolean)"/>, but returns unmanaged ITEMIDLIST*.
            Later need to free it with Marshal.FreeCoTaskMem.
            </summary>
            <param name="s"></param>
            <param name="throwIfFailed"></param>
        </member>
        <member name="M:Au.Types.Pidl._Normalize(System.String)">
            <summary>
            The same as <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>(CanBeUrlOrShell|DontPrefixLongPath), but ignores non-full path (returns s).
            </summary>
            <param name="s">File-system path or URL or "::...".</param>
        </member>
        <member name="M:Au.Types.Pidl.ToShellString(Au.Types.SIGDN,System.Boolean)">
            <summary>
            Converts the ITEMIDLIST to file path or URL or shell object parsing name or display name, depending on stringType argument.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            If failed, returns null or throws exception.
            </summary>
            <param name="stringType">
            String format. API <msdn>SIGDN</msdn>.
            Often used:
            - SIGDN.NORMALDISPLAY - returns object name without path. It is best to display in UI but cannot be parsed to create ITEMIDLIST again.
            - SIGDN.FILESYSPATH - returns path if the ITEMIDLIST identifies a file system object (file or directory). Else returns null.
            - SIGDN.URL - if URL, returns URL. If file system object, returns its path like "file:///C:/a/b.txt". Else returns null.
            - SIGDN.DESKTOPABSOLUTEPARSING - returns path (if file system object) or URL (if URL) or shell object parsing name (if virtual object eg Control Panel). Note: not all returned parsing names can actually be parsed to create ITEMIDLIST again, therefore usually it's better to use <see cref="M:Au.Types.Pidl.ToString"/> instead.
            </param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true.</exception>
            <remarks>
            Calls <msdn>SHGetNameFromIDList</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.Pidl.ToShellString(System.IntPtr,Au.Types.SIGDN,System.Boolean)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.ToString">
            <summary>
            Converts the ITEMIDLIST to string.
            If it identifies an existing file-system object (file or directory), returns path. If URL, returns URL. Else returns ":: ITEMIDLIST" (see <see cref="M:Au.Types.Pidl.ToHexString"/>).
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.ToString(System.IntPtr)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Types.Pidl.ToHexString">
            <summary>
            Returns string ":: ITEMIDLIST".
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
            <remarks>
            The string can be used with some functions of this library, mostly of classes <b>filesystem</b>, <b>Pidl</b> and <b>icon</b>. Cannot be used with native and .NET functions.
            </remarks>
        </member>
        <member name="M:Au.Types.Pidl.ToHexString(System.IntPtr)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="T:Au.Types.SLTransaction">
            <summary>
            A SQLite transaction or savepoint. The main purpose is to automatically rollback if not explicitly committed.
            Usage: <c>using(var trans = new SLTransaction(db)) { ... trans.Commit(); }</c>
            </summary>
        </member>
        <member name="P:Au.Types.SLTransaction.SqlOfDispose">
            <summary>
            Gets or sets SQL to execute when disposing this variable if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>.
            Initially = parameter <c>sqlOfDispose</c> of constructor.
            </summary>
        </member>
        <member name="M:Au.Types.SLTransaction.#ctor(Au.sqlite,System.String,System.String)">
            <summary>
            Begins a SQLite transaction and prepares for automatic rollback if not explicitly committed.
            Usage: <c>using(var trans = new SLTransaction(db)) { ... trans.Commit(); }</c>
            </summary>
            <param name="db"></param>
            <param name="sql">SQL to execute now. Default "BEGIN". For nested transaction use "SAVEPOINT name".</param>
            <param name="sqlOfDispose">SQL to execute when disposing this variable if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>. Default "ROLLBACK". For nested transaction use "ROLLBACK TO name". See also: <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Dispose">
            <summary>
            Calls <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/> if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>.
            </summary>
            <exception cref="T:Au.Types.SLException">Failed to execute <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Rollback(System.String)">
            <summary>
            Executes a rollback SQL (if in transaction) and disables <see cref="M:Au.Types.SLTransaction.Dispose"/>.
            Usually don't need to call this function explicitly. It is implicitly called when disposing this variable if the transaction was not committed.
            </summary>
            <param name="sql">SQL to execute. Default: <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Commit(System.String)">
            <summary>
            Executes a commit SQL and disables <see cref="M:Au.Types.SLTransaction.Dispose"/>.
            </summary>
            <param name="sql">SQL to execute. Default "COMMIT". For nested transaction use "RELEASE name".</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="T:Au.Types.SLIndexOrName">
            <summary>
            Used for parameter types of some <see cref="T:Au.sqliteStatement"/> functions.
            Has implicit conversions from int and string. If int, the value is interpreted as index. If string - as name.
            </summary>
        </member>
        <member name="T:Au.Types.SLException">
            <summary>
            Exception thrown by <see cref="T:Au.sqlite"/>, <see cref="T:Au.sqliteStatement"/> and related types.
            </summary>
        </member>
        <member name="P:Au.Types.SLException.ErrorCode">
            <summary>
            The called SQLite API function returned this error code.
            </summary>
        </member>
        <member name="T:Au.Types.SLFlags">
            <summary>
            Flags for <see cref="T:Au.sqlite"/> constructor.
            </summary>
        </member>
        <member name="F:Au.Types.SLFlags.ReadWriteCreate">
            <summary>Defaut flags. Includes SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.</summary>
        </member>
        <member name="T:Au.Types.SLError">
            <summary>
            SQLite API error codes. Also two success codes - Row and Done.
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Ok">
            <summary>
            Successful result
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Error">
            <summary>
            SQL error or missing database
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Internal">
            <summary>
            Internal logic error in SQLite
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Perm">
            <summary>
            Access permission denied
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Abort">
            <summary>
            Callback routine requested an abort
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Busy">
            <summary>
            The database file is locked
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Locked">
            <summary>
            A table in the database is locked
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NoMem">
            <summary>
            A malloc() failed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.ReadOnly">
            <summary>
            Attempt to write a readonly database
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Interrupt">
            <summary>
            Operation terminated by sqlite3_interrupt()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.IoErr">
            <summary>
            Some kind of disk I/O error occurred
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Corrupt">
            <summary>
            The database disk image is malformed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NotFound">
            <summary>
            Unknown opcode in sqlite3_file_control()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Full">
            <summary>
            Insertion failed because database is full
            </summary>
        </member>
        <member name="F:Au.Types.SLError.CantOpen">
            <summary>
            Unable to open the database file
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Protocol">
            <summary>
            Database lock protocol error
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Empty">
            <summary>
            Database is empty
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Schema">
            <summary>
            The database schema changed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.TooBig">
            <summary>
            String or BLOB exceeds size limit
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Constraint">
            <summary>
            Abort due to constraint violation
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Mismatch">
            <summary>
            Data type mismatch
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Misuse">
            <summary>
            Library used incorrectly
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NoLfs">
            <summary>
            Uses OS features not supported on host
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Auth">
            <summary>
            Authorization denied
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Format">
            <summary>
            Auxiliary database format error
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Range">
            <summary>
            2nd parameter to sqlite3_bind out of range
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NotADb">
            <summary>
            File opened that is not a database file
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Notice">
            <summary>
            Notifications from sqlite3_log()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Warning">
            <summary>
            Warnings from sqlite3_log()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Row">
            <summary>
            sqlite3_step() has another row ready
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Done">
            <summary>
            sqlite3_step() has finished executing
            </summary>
        </member>
        <member name="T:Au.Types.DIcon">
            <summary>
            Standard icons for <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DIcon.App">
            <summary>
            Use <msdn>IDI_APPLICATION</msdn> icon from unmanaged resources of this program file or main assembly.
            If there are no icons - default program icon.
            C# compilers add app icon with this id. The <b>DIcon.App</b> value is = <b>IDI_APPLICATION</b> (32512).
            If this program file contains multiple native icons in range DIcon.App to 0xf000, you can specify them like <c>DIcon.App+1</c>.
            </summary>
        </member>
        <member name="T:Au.Types.DEdit">
            <summary>
            Text edit field type for <see cref="M:Au.dialog.showInput(System.String@,System.String,System.String,Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String},Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>, <see cref="M:Au.dialog.SetEditControl(Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String})"/>, etc.
            </summary>
        </member>
        <member name="T:Au.Types.DFlags">
            <summary>
            Flags for <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CommandLinks">
            <summary>
            Display custom buttons as a column of command-links, not as a row of classic buttons.
            Command links can have multi-line text. The first line has bigger font.
            More info about custom buttons: <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.ExpandDown">
            <summary>
            Show expanded text in footer.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Wider">
            <summary>
            Set <see cref="P:Au.dialog.Width"/> = 700.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.XCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CenterOwner">
            <summary>
            Show the dialog in the center of the owner window.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CenterMouse">
            <summary>
            Show the dialog at the mouse position. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.RawXY">
            <summary>
            x y are relative to the primary screen (ignore <see cref="P:Au.dialog.Screen"/> etc).
            More info: <see cref="M:Au.dialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. 
            </summary>
        </member>
        <member name="T:Au.Types.DControls">
            <summary>
            Used with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions to add more controls and get their final values.
            </summary>
        </member>
        <member name="P:Au.Types.DControls.Checkbox">
            <summary>
            If not null, adds checkbox with this text.
            </summary>
        </member>
        <member name="P:Au.Types.DControls.IsChecked">
            <summary>
            Sets initial and gets final checkbox value (true if checked).
            </summary>
        </member>
        <member name="P:Au.Types.DControls.RadioButtons">
            <summary>
            If not null, adds radio buttons.
            A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".
            </summary>
        </member>
        <member name="P:Au.Types.DControls.RadioId">
            <summary>
            Sets initial and gets final checked radio button. It is button id (as specified in <see cref="P:Au.Types.DControls.RadioButtons"/>), not index.
            See <see cref="M:Au.dialog.SetRadioButtons(System.String,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.DControls.EditType">
            <summary>
            If set (not None, which is default), adds a text edit control.
            Note: then the dialog cannot have a progress bar.
            </summary>
        </member>
        <member name="P:Au.Types.DControls.EditText">
            <summary>
            Sets initial and gets final text edit control value.
            </summary>
        </member>
        <member name="P:Au.Types.DControls.ComboboxValues">
            <summary>
            Sets combo box items used when <see cref="P:Au.Types.DControls.EditType"/> is Combo.
            </summary>
        </member>
        <member name="T:Au.Types.DEventArgs">
            <summary>
            Arguments for <see cref="T:Au.dialog"/> event handlers.
            </summary>
            <remarks>
            To return a non-zero value from the callback function, assign the value to the <b>returnValue</b> field.
            More info: <msdn>TaskDialogCallbackProc</msdn>.
            </remarks>
        </member>
        <member name="F:Au.Types.DEventArgs.message">
            <summary>Reference: <msdn>task dialog notifications</msdn>.</summary>
        </member>
        <member name="P:Au.Types.DEventArgs.LinkHref">
            <summary>
            Clicked hyperlink href attribute value. Use in <see cref="E:Au.dialog.HyperlinkClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.Button">
            <summary>
            Clicked button id. Use in <see cref="E:Au.dialog.ButtonClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.TimerTimeMS">
            <summary>
            Dialog timer time in milliseconds. Use in <see cref="E:Au.dialog.Timer"/> event handler.
            The event handler can set <b>returnValue</b>=1 to reset this.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.DontCloseDialog">
            <summary>
            Your <see cref="E:Au.dialog.ButtonClicked"/> event handler function can use this to prevent closing the dialog.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.EditText">
            <summary>
            Gets or sets edit field text.
            </summary>
        </member>
        <member name="T:Au.Types.DSend">
            <summary>
            Can be used through <see cref="P:Au.dialog.Send"/>, to interact with dialog while it is open.
            </summary>
            <remarks>
            Example (in an event handler): <c>e.d.Close();</c>
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Message(Au.Types.DNative.TDM,System.IntPtr,System.IntPtr)">
            <summary>
            Sends a message to the dialog.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example (in an event handler): <c>e.d.Send.Message(DNative.TDM.CLICK_VERIFICATION, 1);</c>
            Also there are several other functions to send some messages: change text, close dialog, enable/disable buttons, update progress.
            Reference: <msdn>task dialog messages</msdn>.
            NAVIGATE_PAGE currently not supported.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeText1(System.String,System.Boolean)">
            <summary>
            Changes the main big-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeText2(System.String,System.Boolean)">
            <summary>
            Changes the main small-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeFooterText(System.String,System.Boolean)">
            <summary>
            Changes the footer text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeExpandedText(System.String,System.Boolean)">
            <summary>
            Changes the expanded area text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Close(System.Int32)">
            <summary>
            Clicks a button. Normally it closes the dialog.
            </summary>
            <param name="buttonId">A button id or some other number that will be returned by ShowDialog.</param>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message DNative.TDM.CLICK_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.EnableButton(System.Int32,System.Boolean)">
            <summary>
            Enables or disables a button.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example: <c>d.Created += e => { e.d.Send.EnableButton(4, false); };</c>
            Sends message DNative.TDM.ENABLE_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Progress(System.Int32)">
            <summary>
            Sets progress bar value, 0 to 100.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message DNative.TDM.SET_PROGRESS_BAR_POS.
            </remarks>
        </member>
        <member name="T:Au.Types.DNative">
            <summary>
            Rarely used constants for native API used by <see cref="T:Au.dialog"/>.
            </summary>
            <remarks>
            Constants are in enums. Enum name is constant prefix. Enum members are without prefix. For example for <b>TDM_CLICK_BUTTON</b> use <c>DNative.TDM.CLICK_BUTTON</c>.
            </remarks>
        </member>
        <member name="T:Au.Types.DNative.TDM">
            <summary>
            Messages that your <see cref="T:Au.dialog"/> event handler can send to the dialog.
            </summary>
        </member>
        <member name="T:Au.Types.DNative.TDN">
            <summary>
            Notification messages that your <see cref="T:Au.dialog"/> event handler receives.
            </summary>
        </member>
        <member name="T:Au.Types.DNative.TDE">
            <summary>
            Constants for DNative.TDM.SET_ELEMENT_TEXT and DNative.TDM.UPDATE_ELEMENT_TEXT messages and dialog.Send.Text().
            Used with <see cref="T:Au.dialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DNative.TDIE">
            <summary>
            Constants for DNative.TDM.UPDATE_ICON message used with <see cref="T:Au.dialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.OsdWindow">
            <summary>
            Transparent window that can be used for on-screen display. Derived classes on it can draw non-transparent text, rectangle, image, anything.
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Dispose(System.Boolean)">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Dispose">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Close">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="P:Au.Types.OsdWindow.Hwnd">
            <summary>OSD window handle or default(wnd).</summary>
        </member>
        <member name="P:Au.Types.OsdWindow.IsHandleCreated">
            <summary>
            Returns true if the OSD window is created.
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Redraw">
            <summary>
            Redraws the OSD window immediately.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Invalidate">
            <summary>
            Sets to redraw the OSD window later.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="P:Au.Types.OsdWindow.Opacity">
            <summary>
            Gets or sets the opacity of the OSD window, from 0 to 1.
            If 1 (default), completely opaque. If 0, pixels of <see cref="P:Au.Types.OsdWindow.TransparentColor"/> are transparent, others opaque. If between 0 and 1, partially transparent.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.TransparentColor">
            <summary>
            Gets or sets transparent color, default 0xF5F4F5. Pixels of this color will be transparent, unless <see cref="P:Au.Types.OsdWindow.Opacity"/> is not 0.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Note: when used for transparent text, text edges are blended with this color, and it can become visible if the color is not chosen carefully.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.Visible">
            <summary>
            Gets or sets whether the OSD window is visible.
            The 'set' function calls <see cref="M:Au.Types.OsdWindow.Show"/> (it creates OSD window if need) or <see cref="M:Au.Types.OsdWindow.Hide"/> (it does not destroy the OSD window).
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.Show">
            <summary>
            Shows the OSD window. Creates if need.
            </summary>
            <remarks>
            In any case, also moves the window to the top of the Z order.
            </remarks>
        </member>
        <member name="M:Au.Types.OsdWindow.Hide">
            <summary>
            Hides the OSD window. Does not destroy; use <see cref="M:Au.Types.OsdWindow.Close"/> or <see cref="M:Au.Types.OsdWindow.Dispose(System.Boolean)"/> for it.
            Does nothing if not created or not visible.
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.WndProc(Au.wnd,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Called when the OSD window receives a message.
            If your derived class overrides this function, it must call base.WndProc and return its return value, except when don't need default processing.
            </summary>
        </member>
        <member name="M:Au.Types.OsdWindow.OnPaint(System.IntPtr,System.Drawing.Graphics,Au.Types.RECT)">
            <summary>
            Called when the OSD window must be drawn or redrawn.
            Derived classes should override this function and draw anything. Don't need to call base.OnPaint of <see cref="T:Au.Types.OsdWindow"/>, it does nothing.
            </summary>
            <remarks>
            If <see cref="P:Au.Types.OsdWindow.Opacity"/> is 0 (default), <i>g</i> is filled with <see cref="P:Au.Types.OsdWindow.TransparentColor"/>. Pixels of this color will be transparent. The base class draws only non-transparent areas.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Types.OsdWindow.Name">
            <summary>
            OSD window name. Optional, default null.
            </summary>
            <remarks>
            This text is invisible. Can be used to find OSD window. The class name is "Au.OSD"; if with shadow - "Au.OSD2".
            </remarks>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.Types.OsdWindow.closeAll(System.String)">
            <summary>
            Closes all OSD windows of this process.
            </summary>
            <param name="name">If not null, closes only OSD windows whose <see cref="P:Au.Types.OsdWindow.Name"/> matches this [](xref:wildcard_expression).</param>
        </member>
        <member name="T:Au.Types.OsdMode">
            <summary>
            Whether <see cref="M:Au.osdText.Show"/> waits or shows the OSD window in this or new thread.
            </summary>
            <remarks>
            If this thread has windows, any value can be used, but usually <b>Auto</b> (default) or <b>ThisThread</b> is the best.
            </remarks>
        </member>
        <member name="F:Au.Types.OsdMode.Auto">
            <summary>Depends on <see cref="M:Au.process.thisThreadHasMessageLoop(System.Boolean@)"/>. If it is true, uses <b>ThisThread</b>, else <b>StrongThread</b>. Does not wait.</summary>
        </member>
        <member name="F:Au.Types.OsdMode.ThisThread">
            <summary>
            Show the OSD window in this thread and don't wait.
            Don't use if this thread does not process messages and therefore cannot have windows.
            </summary>
        </member>
        <member name="F:Au.Types.OsdMode.WeakThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=true, so that the OSD is closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdMode.StrongThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=false, so that the OSD is not closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdMode.Wait">
            <summary>
            Show the OSD window in this thread and wait until it disappears.
            Waits <see cref="P:Au.osdText.SecondsTimeout"/> seconds. While waiting, dispatches messages etc; see <see cref="M:Au.wait.doEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.MTImage">
            <summary>
            Used for menu/toolbar function parameters to specify an image in different ways (file path, Image object, etc).
            </summary>
            <remarks>
            Has implicit conversions from string, <see cref="T:System.Drawing.Image"/>, <see cref="T:Au.icon"/>, <see cref="T:Au.Types.StockIcon"/>, <see cref="T:Au.Types.FolderPath"/>.
            More info: <see cref="T:Au.MTBase"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.MTImage.op_Implicit(System.String)~Au.Types.MTImage">
            
        </member>
        <member name="M:Au.Types.MTImage.op_Implicit(System.Drawing.Image)~Au.Types.MTImage">
            
        </member>
        <member name="M:Au.Types.MTImage.op_Implicit(Au.icon)~Au.Types.MTImage">
            
        </member>
        <member name="M:Au.Types.MTImage.op_Implicit(Au.Types.StockIcon)~Au.Types.MTImage">
            
        </member>
        <member name="M:Au.Types.MTImage.op_Implicit(Au.Types.FolderPath)~Au.Types.MTImage">
            
        </member>
        <member name="P:Au.Types.MTImage.Value">
            <summary>
            Gets the raw value stored in this variable. Can be <b>string</b>, <b>Image</b>, <b>icon</b>, <b>StockIcon</b> or null.
            </summary>
        </member>
        <member name="T:Au.Types.MSFlags">
            <summary>
            Flags for <see cref="T:Au.popupMenu"/> <b>ShowX</b> methods.
            </summary>
            <remarks>
            Most flags are for API <msdn>TrackPopupMenuEx</msdn>.
            </remarks>
        </member>
        <member name="F:Au.Types.MSFlags.ByCaret">
            <summary>Show by caret (text cursor) position. If not possible, depends on flag <b>ScreenCenter</b> or parameter <i>xy</i>.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.ScreenCenter">
            <summary>Show in center of screen containing mouse pointer.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.Underline">
            <summary>Underline characters preceded by &amp;, regardless of Windows settings. More info: <see cref="M:Au.More.StringUtil.RemoveUnderlineChar(System.String,System.Char)"/>.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.AlignCenterH">
            <summary>Horizontally align the menu so that the show position would be in its center.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.AlignRight">
            <summary>Horizontally align the menu so that the show position would be at its right side.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.AlignCenterV">
            <summary>Vertically align the menu so that the show position would be in its center.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.AlignBottom">
            <summary>Vertically align the menu so that the show position would at in its bottom.</summary>
        </member>
        <member name="F:Au.Types.MSFlags.AlignRectBottomTop">
            <summary>Show at bottom or top of <i>excludeRect</i>, not at righ/left.</summary>
        </member>
        <member name="T:Au.Types.MKHook">
            <summary>
            Used with <see cref="P:Au.popupMenu.KeyboardHook"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MKHook.Default">
            <summary>Process the key event as usually.</summary>
        </member>
        <member name="F:Au.Types.MKHook.Close">
            <summary>Close the menu.</summary>
        </member>
        <member name="F:Au.Types.MKHook.None">
            <summary>Do nothing.</summary>
        </member>
        <member name="T:Au.Types.TBItemType">
            <summary>
            Used with <see cref="P:Au.toolbar.ToolbarItem.ItemType"/>.
            </summary>
        </member>
        <member name="T:Au.Types.TBFlags">
            <summary>
            Used with <see cref="P:Au.toolbar.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBFlags.ActivateOwnerWindow">
            <summary>
            Activate the owner window when the toolbar clicked. Default.
            </summary>
        </member>
        <member name="F:Au.Types.TBFlags.HideWhenFullScreen">
            <summary>
            Hide the toolbar when a full-screen window is active. Default.
            </summary>
        </member>
        <member name="T:Au.Types.TBBorder">
            <summary>
            Used with <see cref="P:Au.toolbar.Border"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBBorder.None">
            <summary>No border.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Width1">
            <summary>1 pixel border.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Width2">
            <summary>1 pixel border + 1 pixel padding.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Width3">
            <summary>1 pixel border + 2 pixels padding.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Width4">
            <summary>1 pixel border + 3 pixels padding.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.ThreeD">
            <summary>3D border.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Thick">
            <summary>Standard window border.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.Caption">
            <summary>Title bar and standard window border.</summary>
        </member>
        <member name="F:Au.Types.TBBorder.CaptionX">
            <summary>Title bar, [x] button and standard window border.</summary>
        </member>
        <member name="T:Au.Types.TBAnchor">
            <summary>
            Used with <see cref="P:Au.toolbar.Anchor"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.TopLeft">
            <summary>
            Anchors are top and left edges. Default.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.TopRight">
            <summary>
            Anchors are top and right edges.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.BottomLeft">
            <summary>
            Anchors are bottom and left edges.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.BottomRight">
            <summary>
            Anchors are bottom and right edges.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.TopLR">
            <summary>
            Anchors are top, left and right edges. The toolbar is resized horizontally when resizing its owner.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.BottomLR">
            <summary>
            Anchors are bottom, left and right edges. The toolbar is resized horizontally when resizing its owner.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.LeftTB">
            <summary>
            Anchors are left, top and bottom edges. The toolbar is resized vertically when resizing its owner.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.RightTB">
            <summary>
            Anchors are right, top and bottom edges. The toolbar is resized vertically when resizing its owner.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.All">
            <summary>
            Anchors are all edges. The toolbar is resized when resizing its owner.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.OppositeEdgeX">
            <summary>
            Use owner's opposite left/right edge than specified. In other words, attach toolbar's left edge to owner's right edge or vice versa.
            This flag is for toolbars that normally are outside of the owner rectangle (at the left or right).
            This flag cannot be used with <b>TopLR</b>, <b>BottomLR</b>, <b>All</b>.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.OppositeEdgeY">
            <summary>
            Use owner's opposite top/bottom edge than specified. In other words, attach toolbar's top edge to owner's bottom edge or vice versa.
            This flag is for toolbars that normally are outside of the owner rectangle (above or below).
            This flag cannot be used with <b>LeftTB</b>, <b>RightTB</b>, <b>All</b>.
            </summary>
        </member>
        <member name="F:Au.Types.TBAnchor.Screen">
            <summary>
            Anchor is screen, not owner window. Don't move the toolbar together with its owner window.
            </summary>
        </member>
        <member name="T:Au.Types.TBOffsets">
            <summary>
            Used with <see cref="P:Au.toolbar.Offsets"/>.
            </summary>
        </member>
        <member name="P:Au.Types.TBOffsets.Left">
            <summary>
            Horizontal distance from the owner's left edge (right if <see cref="F:Au.Types.TBAnchor.OppositeEdgeX"/>) to the toolbar's left edge.
            </summary>
        </member>
        <member name="P:Au.Types.TBOffsets.Top">
            <summary>
            Vertical distance from the owner's top edge (bottom if <see cref="F:Au.Types.TBAnchor.OppositeEdgeY"/>) to the toolbar's top edge.
            </summary>
        </member>
        <member name="P:Au.Types.TBOffsets.Right">
            <summary>
            Horizontal distance from the toolbar's right edge to the owner's right edge (left if <see cref="F:Au.Types.TBAnchor.OppositeEdgeX"/>).
            </summary>
        </member>
        <member name="P:Au.Types.TBOffsets.Bottom">
            <summary>
            Vertical distance from the toolbar's bottom edge to the owner's bottom edge (top if <see cref="F:Au.Types.TBAnchor.OppositeEdgeY"/>).
            </summary>
        </member>
        <member name="M:Au.Types.TBOffsets.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets all properties.
            </summary>
        </member>
        <member name="M:Au.Types.TBOffsets.Equals(Au.Types.TBOffsets)">
            
        </member>
        <member name="M:Au.Types.TBOffsets.ToString">
            
        </member>
        <member name="T:Au.Types.TBHide">
            <summary>
            Reasons to hide a toolbar. Used with <see cref="M:Au.toolbar.Hide(System.Boolean,Au.Types.TBHide)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBHide.Owner">
            <summary>Owner window is hidden, minimized, etc.</summary>
        </member>
        <member name="F:Au.Types.TBHide.FullScreen">
            <summary>A full-screen window is active. See flag <see cref="F:Au.Types.TBFlags.HideWhenFullScreen"/>.</summary>
        </member>
        <member name="F:Au.Types.TBHide.User">
            <summary>This and bigger flag values can be used by callers for any purpose. Value 0x10000.</summary>
        </member>
        <member name="T:Au.Types.TBLayout">
            <summary>
            Used with <see cref="P:Au.toolbar.Layout"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBLayout.HorizontalWrap">
            <summary>Default layout. Buttons are in single row. Wrapped when exceeds maximal row width. More rows can be added with <see cref="M:Au.toolbar.Group(System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.TBLayout.Vertical">
            <summary>Buttons are in single column, like in a popup menu. Separators are horizontal.</summary>
        </member>
        <member name="T:Au.Types.TBNoMenu">
            <summary>
            Used with <see cref="P:Au.toolbar.NoContextMenu"/>.
            </summary>
        </member>
        <member name="T:Au.Types.TBCtor">
            <summary>
            Flags for <see cref="T:Au.toolbar"/> constructor.
            </summary>
        </member>
        <member name="F:Au.Types.TBCtor.ResetSettings">
            <summary>
            Don't load saved settings. Delete the settings file of the toolbar, if exists.
            </summary>
        </member>
        <member name="F:Au.Types.TBCtor.DontSaveSettings">
            <summary>
            Don't load and save settings. No file will be created or opened.
            </summary>
        </member>
        <member name="T:Au.Types.TBScaling">
            <summary>
            Used with <see cref="P:Au.toolbar.DpiScaling"/>.
            </summary>
        </member>
        <member name="M:Au.Types.TBScaling.#ctor(System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            
        </member>
        <member name="F:Au.Types.TBScaling.size">
            <summary>
            Scale toolbar size and related properties.
            If default (null), scales size, except of empty toolbars created by <see cref="M:Au.toolbar.AutoHideScreenEdge(Au.Triggers.MouseTriggerArgs,Au.Types.Coord,Au.Types.Coord,System.Int32,Au.Types.TBCtor,System.String,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.TBScaling.offsets">
            <summary>
            Scale toolbar offsets. See <see cref="P:Au.toolbar.Offsets"/>.
            If default (null), scales offsets, except when anchor is screen (not window etc).
            </summary>
        </member>
        <member name="T:Au.Types.ITBOwnerObject">
            <summary>
            Used with <see cref="M:Au.toolbar.Show(Au.wnd,Au.Types.ITBOwnerObject)"/>.
            </summary>
            <remarks>
            Allows a toolbar to follow an object in the owner window, for example a UI element or image. Or to hide in certain conditions.
            Define a class that implements this interface. Create a variable of that class and pass it to <see cref="M:Au.toolbar.Show(Au.wnd,Au.Types.ITBOwnerObject)"/>.
            The interface functions are called every 250 ms, sometimes more frequently. Not called when the owner window is invisible or cloaked or minimized.
            </remarks>
        </member>
        <member name="P:Au.Types.ITBOwnerObject.IsAlive">
            <summary>
            Returns false to close the toolbar.
            </summary>
            <remarks>
            Not called if the owner window is invisible or cloaked or minimized.
            The default implementation returns true.
            </remarks>
        </member>
        <member name="P:Au.Types.ITBOwnerObject.IsVisible">
            <summary>
            Returns false to hide the toolbar temporarily.
            </summary>
            <remarks>
            Not called if the owner window is invisible or cloaked or minimized.
            The default implementation returns true.
            </remarks>
        </member>
        <member name="M:Au.Types.ITBOwnerObject.GetRect(Au.Types.RECT@)">
            <summary>
            Gets object rectangle.
            Returns false if failed.
            </summary>
            <param name="r">Rectangle in screen coordinates.</param>
            <remarks>
            Not called if the owner window is invisible or cloaked or minimized or if <see cref="P:Au.Types.ITBOwnerObject.IsVisible"/> returned false.
            </remarks>
        </member>
        <member name="T:Au.Types.TINFlags">
            <summary>
            Flags for <see cref="M:Au.trayIcon.ShowNotification(System.String,System.String,Au.Types.TINFlags,Au.icon)"/>. See NIIF_ flags of API <msdn>NOTIFYICONDATAW</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.TINFlags.Realtime">
            <summary>
            Flag <b>NIF_REALTIME</b>.
            </summary>
        </member>
        <member name="T:Au.Types.WBPanelType">
            <summary>
            Used with <see cref="T:Au.wpfBuilder"/> constructor to specify the type of the root panel.
            </summary>
        </member>
        <member name="F:Au.Types.WBPanelType.Grid">
            
        </member>
        <member name="F:Au.Types.WBPanelType.Canvas">
            
        </member>
        <member name="F:Au.Types.WBPanelType.Dock">
            
        </member>
        <member name="F:Au.Types.WBPanelType.VerticalStack">
            
        </member>
        <member name="F:Au.Types.WBPanelType.HorizontalStack">
            
        </member>
        <member name="T:Au.Types.WBAdd">
            <summary>
            Flags for <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WBAdd.ChildOfLast">
            <summary>
            Add as child of <see cref="P:Au.wpfBuilder.Last"/>, which can be of type (or base type):
            - <see cref="T:System.Windows.Controls.ContentControl"/>. Adds as its <see cref="P:System.Windows.Controls.ContentControl.Content"/> property. For example you can add a <b>CheckBox</b> in a <b>Button</b>.
            - <see cref="T:System.Windows.Controls.Decorator"/>, for example <see cref="T:System.Windows.Controls.Border"/>. Adds as its <see cref="P:System.Windows.Controls.Decorator.Child"/> property.
            </summary>
        </member>
        <member name="F:Au.Types.WBAdd.DontSetProperties">
            <summary>
            Don't adjust some properties (padding, specified in <see cref="M:Au.wpfBuilder.Options(System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Windows.Thickness})"/>, etc) of some control types. Just set default margin, except if <i>ChildOfLast</i>.
            </summary>
        </member>
        <member name="T:Au.Types.WBLength">
            <summary>
            Used with <see cref="T:Au.wpfBuilder"/> functions for width/height parameters. Allows to specify minimal and/or maximal values too.
            </summary>
            <remarks>
            Has implicit conversions from double, Range and tuple (double length, Range minMax).
            To specify width or height, pass an integer or double value, like <c>100</c> or <c>15.25</c>.
            To specify minimal value, pass a range like <c>100..</c>.
            To specify maximal value, pass a range like <c>..100</c>.
            To specify minimal and maximal values, pass a range like <c>100..500</c>.
            To specify width or height and minimal or/and maximal values, pass a tuple like <c>(100, 50..)</c> or <c>(100, ..200)</c> or <c>(100, 50..200)</c>.
            </remarks>
        </member>
        <member name="M:Au.Types.WBLength.op_Implicit(System.Double)~Au.Types.WBLength">
            
        </member>
        <member name="M:Au.Types.WBLength.op_Implicit(System.Range)~Au.Types.WBLength">
            
        </member>
        <member name="M:Au.Types.WBLength.op_Implicit(System.ValueTuple{System.Double,System.Range})~Au.Types.WBLength">
            
        </member>
        <member name="M:Au.Types.WBLength.GetLength(System.Double@)">
            <summary>
            Gets the width or height value. Returns false if not set.
            </summary>
        </member>
        <member name="M:Au.Types.WBLength.GetMin(System.Int32@)">
            <summary>
            Gets the minimal value. Returns false if not set.
            </summary>
        </member>
        <member name="M:Au.Types.WBLength.GetMax(System.Int32@)">
            <summary>
            Gets the maximal value. Returns false if not set.
            </summary>
        </member>
        <member name="M:Au.Types.WBLength.ApplyTo(System.Windows.FrameworkElement,System.Boolean)">
            <summary>
            Sets <b>Width</b> or <b>Height</b> or/and <b>MinWidth</b>/<b>MinHeight</b> or/and <b>MaxWidth</b>/<b>MaxHeight</b> of the element.
            </summary>
            <param name="e">Element.</param>
            <param name="height">Set <b>Height</b>. If false, sets <b>Width</b>.</param>
        </member>
        <member name="T:Au.Types.WBGridLength">
            <summary>
            Used with <see cref="T:Au.wpfBuilder"/> functions to specify width/height of columns and rows. Allows to specify minimal and/or maximal values too.
            Like <see cref="T:Au.Types.WBLength"/>, but has functions to create <see cref="T:System.Windows.Controls.ColumnDefinition"/> and <see cref="T:System.Windows.Controls.RowDefinition"/>. Also has implicit conversion from these types.
            </summary>
        </member>
        <member name="M:Au.Types.WBGridLength.op_Implicit(System.Double)~Au.Types.WBGridLength">
            
        </member>
        <member name="M:Au.Types.WBGridLength.op_Implicit(System.ValueTuple{System.Double,System.Range})~Au.Types.WBGridLength">
            
        </member>
        <member name="M:Au.Types.WBGridLength.op_Implicit(System.Range)~Au.Types.WBGridLength">
            
        </member>
        <member name="M:Au.Types.WBGridLength.op_Implicit(System.Windows.Controls.DefinitionBase)~Au.Types.WBGridLength">
            
        </member>
        <member name="P:Au.Types.WBGridLength.Column">
            <summary>
            Creates column definition object from assigned width or/and min/max width values. Or just returns the assigned or previously created object.
            </summary>
        </member>
        <member name="P:Au.Types.WBGridLength.Row">
            <summary>
            Creates row definition object from assigned height or/and min/max height values. Or just returns the assigned or previously created object.
            </summary>
        </member>
        <member name="T:Au.Types.WBAlsoAllArgs">
            <summary>
            Arguments for <see cref="M:Au.wpfBuilder.AlsoAll(System.Action{Au.wpfBuilder,Au.Types.WBAlsoAllArgs})"/> callback function.
            </summary>
        </member>
        <member name="P:Au.Types.WBAlsoAllArgs.Column">
            <summary>
            Gets 0-based column index of last added control, or -1 if not in grid.
            </summary>
        </member>
        <member name="P:Au.Types.WBAlsoAllArgs.Row">
            <summary>
            Gets 0-based row index of last added control, or -1 if not in grid.
            </summary>
        </member>
        <member name="T:Au.Types.WBButtonClickArgs">
            <summary>
            Arguments for <see cref="M:Au.wpfBuilder.AddButton(System.Windows.Controls.Button@,System.Object,System.Action{Au.Types.WBButtonClickArgs},Au.Types.WBBFlags)"/> callback function.
            </summary>
        </member>
        <member name="P:Au.Types.WBButtonClickArgs.Button">
            <summary>
            Gets the button.
            </summary>
        </member>
        <member name="P:Au.Types.WBButtonClickArgs.Window">
            <summary>
            Gets the window.
            </summary>
        </member>
        <member name="T:Au.Types.WBBFlags">
            <summary>
            Flags for <see cref="M:Au.wpfBuilder.AddButton(System.Windows.Controls.Button@,System.Object,System.Action{Au.Types.WBButtonClickArgs},Au.Types.WBBFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WBBFlags.OK">
            <summary>It is OK button (<see cref="P:System.Windows.Controls.Button.IsDefault"/>, closes window, validates, <see cref="E:Au.wpfBuilder.OkApply"/> event).</summary>
        </member>
        <member name="F:Au.Types.WBBFlags.Cancel">
            <summary>It is Cancel button (<see cref="P:System.Windows.Controls.Button.IsCancel"/>, closes window).</summary>
        </member>
        <member name="F:Au.Types.WBBFlags.Apply">
            <summary>It is Apply button (size like OK/Cancel, validates, <see cref="E:Au.wpfBuilder.OkApply"/> event).</summary>
        </member>
        <member name="F:Au.Types.WBBFlags.Validate">
            <summary>Perform validation like OK and Apply buttons.</summary>
        </member>
        <member name="T:Au.Types.ClipFormats">
            <summary>
            Some clipboard format ids.
            These and other standard and registered format ids can be used with <see cref="T:Au.clipboardData"/> class functions.
            </summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Text">
            <summary>The text format. Standard, API constant CF_UNICODETEXT. The default format of <see cref="T:Au.clipboardData"/> add/get text functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Image">
            <summary>The image format. Standard, API constant CF_BITMAP. Used by <see cref="T:Au.clipboardData"/> add/get image functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Files">
            <summary>The file-list format. Standard, API constant CF_HDROP. Used by <see cref="T:Au.clipboardData"/> add/get files functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Html">
            <summary>The HTML format. Registered, name "HTML Format". Used by <see cref="T:Au.clipboardData"/> add/get HTML functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Rtf">
            <summary>The RTF format. Registered, name "Rich Text Format". Used by <see cref="T:Au.clipboardData"/> add/get RTF functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.ShellIDListArray_">
            <summary>Registered "Shell IDList Array" format.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.FileGroupDescriptorW_">
            <summary>Registered "FileGroupDescriptorW" format.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.ClipboardViewerIgnore">
            <summary>
            The "Clipboard Viewer Ignore" registered format.
            </summary>
            <remarks>
            Some clipboard viewer/manager programs don't try to get clipboard data if this format is present. For example Ditto, Clipdiary.
            The copy/paste functions of this library add this format to the clipboard to avoid displaying the temporary text/data in these programs, which also could make the paste function slower and less reliable.
            </remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)">
            <summary>
            Registers a clipboard format and returns its id. If already registered, just returns id.
            </summary>
            <param name="name">Format name.</param>
            <param name="textEncoding">Text encoding, if it's a text format. Used by <see cref="M:Au.clipboardData.getText(System.Int32)"/>, <see cref="M:Au.clipboardData.AddText(System.String,System.Int32)"/> and functions that call them. For example <see cref="P:System.Text.Encoding.UTF8"/> or <see cref="P:System.Text.Encoding.Default"/> (ANSI). If null, text of unknown formats is considered Unicode UTF-16 (no encoding/decoding needed).</param>
            <remarks>Calls API <msdn>RegisterClipboardFormat</msdn>.</remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.GetTextEncoding_(System.Int32,System.Boolean@)">
            <summary>
            Gets text encoding for format.
            Returns null if UTF-16 or if the format is unknown and not in s_textEncoding.
            </summary>
        </member>
        <member name="T:Au.Types.BIEvents">
            <summary>
            Used with <see cref="T:Au.inputBlocker"/> class to specify what user input types to block (keys, mouse).
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.None">
            <summary>
            Do not block.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.Keys">
            <summary>
            Block keys. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseClicks">
            <summary>
            Block mouse clicks and wheel. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseMoving">
            <summary>
            Block mouse moving. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.All">
            <summary>
            Block keys, mouse clicks, wheel and mouse moving. Except if generated by functions of this library.
            This flag incluses flags <b>Keys</b>, <b>MouseClicks</b> and <b>MouseMoving</b>.
            </summary>
        </member>
        <member name="T:Au.Types.PastingEventArgs">
            <summary>
            <see cref="E:Au.keys.Pasting"/> event data.
            </summary>
        </member>
        <member name="P:Au.Types.PastingEventArgs.Text">
            
        </member>
        <member name="P:Au.Types.PastingEventArgs.Options">
            
        </member>
        <member name="P:Au.Types.PastingEventArgs.WndFocus">
            
        </member>
        <member name="T:Au.Types.KMod">
            <summary>
            Modifier keys as flags.
            </summary>
            <remarks>
            The values don't match those in the .NET enum <see cref="T:System.Windows.Forms.Keys"/>. This library does not use the .NET enum for modifier keys, mostly because it: does not have Win as modifier flag; confusing names, for example Alt and Menu.
            </remarks>
            <seealso cref="M:Au.keys.more.KModToWinforms(Au.Types.KMod)"/>
            <seealso cref="M:Au.keys.more.KModFromWinforms(System.Windows.Forms.Keys)"/>
            <seealso cref="T:Au.Types.KKey"/>
        </member>
        <member name="T:Au.Types.KKey">
            <summary>
            Virtual-key codes.
            </summary>
            <remarks>
            The values are the same as the native VK_ constants. Also the same as in the <see cref="T:System.Windows.Forms.Keys"/> enum, but not as in the WPF <b>Key</b> enum.
            Some key names are different than VK_/Keys, for example Alt instead of VK_MENU/Menu.
            Most rare and obsolete keys are not included. You can use Keys or VK_ (int) like <c>(KKey)Keys.Attn</c>.
            This library does not use the .NET <b>Keys</b> enum, mostly because it includes modifier key flags and it's easy to confuse eg Shift (flag) with ShiftKey (key). Also this library does not use the WPF <b>Key</b> enum; its values don't match the native VK_ constants that must be used with API functions.
            </remarks>
            <seealso cref="T:Au.Types.KMod"/>
        </member>
        <member name="F:Au.Types.KKey.Break">
            <summary>Ctrl+Pause.</summary>
        </member>
        <member name="F:Au.Types.KKey.Clear">
            <summary>Shift+NumPad5, or NumPad5 when NumLock off.</summary>
        </member>
        <member name="F:Au.Types.KKey.D0">
            <summary>The 0 ) key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D1">
            <summary>The 1 ! key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D2">
            <summary>The 2 @ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D3">
            <summary>The 3 # key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D4">
            <summary>The 4 $ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D5">
            <summary>The 5 % key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D6">
            <summary>The 6 ^ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D7">
            <summary>The 7 &amp; key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D8">
            <summary>The 8 * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D9">
            <summary>The 9 ( key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Win">
            <summary>The left Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RWin">
            <summary>The right Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Apps">
            <summary>The Application/Menu key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Multiply">
            <summary>The numpad * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Add">
            <summary>The numpad + key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Subtract">
            <summary>The numpad - key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Decimal">
            <summary>The numpad . key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Divide">
            <summary>The numpad / key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LShift">
            <summary>The left Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RShift">
            <summary>The right Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LCtrl">
            <summary>The left Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RCtrl">
            <summary>The right Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LAlt">
            <summary>The left Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RAlt">
            <summary>The right Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Packet">
            <summary>VK_PACKET. Not a key.</summary>
        </member>
        <member name="T:Au.Types.KKeyScan">
            <summary>
            Virtual-key code (optional), scan code and extended-key flag for <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> and similar functions.
            </summary>
        </member>
        <member name="T:Au.Types.KKeysEtc">
            <summary>
            Parameter type of <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> and similar functions.
            Has implicit conversions from string, clipboardData, KKey, KKeyScan, int (sleep time) and Action.
            </summary>
        </member>
        <member name="P:Au.Types.KKeysEtc.Value">
            <summary>
            Raw value.
            </summary>
        </member>
        <member name="T:Au.Types.KHotkey">
            <summary>
            Defines a hotkey as <see cref="T:Au.Types.KMod"/> and <see cref="T:Au.Types.KKey"/>.
            Has implicit conversion operators from string like "Ctrl+Shift+K", tuple (KMod, KKey), enum KKey, enum Keys.
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Mod">
            <summary>
            Modifier keys (flags).
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Key">
            <summary>
            Key without modifier keys.
            </summary>
        </member>
        <member name="M:Au.Types.KHotkey.#ctor(Au.Types.KMod,Au.Types.KKey)">
            
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.String)~Au.Types.KHotkey">
            <summary>Implicit conversion from string like "Ctrl+Shift+K".</summary>
            <exception cref="T:System.ArgumentException">"Error in hotkey."</exception>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.ValueTuple{Au.Types.KMod,Au.Types.KKey})~Au.Types.KHotkey">
            <summary>Implicit conversion from tuple (KMod, KKey).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(Au.Types.KKey)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:Au.Types.KKey"/> (hotkey without modifiers).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.Windows.Forms.Keys)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:System.Windows.Forms.Keys"/> like <c>Keys.Ctrl|Keys.B</c>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Explicit(Au.Types.KHotkey)~System.Windows.Forms.Keys">
            <summary>Explicit conversion to <see cref="T:System.Windows.Forms.Keys"/>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.Deconstruct(Au.Types.KMod@,Au.Types.KKey@)">
            <summary>Allows to split a <b>KHotkey</b> variable like <c>var (mod, key) = hotkey;</c></summary>
        </member>
        <member name="T:Au.Types.MButton">
            <summary>
            <i>button</i> parameter type for <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/> and similar functions.
            </summary>
            <remarks>
            There are two groups of values:
            1. Button (Left, Right, Middle, X1, X2). Default or 0: Left.
            2. Action (Down, Up, DoubleClick). Default: click.
            
            Multiple values from the same group cannot be combined. For example Left|Right is invalid.
            Values from different groups can be combined. For example Right|Down.
            </remarks>
        </member>
        <member name="F:Au.Types.MButton.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Down">
            <summary>(flag) Press and don't release.</summary>
        </member>
        <member name="F:Au.Types.MButton.Up">
            <summary>(flag) Don't press, only release.</summary>
        </member>
        <member name="F:Au.Types.MButton.DoubleClick">
            <summary>(flag) Double-click.</summary>
        </member>
        <member name="T:Au.Types.MButtons">
            <summary>
            Flags for mouse buttons.
            Used with functions that check mouse button states (down or up).
            </summary>
            <remarks>
            The values are the same as <see cref="T:System.Windows.Forms.MouseButtons"/>, therefore can be cast to/from.
            </remarks>
        </member>
        <member name="F:Au.Types.MButtons.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="T:Au.Types.MRelease">
            <summary>
            At the end of <c>using(...) { ... }</c> block releases mouse buttons pressed by the function that returned this variable. See example.
            </summary>
            <example>
            Drag and drop: start at x=8 y=8, move 20 pixels down, drop.
            <code><![CDATA[
            using(mouse.leftDown(w, 8, 8)) mouse.moveRelative(0, 20); //the button is auto-released when the 'using' code block ends
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.MRelease.op_Implicit(Au.Types.MButton)~Au.Types.MRelease">
            
        </member>
        <member name="M:Au.Types.MRelease.Dispose">
            <summary>
            Releases mouse buttons pressed by the function that returned this variable.
            </summary>
        </member>
        <member name="T:Au.Types.MCursor">
            <summary>
            Standard cursor ids.
            Used with <see cref="M:Au.mouse.waitForCursor(System.Double,Au.Types.MCursor,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MCursor.Arrow">
            <summary>Standard arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.IBeam">
            <summary>I-beam (text editing).</summary>
        </member>
        <member name="F:Au.Types.MCursor.Wait">
            <summary>Hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Cross">
            <summary>Crosshair.</summary>
        </member>
        <member name="F:Au.Types.MCursor.UpArrow">
            <summary>Vertical arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNWSE">
            <summary>Double-pointed arrow pointing northwest and southeast.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNESW">
            <summary>Double-pointed arrow pointing northeast and southwest.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeWE">
            <summary>Double-pointed arrow pointing west and east.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNS">
            <summary>Double-pointed arrow pointing north and south.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeAll">
            <summary>Four-pointed arrow pointing north, south, east, and west.</summary>
        </member>
        <member name="F:Au.Types.MCursor.No">
            <summary>Slashed circle.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Hand">
            <summary>Hand.</summary>
        </member>
        <member name="F:Au.Types.MCursor.AppStarting">
            <summary>Standard arrow and small hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Help">
            <summary>Arrow and question mark.</summary>
        </member>
        <member name="T:Au.Types.ExtAu">
            <summary>
            Extension methods for types of this library.
            </summary>
        </member>
        <member name="M:Au.Types.ExtAu.MouseMove(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to this window.
            Calls <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtAu.MouseClick(Au.wnd,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to this window.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtAu.MouseMove(Au.elm,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to this UI element.
            Calls <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">UI element not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.elm.GetRect(Au.Types.RECT@,Au.wnd)"/>) or container window (<see cref="P:Au.elm.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtAu.MouseClick(Au.elm,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks this UI element.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">UI element not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.elm.GetRect(Au.Types.RECT@,Au.wnd)"/>) or container window (<see cref="P:Au.elm.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtAu.MouseMove(Au.uiimage,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the mouse to the found image.
            Calls <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Types.ExtAu.MouseClick(Au.uiimage,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks the found image.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="T:Au.Types.DpiOf">
            <summary>
            Used for <i>DPI</i> parameter of functions.
            Has implicit conversions from int (DPI), wnd (DPI of window), IntPtr (DPI of screen handle), POINT (DPI of screen containing point), RECT (DPI of screen containing rectangle), forms Control, WPF DependencyObject. The conversion operators set the <see cref="P:Au.Types.DpiOf.Dpi"/> property and the function can use it.
            </summary>
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(System.Int32)">
            
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(Au.wnd)">
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(System.Windows.Forms.Control)">
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(System.Windows.DependencyObject)">
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(System.IntPtr)">
            
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(Au.Types.POINT)">
            
        </member>
        <member name="M:Au.Types.DpiOf.#ctor(Au.Types.RECT)">
            
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(System.Int32)~Au.Types.DpiOf">
            
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(Au.wnd)~Au.Types.DpiOf">
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(System.Windows.Forms.Control)~Au.Types.DpiOf">
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(System.Windows.DependencyObject)~Au.Types.DpiOf">
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(System.IntPtr)~Au.Types.DpiOf">
            
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(Au.Types.POINT)~Au.Types.DpiOf">
            
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(Au.Types.RECT)~Au.Types.DpiOf">
            
        </member>
        <member name="P:Au.Types.DpiOf.Dpi">
            
        </member>
        <member name="M:Au.Types.DpiOf.op_Implicit(Au.Types.DpiOf)~System.Int32">
            
        </member>
        <member name="T:Au.Types.BSFlags">
            <summary>
            Flags for <see cref="M:Au.More.FastBuffer`1.GetString(System.Int32,System.String@,Au.Types.BSFlags,System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.BSFlags.Truncates">
            <summary>
            If buffer too small, the API gets part of string instead of returning required buffer length.
            </summary>
        </member>
        <member name="F:Au.Types.BSFlags.ReturnsLengthWith0">
            <summary>
            The API returns string length including the terminating null character.
            </summary>
        </member>
        <member name="T:Au.Types.HookData">
            <summary>
            Contains types of hook data for hook procedures set by <see cref="T:Au.More.WindowsHook"/> and <see cref="T:Au.More.WinEventHook"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.Keyboard">
            <summary>
            Event data for the hook procedure set by <see cref="M:Au.More.WindowsHook.Keyboard(System.Action{Au.Types.HookData.Keyboard},System.Boolean,System.Boolean)"/>.
            More info: API <msdn>LowLevelKeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Keyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.BlockEvent">
            <summary>
            Call this function to steal this event from other hooks and apps.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsExtended">
            <summary>
            Is extended key.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the keyboard.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsAlt">
            <summary>
            Key Alt is pressed.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsUp">
            <summary>
            Is key-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Mod">
            <summary>
            If the key is a modifier key (Shift, Ctrl, Alt, Win), returns the modifier flag. Else returns 0.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Key">
            <summary>
            If <b>vkCode</b> is a left or right modifier key code (LShift, LCtrl, LAlt, RShift, RCtrl, RAlt, RWin), returns the common modifier key code (Shift, Ctrl, Alt, Win). Else returns <b>vkCode</b>.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.IsKey(Au.Types.KKey)">
            <summary>
            Returns true if <i>key</i> == <b>vkCode</b> or <i>key</i> is Shift, Ctrl, Alt or Win and <b>vkCode</b> is LShift/RShift, LCtrl/RCtrl, LAlt/RAlt or RWin.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.SendInputFlags_">
            <summary>
            Converts flags to API SendInput flags KEYEVENTF_KEYUP and KEYEVENTF_EXTENDEDKEY.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Keyboard.vkCode">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.scanCode">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.flags">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.time">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.dwExtraInfo">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AuExtraInfo">
            <summary>
            Extra info value used by functions of this library that generate keyboard events. Low-level hooks receive it in <b>dwExtraInfo</b>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.Mouse">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.Mouse(System.Action{Au.Types.HookData.Mouse},System.Boolean,System.Boolean)"/>.
            More info: API <msdn>LowLevelMouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Mouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="M:Au.Types.HookData.Mouse.BlockEvent">
            <summary>
            Call this function to steal this event from other hooks and apps.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.Event">
            <summary>
            What event it is (button, move, wheel).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsMove">
            <summary>
            Is mouse-move event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonDown">
            <summary>
            Is button-down event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonUp">
            <summary>
            Is button-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButton">
            <summary>
            Is button event (down or up).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.Button">
            <summary>
            Converts <see cref="P:Au.Types.HookData.Mouse.Event"/> to <see cref="T:Au.Types.MButtons"/>.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsWheel">
            <summary>
            Is wheel event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the mouse.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Mouse.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Mouse.pt">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.mouseData">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.flags">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.time">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.dwExtraInfo">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.MouseEvent">
            <summary>
            Mouse hook event types. See <see cref="P:Au.Types.HookData.Mouse.Event"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCbt">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.code">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.wParam">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.lParam">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.ThreadCbt.Hwnd">
            <summary>Window handle.</summary>
        </member>
        <member name="P:Au.Types.HookData.ThreadCbt.ActivationInfo">
            <summary>
            Gets <see cref="F:Au.Types.HookData.CbtEvent.ACTIVATE"/> event info.
            </summary>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.ACTIVATE.</exception>
        </member>
        <member name="T:Au.Types.HookData.ThreadCbt.CBTACTIVATESTRUCT">
            <summary>
            API <msdn>CBTACTIVATESTRUCT</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.CBTACTIVATESTRUCT.fMouse">
            
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.CBTACTIVATESTRUCT.hWndActive">
            
        </member>
        <member name="P:Au.Types.HookData.ThreadCbt.CreationInfo">
            <summary>
            Gets <see cref="F:Au.Types.HookData.CbtEvent.CREATEWND"/> event info.
            You can modify x, y, cx, cy, and hwndInsertAfter.
            </summary>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.CREATEWND.</exception>
        </member>
        <member name="T:Au.Types.HookData.ThreadCbt.CBT_CREATEWND">
            <summary>
            API <msdn>CBT_CREATEWND</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.CBT_CREATEWND.lpcs">
            
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.CBT_CREATEWND.hwndInsertAfter">
            
        </member>
        <member name="T:Au.Types.HookData.CbtEvent">
            <summary>
            CBT hook event types. Used with <see cref="T:Au.Types.HookData.ThreadCbt"/>.
            More info: API <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadGetMessage">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32,System.Boolean)"/>.
            More info: API <msdn>GetMsgProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.msg">
            <summary>
            Message parameters.
            API <msdn>MSG</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadKeyboard">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.key">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.lParam">
            <summary>
            <i>lParam</i> of the key message. Specifies the key state, scan code, etc. See API <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.ThreadKeyboard.IsUp">
            <summary>
            Is key-up event.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadMouse">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>MouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.message">
            <summary>
            The mouse message, for example WM_MOUSEMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.m">
            <summary>
            More info about the mouse message.
            API <msdn>MOUSEHOOKSTRUCT</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.MOUSEHOOKSTRUCT">
            <summary>API <msdn>MOUSEHOOKSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.CWPSTRUCT">
            <summary>API <msdn>CWPSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.CWPRETSTRUCT">
            <summary>API <msdn>CWPRETSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProc">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CallWndProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.msg">
            <summary>
            Message parameters.
            API <msdn>CWPSTRUCT</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProcRet">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.More.WindowsHook.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CallWndRetProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.msg">
            <summary>
            Message parameters and the return value.
            API <msdn>CWPRETSTRUCT</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.ReplyMessage(System.Boolean)">
            <summary>
            Calls API API <msdn>ReplyMessage</msdn>, which allows to use <see cref="T:Au.elm"/> and COM in the hook procedure.
            </summary>
            <param name="cancelEvent">
            Don't notify the target window about the event, and don't call other hook procedures.
            This value is used instead of the return value of the hook procedure, which is ignored.
            </param>
            <remarks>
            It can be used as a workaround for this problem: in low-level hook procedure some functions don't work with some windows. For example cannot get a UI element or use a COM object. Error/exception "An outgoing call cannot be made since the application is dispatching an input-synchronous call (0x8001010D)".
            </remarks>
        </member>
        <member name="T:Au.Types.HookData.WinEvent">
            <summary>
            Hook data for the hook procedure set by <see cref="T:Au.More.WinEventHook"/>.
            More info: API <msdn>WinEventProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.event_">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.w">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.idObject">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.idChild">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.thread">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.WinEvent.time">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="M:Au.Types.HookData.WinEvent.GetElm">
            <summary>
            Calls <see cref="M:Au.elm.fromEvent(Au.wnd,Au.Types.EObjid,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.ColorInt">
            <summary>
            Color, as int in 0xAARRGGBB format.
            Can convert from/to <see cref="T:System.Drawing.Color"/>, <see cref="T:System.Windows.Media.Color"/>, int (0xAARRGGBB), Windows COLORREF (0xBBGGRR), string.
            </summary>
        </member>
        <member name="F:Au.Types.ColorInt.argb">
            <summary>
            Color value in 0xAARRGGBB format.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.Int32,System.Boolean)">
            <param name="colorARGB">Color value in 0xAARRGGBB or 0xRRGGBB format.</param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.UInt32,System.Boolean)">
            <param name="colorARGB">Color value in 0xAARRGGBB or 0xRRGGBB format.</param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Int32)~Au.Types.ColorInt">
            <summary>
            Converts from int color value in 0xRRGGBB or 0xAARRGGBB format.
            Sets alpha 0xFF.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.UInt32)~Au.Types.ColorInt">
            <summary>
            Converts from int color value in 0xRRGGBB or 0xAARRGGBB format.
            Sets alpha 0xFF.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Drawing.Color)~Au.Types.ColorInt">
            <summary>
            Converts from <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Windows.Media.Color)~Au.Types.ColorInt">
            <summary>
            Converts from <see cref="T:System.Windows.Media.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.FromString(System.String,Au.Types.ColorInt@)">
            <summary>
            Converts from color name (<see cref="M:System.Drawing.Color.FromName(System.String)"/>) or string "0xRRGGBB" or "#RRGGBB".
            </summary>
            <remarks>
            If s is a hex number that contains 6 or less hex digits, makes opaque (alpha 0xFF).
            If s is null or invalid, sets c.argb = 0 and returns false.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.FromBGR(System.Int32,System.Boolean)">
            <summary>
            Converts from Windows native COLORREF (0xBBGGRR to 0xAARRGGBB).
            </summary>
            <param name="colorBGR">Color in 0xBBGGRR format.</param>
            <param name="makeOpaque">If true, sets alpha = 0xFF. If null, sets alpha = 0xFF if it is 0 in <i>colorBGR</i>.</param>
        </member>
        <member name="M:Au.Types.ColorInt.ToBGR(System.Boolean)">
            <summary>
            Converts to Windows native COLORREF (0xBBGGRR from 0xAARRGGBB).
            Returns color in COLORREF format. Does not modify this variable.
            </summary>
            <param name="zeroAlpha">Set the alpha byte = 0.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Drawing.Color">
            <summary>Converts to <see cref="T:System.Drawing.Color"/>.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Windows.Media.Color">
            <summary>Converts to <see cref="T:System.Windows.Media.Color"/>.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.SwapRB(System.Int32)">
            <summary>
            Converts color from ARGB (0xAARRGGBB) to ABGR (0xAABBGGRR) or vice versa (swaps the red and blue bytes).
            ARGB is used in .NET, GDI+ and HTML/CSS.
            ABGR is used by most Windows API; aka COLORREF.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.SwapRB(System.UInt32)">
            <summary>
            Converts color from ARGB (0xAARRGGBB) to ABGR (0xAABBGGRR) or vice versa (swaps the red and blue bytes).
            ARGB is used in .NET, GDI+ and HTML/CSS.
            ABGR is used by most Windows API; aka COLORREF.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.FromHLS(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Converts from hue-luminance-saturation (HLS).
            </summary>
            <param name="H">Hue, 0 to 240.</param>
            <param name="L">Luminance, 0 to 240.</param>
            <param name="S">Saturation, 0 to 240.</param>
            <param name="bgr">Return color in 0xBBGGRR format. If false, 0xRRGGBB.</param>
            <returns>Color in 0xRRGGBB or 0xBBGGRR format, depending on <b>bgr</b>. Alpha 0.</returns>
        </member>
        <member name="M:Au.Types.ColorInt.ToHLS(System.Int32,System.Boolean)">
            <summary>
            Converts to hue-luminance-saturation (HLS).
            </summary>
            <param name="color">Color in 0xRRGGBB or 0xBBGGRR format, depending on <b>bgr</b>. Ignores alpha.</param>
            <param name="bgr"><i>color</i> is in 0xBBGGRR format. If false, 0xRRGGBB.</param>
            <returns>Hue, luminance and saturation. All 0 to 240.</returns>
        </member>
        <member name="M:Au.Types.ColorInt.GetPerceivedBrightness(System.Int32,System.Boolean)">
            <summary>
            Calculates color's perceived brightness.
            Returns 0 to 1.
            </summary>
            <param name="color">Color in 0xRRGGBB or 0xBBGGRR format, depending on <b>bgr</b>. Ignores alpha.</param>
            <param name="bgr"><i>color</i> is in 0xBBGGRR format. If false, 0xRRGGBB.</param>
            <remarks>
            Unlike <see cref="M:Au.Types.ColorInt.ToHLS(System.Int32,System.Boolean)"/> and <see cref="M:System.Drawing.Color.GetBrightness"/>, this function uses different weights for red, green and blue components.
            Ignores alpha.
            </remarks>
        </member>
        <member name="T:Au.Types.NoDoc">
            <summary>
            In DocFX-generated help files removes documentation and auto-generated links in TOC and class pages.
            </summary>
        </member>
        <member name="T:Au.Types.NativeApi">
            <summary>
            If a class is derived from this class, editor adds undeclared Windows API to its completion list.
            </summary>
        </member>
        <member name="T:Au.Types.NativeApi.l">
            
        </member>
        <member name="T:Au.Types.UsingEndAction">
            <summary>
            Invokes specified action (calls callback function) at the end of <c>using(...) { ... }</c>.
            Usually returned by functions. Example: <see cref="M:Au.opt.scope.mouse(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.UsingEndAction.#ctor(System.Action)">
            <summary>Sets action to be invoked when disposing this variable.</summary>
        </member>
        <member name="M:Au.Types.UsingEndAction.Dispose">
            <summary>Invokes the action if not null.</summary>
        </member>
        <member name="T:Au.Types.PSFormat">
            <summary>
            Used with <see cref="T:Au.Types.ParamStringAttribute"/> to specify string parameter format.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.None">
            
        </member>
        <member name="F:Au.Types.PSFormat.keys">
            <summary>
            Keys. See <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.wildex">
            <summary>
            [Wildcard expression](xref:wildcard_expression).
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.regexp">
            <summary>
            PCRE regular expression.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.regexpReplacement">
            <summary>
            PCRE regular expression replacement string.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.NetRegex">
            <summary>
            .NET regular expression.
            </summary>
        </member>
        <member name="T:Au.Types.ParamStringAttribute">
            <summary>
            A function parameter with this attribute is a string of the specified format, for example regular expression.
            Code editors should help to create correct string arguments: provide tools or reference, show errors.
            </summary>
        </member>
        <member name="M:Au.Types.ParamStringAttribute.#ctor(Au.Types.PSFormat)">
            
        </member>
        <member name="P:Au.Types.ParamStringAttribute.Format">
            
        </member>
        <member name="T:Au.Types.AuException">
            <summary>
            The base exception class used in this library.
            Thrown when something fails and there is no better exception type for that failure.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then <see cref="P:Au.Types.AuException.Message"/> will contain its error description.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String,System.Exception)">
            <summary>
            Sets <b>Message</b> = <i>message</i> (default "Failed.").
            Sets <b>NativeErrorCode</b> = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
            Sets <b>NativeErrorCode</b> = <c>(errorCode != 0) ? errorCode : lastError.code</c>.
            Sets <b>Message</b> = <c>message + " " + lastError.messageFor(NativeErrorCode)</c>.
            </summary>
        </member>
        <member name="P:Au.Types.AuException.NativeErrorCode">
            <summary> Gets the Windows API error code. </summary>
        </member>
        <member name="P:Au.Types.AuException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="F:Au.Types.AuException.FormattedMessage">
            <summary> String created by FormatMessage(), which should be called by the Message override if null. Initially null. </summary>
        </member>
        <member name="M:Au.Types.AuException.FormatMessage(System.String,System.String)">
            <summary>
            Formats error message. Sets and returns FormattedMessage.
            As base text, uses the text passed to the constructor (default "Failed.").
            If it starts with "*", replaces the "*" with "Failed to ".
            If it ends with "*", replaces the "*" with commonPostfix if it is not empty.
            If then the message does not end with ".", appends ".".
            If appendMessage is null, uses lastError.messageFor(NativeErrorCode) if NativeErrorCode not 0.
            If then appendMessage is not empty, appends " " and appendMessage.
            Also appends InnerException.Message in new tab-indented line if InnerException is not null.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNot0(System.Int32,System.String)">
            <summary>
            If errorCode is not 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNegative(System.Int32,System.String)">
            <summary>
            If errorCode is less than 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="T:Au.Types.AuWndException">
            <summary>
            Exception thrown mostly by <see cref="T:Au.wnd"/> functions.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then Message also will contain its error description.
            If error code ERROR_INVALID_WINDOW_HANDLE, Message also depends on whether the window handle is 0.
            If parameter <i>errorCode</i> is 0 or not used: if the window handle is invalid, uses ERROR_INVALID_WINDOW_HANDLE.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If ends with "*", replaces the "*" with " window.". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.wnd,System.String,System.Exception)">
            <summary>
            Sets <b>Message</b> = <i>message</i> (default "Failed.").
            Sets <b>NativeErrorCode</b> = <c>w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE</c>.
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.wnd,System.Int32,System.String,System.Exception)">
            <summary>
            Sets <b>NativeErrorCode</b> = <c>(errorCode != 0) ? errorCode : (w.IsAlive ? lastError.code : ERROR_INVALID_WINDOW_HANDLE)</c>.
            Sets <b>Message</b> = <c>message + " " + lastError.messageFor(NativeErrorCode)</c>.
            </summary>
        </member>
        <member name="P:Au.Types.AuWndException.Window">
            <summary> Gets the window passed to the constructor. </summary>
        </member>
        <member name="P:Au.Types.AuWndException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="T:Au.Types.NotFoundException">
            <summary>
            Functions that search for an object can throw this exception when not found.
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor">
            <summary>
            Sets Message = "Not found.".
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            </summary>
        </member>
        <member name="T:Au.Types.JSettings">
            <summary>
            Base of records that contain various settings as public fields. Loads and lazily auto-saves from/to a JSON file.
            </summary>
            <remarks>
            All functions are thread-safe.
            </remarks>
            <example>
            <code><![CDATA[
            MySettings sett = MySettings.Load(); //normally you probably would use a static field or property, but this example uses a local variable for simplicity
            
            print.it(sett.i);
            sett.i++;
            
            if (dialog.showInput(out string s, "example", editText: sett.s)) {
            	sett.s = s;
            	
            	print.it("old array:", sett.a);
            	if ((!sett.a.Contains(s))) sett.a = sett.a.InsertAt(-1, s);
            	
            	print.it("old dictionary:", sett.d);
            	sett.d[s] = DateTime.Now;
            }
            
            
            record MySettings : JSettings {
            	public static readonly string File = folders.ThisAppDocuments + @"MySettings.json";
            
            	public static MySettings Load() => Load<MySettings>(File);
            	
            	// examples of settings
            	public int i;
            	public string s = "default";
            	public string[] a = Array.Empty<string>();
            	public Dictionary<string, DateTime> d = new();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.JSettings.Load``1(System.String,System.Boolean)">
            <summary>
            Loads JSON file and deserializes to new object of type T.
            Returns new empty object if file does not exist or failed to load or parse (invalid JSON) or <i>useDefault</i> true. If failed, writes error info in the output.
            Will auto-save soon after a property changed.
            </summary>
            <param name="file">Full path of .json file. If null, does not load and will not save.</param>
            <param name="useDefault">Use default settings, don't load from file. Delete file if exists.</param>
        </member>
        <member name="M:Au.Types.JSettings.Dispose">
            <summary>
            Call this when finished using the settings. Saves now if need, and stops autosaving.
            Don't need to call if the settings are used until process exit.
            </summary>
        </member>
        <member name="M:Au.Types.JSettings.SaveIfNeed">
            <summary>
            Saves now if need.
            Don't need to call explicitly. Autosaving is every 2 s, also on process exit and <b>Dispose</b>.
            </summary>
        </member>
        <member name="P:Au.Types.JSettings.LoadedFile">
            <summary>
            true if settings were loaded from file.
            </summary>
            <remarks>
            Returns false if <b>Load</b> did not find the file (the settings were not saved) or failed to load/parse or parameter <i>useDefault</i> = true or parameter <i>file</i> = null.
            </remarks>
        </member>
        <member name="T:Au.Types.OWarnings">
            <summary>
            Options for run-time warnings (<see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>).
            </summary>
        </member>
        <member name="M:Au.Types.OWarnings.#ctor(Au.Types.OWarnings)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="P:Au.Types.OWarnings.Verbose">
            <summary>
            If true, some library functions may display more warnings and other info.
            If not explicitly set, the default value depends on the build configuration of the main assembly: true if Debug, false if Release (optimize true). See <see cref="M:Au.More.AssemblyUtil_.IsDebug(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.OWarnings.Disable(System.String[])">
            <summary>
            Disables one or more run-time warnings.
            </summary>
            <param name="warningsWild">One or more warnings as case-insensitive wildcard strings. See <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>.</param>
            <remarks>
            Adds the strings to an internal list. When <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/> is called, it looks in the list. If finds the warning in the list, does not show the warning.
            It's easy to auto-restore warnings with 'using', like in the second example. Restoring is optional.
            </remarks>
            <example>
            This code at the start of script disables two warnings in all threads.
            <code><![CDATA[
            opt.init.warnings.Disable("*part of warning 1 text*", "*part of warning 2 text*");
            ]]></code>
            Temporarily disable all warnings in this thread.
            <code><![CDATA[
            opt.warnings.Verbose = true;
            print.warning("one");
            using(opt.warnings.Disable("*")) {
            	print.warning("two");
            }
            print.warning("three");
            ]]></code>
            Don't use code <c>using(opt.init.warnings.Disable...</c>, it's not thread-safe.
            </example>
        </member>
        <member name="M:Au.Types.OWarnings.IsDisabled(System.String)">
            <summary>
            Returns true if the specified warning text matches a wildcard string added with <see cref="M:Au.Types.OWarnings.Disable(System.String[])"/>.
            </summary>
            <param name="text">Warning text. Case-insensitive.</param>
        </member>
        <member name="T:Au.Types.OMouse">
            <summary>
            Options for functions of class <see cref="T:Au.mouse"/>.
            </summary>
            <remarks>
            Total <c>Click(x, y)</c> time is: mouse move + <see cref="P:Au.Types.OMouse.MoveSleepFinally"/> + button down + <see cref="P:Au.Types.OMouse.ClickSpeed"/> + button down + <see cref="P:Au.Types.OMouse.ClickSpeed"/> + <see cref="P:Au.Types.OMouse.ClickSleepFinally"/>.
            </remarks>
            <seealso cref="P:Au.opt.mouse"/>
            <seealso cref="P:Au.opt.init.mouse"/>
        </member>
        <member name="M:Au.Types.OMouse.#ctor(Au.Types.OMouse)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="P:Au.Types.OMouse.ClickSpeed">
            <summary>
            How long to wait (milliseconds) after sending each mouse button down or up event (2 events for click, 4 for double-click).
            Default: 20.
            </summary>
            <value>Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.opt.init.mouse"/>: 0 - 100 (1 s).</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OMouse.MoveSpeed">
            <summary>
            If not 0, makes mouse movements slower, not instant.
            Default: 0.
            </summary>
            <value>Valid values: 0 (instant) - 10000 (slowest). Valid values for <see cref="P:Au.opt.init.mouse"/>: 0 - 100.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that generate mouse movement events, except <see cref="M:Au.mouse.moveRecorded(System.String,System.Double)"/>.
            It is not milliseconds or some other unit. It adds intermediate mouse movements and small delays when moving the mouse cursor to the specified point. The speed also depends on the distance.
            Value 0 (default) does not add intermediate mouse movements. Adds at least 1 if some mouse buttons are pressed. Value 1 adds at least 1 intermediate mouse movement. Values 10-50 are good for visually slow movements.
            </remarks>
        </member>
        <member name="P:Au.Types.OMouse.ClickSleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'mouse click' or 'mouse wheel' function returns.
            Default: 10.
            </summary>
            <value>Valid values: 0 - 10000 (10 s). Valid values for <see cref="P:Au.opt.init.mouse"/>: 0 - 100.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'click' functions also sleep <see cref="P:Au.Types.OMouse.ClickSpeed"/> ms after button down and up. Default <b>ClickSpeed</b> is 20, default <b>ClickSleepFinally</b> is 10, therefore default click time without mouse-move is 20+20+10=50.
            </remarks>
        </member>
        <member name="P:Au.Types.OMouse.MoveSleepFinally">
            <summary>
            How long to wait (milliseconds) after moving the mouse cursor. Used in 'move+click' functions too.
            Default: 10.
            </summary>
            <value>Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.opt.init.mouse"/>: 0 - 100.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> (finally), <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> (between moving and clicking) and other functions that generate mouse movement events.
            </remarks>
        </member>
        <member name="P:Au.Types.OMouse.Relaxed">
            <summary>
            Make some functions less strict (throw less exceptions etc).
            Default: false.
            </summary>
            <remarks>
            This option is used by these functions:
            - <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            <br/>false - throw exception if cannot move the cursor to the specified x y. For example it the x y is not in screen.
            <br/>true - try to move anyway. Don't throw exception, regardless of the final cursor position (which probably will be at a screen edge).
            - <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            <br/>false - before moving the cursor, wait while a mouse button is pressed by the user or another thread. It prevents an unintended drag-drop.
            <br/>true - do not wait.
            - <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that click or press a mouse button using window coordinates:
            <br/>false - don't allow to click in another window. If need, activate the specified window (or its top-level parent). If that does not help, throw exception. However if the window is a control, allow x y anywhere in its top-level parent window.
            <br/>true - allow to click in another window. Don't activate the window and don't throw exception.
            </remarks>
        </member>
        <member name="T:Au.Types.OKey">
            <summary>
            Options for functions of class <see cref="T:Au.keys"/>.
            Some options also are used with <see cref="T:Au.clipboard"/> functions that send keys (Ctrl+V etc).
            </summary>
            <seealso cref="P:Au.opt.key"/>
            <seealso cref="P:Au.opt.init.key"/>
        </member>
        <member name="M:Au.Types.OKey.#ctor(Au.Types.OKey)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OKey.CopyOrDefault_(Au.Types.OKey)">
            <summary>
            Copies options from o, or sets default if o==null. Like ctor does.
            </summary>
        </member>
        <member name="M:Au.Types.OKey.GetHookOptionsOrThis_(Au.wnd)">
            <summary>
            Returns this variable, or <b>OKey</b> cloned from this variable and possibly modified by <b>Hook</b>.
            </summary>
            <param name="wFocus">The focused or active window. Use Lib.GetWndFocusedOrActive().</param>
        </member>
        <member name="P:Au.Types.OKey.TextSpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each character key. Used by <see cref="M:Au.keys.sendt(System.String,System.String)"/>. Also by <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> and similar functions for <c>"!text"</c> arguments.
            Default: 0.
            </summary>
            <value>Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.opt.init.key"/>: 0 - 10.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used only for 'text' arguments, not for 'keys' arguments. See <see cref="P:Au.Types.OKey.KeySpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.KeySpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each key. Used by <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> and similar functions, except for <c>"!text"</c> arguments.
            Default: 1.
            </summary>
            <value>Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.opt.init.key"/>: 0 - 10.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used only for 'keys' arguments, not for 'text' arguments. See <see cref="P:Au.Types.OKey.TextSpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.KeySpeedClipboard">
            <summary>
            How long to wait (milliseconds) between sending Ctrl+V and Ctrl+C keys of clipboard functions (paste, copy).
            Default: 5.
            </summary>
            <value>Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.opt.init.key"/>: 0 - 50.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            In most apps copy/paste works without this delay. Known apps that need it: Internet Explorer's address bar, BlueStacks.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.SleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'send keys or text' function returns.
            Default: 10.
            </summary>
            <value>Valid values: 0 - 10000 (10 seconds). Valid values for <see cref="P:Au.opt.init.key"/>: 0 - 100.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used by <see cref="M:Au.clipboard.copy(System.Boolean,Au.Types.OKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.TextHow">
            <summary>
            How to send text to the active window (keys, characters or clipboard).
            Default: <see cref="F:Au.Types.OKeyText.Characters"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OKey.PasteLength">
            <summary>
            To send text use clipboard (like with <see cref="F:Au.Types.OKeyText.Paste"/>) if text length is &gt;= this value.
            Default: 200.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OKey.PasteWorkaround">
            <summary>
            When pasting text that ends with space, tab or/and newline characters, remove them and after pasting send them as keys.
            Default: false.
            </summary>
            <remarks>
            Some apps trim these characters when pasting.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.RestoreClipboard">
            <summary>
            Whether to restore clipboard data when copying or pasting text.
            Default: true.
            By default restores only text. See also <see cref="P:Au.Types.OKey.RestoreClipboardAllFormats"/>, <see cref="P:Au.Types.OKey.RestoreClipboardExceptFormats"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OKey.RestoreClipboardAllFormats">
            <summary>
            When copying or pasting text, restore clipboard data of all formats that are possible to restore.
            Default: false - restore only text.
            </summary>
            <remarks>
            Restoring data of all formats set by some apps can be slow or cause problems. More info: <see cref="P:Au.Types.OKey.RestoreClipboardExceptFormats"/>.
            
            This property is static, not thread-static. It should be set (if need) at the start of script and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OKey.RestoreClipboard"/>
            <seealso cref="P:Au.Types.OKey.RestoreClipboardExceptFormats"/>
        </member>
        <member name="P:Au.Types.OKey.RestoreClipboardExceptFormats">
            <summary>
            When copying or pasting text, and <see cref="P:Au.Types.OKey.RestoreClipboardAllFormats"/> is true, do not restore clipboard data of these formats.
            Default: null.
            </summary>
            <remarks>
            To restore clipboard data, the copy/paste functions at first get clipboard data. Getting data of some formats set by some apps can be slow (100 ms or more) or cause problems (the app can change something in its window or even show a dialog).
            It also depends on whether this is the first time the data is being retrieved. The app can render data on demand, when some app is retrieving it from the clipboard first time; then can be slow etc.
            
            You can use function <see cref="M:Au.Types.OKey.PrintClipboard"/> to see format names and get-data times.
            
            There are several kinds of clipboard formats - registered, standard, private and display. Only registered formats have string names. For standard formats use API contant names, like "CF_WAVE". Private, display and metafile formats are never restored.
            These formats are never restored: CF_METAFILEPICT, CF_ENHMETAFILE, CF_PALETTE, CF_OWNERDISPLAY, CF_DSPx formats, CF_GDIOBJx formats, CF_PRIVATEx formats. Some other formats too, but they are automatically synthesized from other formats if need. Also does not restore if data size is 0 or &gt; 10 MB.
            
            This property is static, not thread-static. It should be set (if need) at the start of script and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OKey.RestoreClipboard"/>
            <seealso cref="M:Au.Types.OKey.PrintClipboard"/>
        </member>
        <member name="M:Au.Types.OKey.PrintClipboard">
            <summary>
            Writes to the output some info about current clipboard data.
            </summary>
            <remarks>
            Shows this info for each clipboard format: format name, time spent to get data (microseconds), data size (bytes), and whether this format would be restored (depends on <see cref="P:Au.Types.OKey.RestoreClipboardExceptFormats"/>).
            <note>Copy something to the clipboard each time before calling this function. Don't use <see cref="M:Au.clipboard.copy(System.Boolean,Au.Types.OKey)"/> and don't call this function in loop. Else it shows small times.</note>
            The time depends on app, etc. More info: <see cref="P:Au.Types.OKey.RestoreClipboardExceptFormats"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.NoModOff">
            <summary>
            When starting to send keys or text, don't release modifier keys.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OKey.NoCapsOff">
            <summary>
            When starting to send keys or text, don't turn off CapsLock.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OKey.NoBlockInput">
            <summary>
            While sending or pasting keys or text, don't block user-pressed keys.
            Default: false.
            </summary>
            <remarks>
            If false (default), user-pressed keys are sent afterwards. If true, user-pressed keys can be mixed with script-pressed keys, which is particularly dangerous when modifier keys are mixed (and combined) with non-modifier keys.
            </remarks>
        </member>
        <member name="P:Au.Types.OKey.Hook">
            <summary>
            Callback function that can modify options of 'send keys or text' functions depending on active window etc.
            Default: null.
            </summary>
            <remarks>
            The callback function is called by <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>, <see cref="M:Au.keys.sendt(System.String,System.String)"/>, <see cref="M:Au.keys.SendIt(System.Boolean)"/>, <see cref="M:Au.clipboard.paste(System.String,System.String,Au.Types.OKey)"/> and similar functions. Not called by <see cref="M:Au.clipboard.copy(System.Boolean,Au.Types.OKey)"/>.
            </remarks>
            <seealso cref="T:Au.Types.OKeyHookData"/>
        </member>
        <member name="T:Au.Types.OKeyHookData">
            <summary>
            Parameter type of the <see cref="P:Au.Types.OKey.Hook"/> callback function.
            </summary>
        </member>
        <member name="F:Au.Types.OKeyHookData.optk">
            <summary>
            Options used by the 'send keys or text' function. The callback function can modify them, except Hook, NoModOff, NoCapsOff, NoBlockInput.
            </summary>
        </member>
        <member name="F:Au.Types.OKeyHookData.w">
            <summary>
            The focused control. If there is no focused control - the active window. Use <c>w.Window</c> to get top-level window; if <c>w.Window == w</c>, <b>w</b> is the active window, else the focused control. The callback function is not called if there is no active window.
            </summary>
        </member>
        <member name="T:Au.Types.OKeyText">
            <summary>
            How functions send text.
            See <see cref="P:Au.Types.OKey.TextHow"/>.
            </summary>
            <remarks>
            There are three ways to send text to the active app using keys:
            - Characters (default) - use special key code VK_PACKET. Can send most characters.
            - Keys - use virtual-key codes, with Shift etc where need. Can send only characters that can be simply entered with the keyboard using current keyboard layout.
            - Paste - use the clipboard and Ctrl+V. Can send any text.
            
            Most but not all apps support all three ways.
            </remarks>
        </member>
        <member name="F:Au.Types.OKeyText.Characters">
            <summary>
            Send text characters using special key code VK_PACKET.
            This option is default. Few apps don't support it.
            For newlines sends key Enter, because VK_PACKET often does not work well.
            If text contains Unicode characters with Unicode code above 0xffff, clipboard-pastes whole text, because many apps don't support Unicode surrogates sent as WM_PACKET pairs.
            </summary>
        </member>
        <member name="F:Au.Types.OKeyText.KeysOrChar">
            <summary>
            Send virtual-key codes, with Shift etc where need.
            All apps support it.
            If a character cannot be simply typed with the keyboard using current keyboard layout, sends it like with the <b>Characters</b> option.
            </summary>
        </member>
        <member name="F:Au.Types.OKeyText.KeysOrPaste">
            <summary>
            Send virtual-key codes, with Shift etc where need.
            All apps support it.
            If text contains characters that cannot be simply typed with the keyboard using current keyboard layout, clipboard-pastes whole text.
            </summary>
        </member>
        <member name="F:Au.Types.OKeyText.Paste">
            <summary>
            Paste text using the clipboard and Ctrl+V.
            Few apps don't support it.
            This option is recommended for long text, because other ways then are too slow.
            Other options are unreliable when text length is more than 4000 and the target app is too slow to process sent characters. Then <see cref="P:Au.Types.OKey.TextSpeed"/> can help.
            Also, other options are unreliable when the target app modifies typed text, for example has such features as auto-complete, auto-indent or auto-correct. However some apps modify even pasted text, for example trim the last newline or space.
            When pasting text, previous clipboard data of some formats is lost. Text is restored by default.
            </summary>
        </member>
        <member name="T:Au.Types.OWait">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <seealso cref="P:Au.opt.wait"/>
            <seealso cref="M:Au.wait.forCondition(System.Double,System.Func{System.Boolean},Au.Types.OWait)"/>
            <seealso cref="T:Au.wait.Loop"/>
        </member>
        <member name="P:Au.Types.OWait.Period">
            <summary>
            The sleep time between checking the wait condition. Milliseconds.
            Default: 10.
            </summary>
            <value>Valid values: 1-1000.</value>
            <remarks>
            Most 'wait for' functions of this library use <see cref="T:Au.wait.Loop"/>, which repeatedly checks the wait condition and sleeps (waits) several ms. This property sets the initial sleep time, which then is incremented by <b>Period</b>/10 ms (default 1 ms) in each loop until reaches <b>Period</b>*50 (default 500 ms).
            This property makes the response time shorter or longer. If &lt;10, makes it shorter (faster response), but increases CPU usage; if &gt;10, makes it longer (slower response).
            </remarks>
            <seealso cref="P:Au.wait.Loop.Period"/>
            <example>
            <code><![CDATA[
            opt.wait.Period = 100;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.OWait.DoEvents">
            <summary>
            Use <see cref="M:Au.wait.doEvents(System.Int32)"/> instead of <see cref="M:Au.wait.ms(System.Int32)"/>.
            Default: false.
            </summary>
            <remarks>
            Use this property when need to process Windows messages, events, hooks, timers, etc while waiting. More info: <see cref="M:Au.wait.doEvents(System.Int32)"/>.
            </remarks>
            <seealso cref="M:Au.wait.forMessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
            <example>
            <code><![CDATA[
            opt.wait.DoEvents = true;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.OWait.#ctor(System.Int32,System.Boolean)">
            
        </member>
        <member name="T:Au.Types.Coord">
            <summary>
            Contains x or y coordinate in screen or some other rectangle that can be specified in various ways: normal, reverse, fraction, center, max.
            Used for parameters of functions like <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)"/>.
            </summary>
            <remarks>
            To specify a normal coordinate, assign an <b>int</b> value (implicit conversion from <b>int</b> to <b>Coord</b>). Else use static functions such as <b>Reverse</b>, <b>Fraction</b> (or assign float), <b>Center</b>, <b>Max</b>, <b>MaxInside</b>.
            Also there are functions to convert <b>Coord</b> to normal coodinates.
            </remarks>
        </member>
        <member name="P:Au.Types.Coord.Type">
            <summary>
            Value type.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Value">
            <summary>
            Non-fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.FractionValue">
            <summary>
            Fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.IsEmpty">
            <summary>
            Returns true if Type == None (when assigned default(Coord)).
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Int32)~Au.Types.Coord">
            <summary>
            Creates Coord of Normal type.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Single)~Au.Types.Coord">
            <summary>
            Creates Coord of Fraction type.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.UInt32)~Au.Types.Coord">
            
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Int64)~Au.Types.Coord">
            
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.UInt64)~Au.Types.Coord">
            
        </member>
        <member name="M:Au.Types.Coord.Reverse(System.Int32)">
            <summary>
            Creates Coord of Reverse type.
            Value 0 is at the right or bottom, and does not belong to the rectangle. Positive values are towards left or top.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Fraction(System.Double)">
            <summary>
            Creates Coord of Fraction type.
            Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
            Instead can be used implicit conversion from float, for example argument <c>Coord.Fraction(0.5)</c> can be replaced with <c>0.5f</c>.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Center">
            <summary>
            Returns <c>Fraction(0.5)</c>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Fraction(System.Double)"/>
        </member>
        <member name="P:Au.Types.Coord.Max">
            <summary>
            Returns <c>Reverse(0)</c>.
            This point will be outside of the rectangle. See also <see cref="P:Au.Types.Coord.MaxInside"/>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="P:Au.Types.Coord.MaxInside">
            <summary>
            Returns <c>Reverse(1)</c>.
            This point will be inside of the rectangle, at the very right or bottom, assuming the rectangle is not empty.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInRange(System.Int32,System.Int32)">
            <summary>
            Converts fractional/reverse coordinate to normal coordinate in a range.
            </summary>
            <param name="start">Start of range.</param>
            <param name="end">End of range.</param>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)">
            <summary>
            Converts fractional/reverse coordinates to normal coordinates in a rectangle.
            </summary>
            <param name="x">X coordinate relative to r.</param>
            <param name="y">Y coordinate relative to r.</param>
            <param name="r">The rectangle.</param>
            <param name="widthHeight">Use only width and height of r. If false (default), the function adds r offset (left and top).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center. Not used with widthHeight.</param>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInWindow(Au.Types.Coord,Au.Types.Coord,Au.wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the client area of a window. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the client area of w.</param>
            <param name="y">Y coordinate relative to the client area of w.</param>
            <param name="w">The window.</param>
            <param name="nonClient">x y are relative to the entire w rectangle, not to its client area.</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the specified screen (default - primary).</param>
            <param name="y">Y coordinate relative to the specified screen (default - primary).</param>
            <param name="workArea">x y are relative to the work area.</param>
            <param name="screen">If used, x y are relative to this screen. Default - primary screen. Example: <c>screen.index(1)</c>.</param>
            <param name="widthHeight">Use only width and height of the screen rectangle. If false, the function adds its offset (left and top, which can be nonzero if using the work area or a non-primary screen).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.ToString">
            
        </member>
        <member name="M:Au.Types.Coord.Equals(Au.Types.Coord)">
            
        </member>
        <member name="M:Au.Types.Coord.op_Equality(Au.Types.Coord,Au.Types.Coord)">
            
        </member>
        <member name="M:Au.Types.Coord.op_Inequality(Au.Types.Coord,Au.Types.Coord)">
            
        </member>
        <member name="M:Au.Types.Coord.GetHashCode">
            
        </member>
        <member name="T:Au.Types.CoordType">
            <summary>
            <see cref="T:Au.Types.Coord"/> variable value type.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.None">
            <summary>
            No value. The variable is default(Coord).
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Normal">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from left or top of a rectangle.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Reverse">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from right or bottom of a rectangle, towards left or top.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Fraction">
            <summary>
            <see cref="P:Au.Types.Coord.FractionValue"/> is fraction of a rectangle, where 0.0 is left or top, and 1.0 is right or bottom (outside of the rectangle).
            </summary>
        </member>
        <member name="T:Au.Types.PopupXY">
            <summary>
            Can be used to specify coordinates for various popup windows, like <c>new PopupXY(x, y)</c>, <c>(x, y)</c>, <c>PopupXY.In(rectangle)</c>, <c>PopupXY.Mouse</c>.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.#ctor(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)">
            <summary>
            Sets position and/or screen.
            </summary>
            <param name="x">X relative to the screen or work area. Default - center.</param>
            <param name="y">X relative to the screen or work area. Default - center.</param>
            <param name="workArea">x y are relative to the work area of the screen.</param>
            <param name="screen">Can be used to specify a screen. Default - primary. Example: <c>screen.index(1)</c>.</param>
            <remarks>
            Also there is are implicit conversions from tuple (x, y) and POINT. Instead of <c>new PopupXY(x, y)</c> you can use <c>(x, y)</c>. Instead of <c>new PopupXY(p.x, p.y, false)</c> you can use <c>p</c> or <c>(POINT)p</c> .
            </remarks>
        </member>
        <member name="M:Au.Types.PopupXY.In(Au.Types.RECT,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Creates new <b>PopupXY</b> that specifies position in a rectangle. For example of the owner window, like <c>PopupXY.In(myForm.Bounds)</c>.
            </summary>
            <param name="r">Rectangle relative to the primary screen.</param>
            <param name="x">X relative to the rectangle. Default - center.</param>
            <param name="y">Y relative to the rectangle. Default - center.</param>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>
            Creates new <b>PopupXY</b> that specifies position relative to the work area of the primary screen.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.POINT)~Au.Types.PopupXY">
            <summary>Creates new <b>PopupXY</b> that specifies position relative to the primary screen (not to the work area).</summary>
        </member>
        <member name="P:Au.Types.PopupXY.Mouse">
            <summary>
            Gets point coordinates below mouse cursor, for showing a tooltip-like popup.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.GetScreen">
            <summary>
            Gets <see cref="F:Au.Types.PopupXY.screen"/>.Now if not empty, else screen that contains the specified point.
            </summary>
        </member>
        <member name="T:Au.Types.FontNSS">
            <summary>
            Font name, size and style.
            If <b>Name</b> not set, will be used standard GUI font; then <b>Size</b> can be 0 to use size of standard GUI font.
            On high-DPI screen the font size will be scaled.
            </summary>
        </member>
        <member name="M:Au.Types.FontNSS.#ctor(System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Font name, size and style.
            If <b>Name</b> not set, will be used standard GUI font; then <b>Size</b> can be 0 to use size of standard GUI font.
            On high-DPI screen the font size will be scaled.
            </summary>
        </member>
        <member name="M:Au.Types.FontNSS.CreateFont(Au.Types.DpiOf)">
            <summary>
            Creates font.
            </summary>
            <param name="dpi">DPI for scaling.</param>
        </member>
        <member name="T:Au.Types.AnyWnd">
            <summary>
            Window handle.
            Used for function parameters where the function needs a window handle as <see cref="T:Au.wnd"/> but also allows to pass a variable of any of these types: System.Windows.Forms.Control (Form or control), System.Windows.DependencyObject (WPF window or control), IntPtr (window handle).
            </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(Au.wnd)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type wnd. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.IntPtr)~Au.Types.AnyWnd">
            <summary> Assignment of a window handle as IntPtr. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.Forms.Control)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.Forms.Control (Form or any control class). </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.DependencyObject)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.DependencyObject (WPF window or control). </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.Hwnd">
            <summary>
            Gets the window or control handle as wnd.
            Returns default(wnd) if not assigned.
            </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.IsEmpty">
            <summary>
            true if this is default(AnyWnd).
            </summary>
        </member>
        <member name="T:Au.Types.DStringList">
            <summary>
            Used for function parameters to specify multiple strings.
            Contains a string like "One|Two|Three" or string[] or List&lt;string&gt;. Has implicit conversions from these types.
            </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.String)~Au.Types.DStringList">
            <summary> Assignment of a value of type string. </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.String[])~Au.Types.DStringList">
            <summary> Assignment of a value of type string[]. </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.Collections.Generic.List{System.String})~Au.Types.DStringList">
            <summary> Assignment of a value of type List&lt;string&gt;. </summary>
        </member>
        <member name="P:Au.Types.DStringList.Value">
            <summary>
            The raw value.
            </summary>
        </member>
        <member name="M:Au.Types.DStringList.ToArray">
            <summary>
            Converts the value to string[].
            </summary>
        </member>
        <member name="T:Au.Types.PrintServerMessageType">
            <summary>
            See <see cref="P:Au.Types.PrintServerMessage.Type"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PrintServerMessageType.Write">
            <summary>
            Add line to the output window.
            All <see cref="T:Au.Types.PrintServerMessage"/> members can be used.
            </summary>
        </member>
        <member name="F:Au.Types.PrintServerMessageType.Clear">
            <summary>
            Clear the output window.
            Only <see cref="P:Au.Types.PrintServerMessage.Type"/> is used.
            </summary>
        </member>
        <member name="F:Au.Types.PrintServerMessageType.TaskEvent">
            <summary>
            Used internally to log events such as start/end of trigger actions.
            </summary>
        </member>
        <member name="T:Au.Types.PrintServerMessage">
            <summary>
            Contains message text and/or related info.
            More info: <see cref="T:Au.print.Server"/>, <see cref="M:Au.print.Server.GetMessage(Au.Types.PrintServerMessage@)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.PrintServerMessage.Type">
            <summary>
            Message type.
            Currently there are 2 types - Write and Clear.
            </summary>
        </member>
        <member name="P:Au.Types.PrintServerMessage.Text">
            <summary>
            Message text.
            Used with <see cref="F:Au.Types.PrintServerMessageType.Write"/>.
            </summary>
        </member>
        <member name="P:Au.Types.PrintServerMessage.TimeUtc">
            <summary>
            Message time in FILETIME format, UTC.
            Used with <see cref="F:Au.Types.PrintServerMessageType.Write"/>.
            To convert to string: <c>DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime().ToString()</c>.
            </summary>
        </member>
        <member name="P:Au.Types.PrintServerMessage.Caller">
            <summary>
            The <see cref="P:Au.script.name"/> property value of the process that called <see cref="M:Au.print.it(System.String)"/>.
            Used with <see cref="F:Au.Types.PrintServerMessageType.Write"/>.
            </summary>
        </member>
        <member name="M:Au.Types.PrintServerMessage.ToString">
            
        </member>
        <member name="T:Au.Types.SODefault">
            <summary>
            Used with <see cref="M:Au.screen.of(Au.wnd,Au.Types.SODefault,System.Boolean)"/> to specify what screen to return if the window/point/etc is not in a screen or if the window handle is invalid etc.
            </summary>
        </member>
        <member name="F:Au.Types.SODefault.Zero">
            <summary>Create empty variable.</summary>
        </member>
        <member name="F:Au.Types.SODefault.Primary">
            <summary>The primary screen.</summary>
        </member>
        <member name="F:Au.Types.SODefault.Nearest">
            <summary>The nearest screen. If window handle is invalid - the primary screen.</summary>
        </member>
        <member name="T:Au.Types.POINT">
            <summary>
            Point coordinates x y.
            </summary>
        </member>
        <member name="M:Au.Types.POINT.From(System.Drawing.PointF,System.Boolean)">
            <param name="p"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.POINT.From(System.Windows.Point,System.Boolean)">
            <param name="p"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.POINT.Offset(System.Int32,System.Int32)">
            <summary>Adds x and y to this.x and this.y.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Addition(Au.Types.POINT,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new POINT(p.x + d.x, p.y + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.SIZE">
            <summary>
            Width and height.
            </summary>
        </member>
        <member name="M:Au.Types.SIZE.From(System.Drawing.SizeF,System.Boolean)">
            <param name="z"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.SIZE.From(System.Windows.Size,System.Boolean)">
            <param name="z"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.SIZE.op_Addition(Au.Types.SIZE,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new SIZE(z.width + d.x, z.height + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.RECT">
            <summary>
            Rectangle coordinates left top right bottom.
            </summary>
            <remarks>
            This type can be used with Windows API functions. The .NET <b>Rectangle</b> etc can't, because their fields are different.
            Has conversions from/to <b>Rectangle</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets all fields.
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="width">Width (not <i>right</i>).</param>
            <param name="height">Height (not <i>bottom</i>).</param>
            <remarks>
            Sets <c>right = left + width; bottom = top + height;</c>. To specify right/bottom instead of width/height, use <see cref="M:Au.Types.RECT.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates <b>RECT</b> with specified <b>left</b>, <b>top</b>, <b>right</b> and <b>bottom</b>.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.op_Implicit(System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32})~Au.Types.RECT">
            <summary>
            Converts from tuple (left, top, width, height).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.From(System.Drawing.RectangleF,System.Boolean)">
            <param name="r"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.Types.RECT.From(System.Windows.Rect,System.Boolean)">
            <param name="r"></param>
            <param name="round">Can round up, for example 1.7 to 2.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="P:Au.Types.RECT.Is0">
            <summary>
            Returns true if all fields == 0.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.NoArea">
            <summary>
            Returns true if the rectangle area is empty or invalid: <c>right&lt;=left || bottom&lt;=top;</c>
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Width">
            <summary>
            Gets or sets width.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Height">
            <summary>
            Gets or sets height.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.XY">
            <summary>
            Returns <c>new POINT(left, top)</c>.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Size">
            <summary>
            Returns <c>new SIZE(Width, Height)</c>.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterX">
            <summary>
            Gets horizontal center.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterY">
            <summary>
            Gets vertical center.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.POINT)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle contains entire specified rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Inflate(System.Int32,System.Int32)">
            <summary>
            Makes this rectangle bigger or smaller: <c>left-=dx; right+=dx; top-=dy; bottom+=dy;</c>
            Use negative dx/dy to make the rectangle smaller. Note: too big negative dx/dy can make it invalid (right&lt;left or bottom&lt;top).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the intersection of itself and the specified rectangle.
            Returns true if the rectangles intersect.
            If they don't intersect, makes this RECT empty.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the intersection rectangle of two rectangles.
            If they don't intersect, returns empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.IntersectsWith(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle and another rectangle intersect.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Offset(System.Int32,System.Int32)">
            <summary>
            Moves this rectangle by the specified offsets: <c>left+=dx; right+=dx; top+=dy; bottom+=dy;</c>
            Negative dx moves to the left. Negative dy moves up.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Move(System.Int32,System.Int32)">
            <summary>
            Moves this rectangle so that <b>left</b>=<i>x</i> and <b>right</b>=<i>y</i>. Does not change <b>Width</b> and <b>Height</b>.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the union of itself and the specified rectangle.
            Union is the smallest rectangle that contains two full rectangles.
            Returns true if finally this rectangle is not empty.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the union of two rectangles.
            Union is the smallest rectangle that contains two full rectangles.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Normalize(System.Boolean)">
            <summary>
            If width or height are negative, modifies this rectangle so that they would not be negative.
            </summary>
            <param name="swap">true - swap right/left, bottom/top; false - set right = left, bottom = top.</param>
        </member>
        <member name="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in the specified screen, and ensures that whole rectangle is in screen.
            Final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - center. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - center. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="screen">Use this screen. If default, uses the primary screen. Example: <c>screen.index(1)</c>.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of rectangle is not in screen, move and/or resize it so that entire rectangle would be in screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.MoveInRect(Au.Types.RECT,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in another rectangle <i>r</i>.
            </summary>
            <param name="r">Another rectangle.</param>
            <param name="x">X coordinate relative to <i>r</i>. Default - center. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate relative to <i>r</i>. Default - center. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="ensureInRect">If part of rectangle is not in <i>r</i>, move and/or resize it so that entire rectangle would be in <i>r</i>.</param>
        </member>
        <member name="M:Au.Types.RECT.EnsureInScreen(Au.screen,System.Boolean)">
            <summary>
            Adjusts this rectangle to ensure that whole rectangle is in screen.
            Initial and final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="screen">Use this screen (see <see cref="T:Au.screen"/>). If default, uses screen of the rectangle (or nearest).</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.wnd.EnsureInScreen(Au.screen,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.ToString">
            <summary>
            Converts to string "{L=left T=top W=width H=height}".
            </summary>
            <seealso cref="M:Au.Types.RECT.TryParse(System.String,Au.Types.RECT@)"/>
        </member>
        <member name="M:Au.Types.RECT.ToStringSimple">
            <summary>
            Converts to string "left top width height".
            </summary>
            <seealso cref="M:Au.Types.RECT.TryParse(System.String,Au.Types.RECT@)"/>
        </member>
        <member name="M:Au.Types.RECT.ToStringFormat(System.String)">
            <summary>
            Formats string from RECT main fields and properties.
            </summary>
            <param name="format">
            <see cref="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)"/> format string. Example: <c>"({0}, {1}, {4}, {5})"</c>.
            This function passes to AppendFormat 6 values in this order: <b>left</b>, <b>top</b>, <b>right</b>, <b>bottom</b>, <b>Width</b>, <b>Height</b>.
            </param>
        </member>
        <member name="M:Au.Types.RECT.TryParse(System.String,Au.Types.RECT@)">
            <summary>
            Converts string to RECT.
            Returns false if invalid string format.
            </summary>
            <param name="s">String in format "{L=left T=top W=width H=height}" (<see cref="M:Au.Types.RECT.ToString"/>) or "left top width height" (<see cref="M:Au.Types.RECT.ToStringSimple"/>).</param>
            <param name="r"></param>
        </member>
        <member name="M:Au.Types.VARIANT.Dispose">
            <summary>
            Calls VariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToString">
            <summary>
            Converts to string.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToStringAndDispose">
            <summary>
            Converts to string.
            Disposes this VARIANT.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Is0">
            <summary>
            Returns true if the string is null.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Item(System.Int32)">
            <summary>
            Unsafe.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToString">
            <summary>
            Converts to string.
            Does not dispose.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToStringAndDispose">
            <summary>
            Converts to string and disposes.
            </summary>
        </member>
        <member name="T:Au.Types.STIFlags">
            <summary>
            Flags for <see cref="M:Au.ExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.NoHex">
            <summary>
            Don't support hexadecimal numbers (numbers with prefix "0x").
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.IsHexWithout0x">
            <summary>
            The number in string is hexadecimal without a prefix, like "1A".
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.DontSkipSpaces">
            <summary>
            Fail if string starts with a whitespace character.
            </summary>
        </member>
        <member name="T:Au.Types.SUpper">
            <summary>
            Used with <see cref="M:Au.ExtString.Upper(System.String,Au.Types.SUpper,System.Globalization.CultureInfo)"/>
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.AllChars">
            <summary>
            Convert all characters to upper case.
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.FirstChar">
            <summary>
            Convert only the first character to upper case.
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.TitleCase">
            <summary>
            Convert the first character of each word to upper case and other characters to lower case.
            Calls <see cref="M:System.Globalization.TextInfo.ToTitleCase(System.String)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatch">
            <summary>
            Regular expression match info.
            Used with <see cref="T:Au.regexp"/> class functions and String extension methods like <see cref="M:Au.ExtString.RegexMatch(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags,System.Nullable{System.Range})"/>.
            </summary>
            <remarks>
            Contains info about a regular expression match found in the subject string: index, length, substring, etc.
            Also contains an array of group matches, as <see cref="T:Au.Types.RXGroup"/>. Groups are regular expression parts enclosed in (), except (?...).
            Group matches can be accessed like array elements. Group 0 is whole match. Group 1 is the first group. See examples.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "ab cd-45-ef gh";
            if(s.RegexMatch(@"\b([a-z]+)-(\d+)\b", out RXMatch m))
            	print.it(
            		m.GroupCountPlusOne, //3 (whole match and 2 groups)
            		m.Start, //3, same as m[0].Index
            		m.Value, //"cd-45-ef", same as m[0].Value
            		m[1].Start, //3
            		m[1].Value, //"cd"
            		m[2].Start, //6
            		m[2].Value //"45"
            		);
            ]]></code>
            A group in the subject string may not exist even if whole match found. Then its Exists property is false, Index -1, Length 0, Value null.
            <code><![CDATA[
            var s = "ab cd--ef gh";
            if(s.RegexMatch(@"\b([a-z]+)-(\d+)?-([a-z]+)\b", out RXMatch m))
            	print.it(
            		m.GroupCountPlusOne, //4 (whole match and 3 groups)
            		m[2].Exists, //false
            		m[2].Start, //-1
            		m[2].Length, //0
            		m[2].Value //null
            		);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.RXMatch.GroupCountPlusOne">
            <summary>
            The number of groups in the regular expression, + 1 for the whole match.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Start">
            <summary>
            Start offset of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.End">
            <summary>
            <see cref="P:Au.Types.RXMatch.Start"/> + <see cref="P:Au.Types.RXMatch.Length"/>. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Length">
            <summary>
            Length of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Value">
            <summary>
            The match (substring) in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Subject">
            <summary>
            The subject string in which this match was found.
            </summary>
        </member>
        <member name="M:Au.Types.RXMatch.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXMatch.Value"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.StartNoK">
            <summary>
            Start offset of whole match regardless of \K.
            When the regular expression contains \K, this is less than <see cref="P:Au.Types.RXMatch.Start"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Mark">
            <summary>
            The name of a found mark, or null.
            Marks can be inserted in regular expression pattern like (*MARK:name) or (*:name).
            After a full successful match, it is the last mark encountered on the matching path through the pattern. After a "no match" or a partial match, it is the last encountered mark. For example, consider this pattern: "^(*MARK:A)((*MARK:B)a|b)c". When it matches "bc", the mark is A. The B mark is "seen" in the first branch of the group, but it is not on the matching path. On the other hand, when this pattern fails to match "bx", the mark is B.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Exists">
            <summary>
            Gets the return value of the <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> call.
            Can be false only when the function returned false but a mark is available (see <see cref="P:Au.Types.RXMatch.Mark"/>). Otherwise, when the function returns flase, it returns null instead of a RXMatch object.
            When false, all properties except Exists and Mark have undefined values or throw exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IsPartial">
            <summary>
            Returns true if this match is partial.
            Partial match is possible if used a PARTIAL_ flag.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.Int32)">
            <summary>
            Gets group info. Index 0 is whole match. Index 1 is the first group.
            </summary>
            <param name="group">1-based group index, or 0 for whole match.</param>
            <exception cref="T:System.IndexOutOfRangeException">The group index is &lt; 0 or &gt;= <see cref="P:Au.Types.RXMatch.GroupCountPlusOne"/>.</exception>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.String)">
            <summary>
            Gets group info of a named group.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentException">Unknown group name.</exception>
            <remarks>
            If multiple groups have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If multiple groups have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <param name="notUnique">Receives true if multiple groups have this name.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If multiple groups have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.ExpandReplacement(System.String)">
            <summary>
            Returns expanded version of the specified replacement pattern.
            </summary>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} and ${+func(n)} with the return value of a function registered with <see cref="M:Au.regexp.addReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.Int32,System.String,System.String})"/>.
            </param>
            <exception cref="T:System.ArgumentException">
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <remarks>
            Works like <see cref="M:System.Text.RegularExpressions.Match.Result(System.String)"/>.
            See also: <see cref="M:Au.regexp.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.RXGroup">
            <summary>
            Regular expression group match info.
            Used with <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.regexp"/> and some String extension methods.
            </summary>
            <remarks>
            Groups are regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). A RXGroup variable contains info about a group found in the subject string: index, length, substring.
            
            Some groups specified in regular expression may not exist in the subject string even if it matches the regular expression. For example, regular expression "A(\d+)?B" matches string "AB", but group (\d+) does not exist. Then <see cref="P:Au.Types.RXGroup.Exists"/> is false, <see cref="P:Au.Types.RXGroup.Start"/> -1, <see cref="P:Au.Types.RXGroup.Length"/> 0, <see cref="P:Au.Types.RXGroup.Value"/> null.
            
            When a group matches multiple times, the RXGroup variable contains only the last instance. For example, if subject is <c>"begin 12 345 67 end"</c> and regular expression is <c>(\d+ )+</c>, value of group 1 is <c>"67"</c>. If you need all instances (<c>"12"</c>, <c>"345"</c>, <c>"67"</c>), instead use .NET <see cref="T:System.Text.RegularExpressions.Regex"/> and <see cref="P:System.Text.RegularExpressions.Group.Captures"/>. Also you can get all instances with <see cref="P:Au.regexp.Callout"/>.
            
            Examples and more info: <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.regexp"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.RXGroup.Start">
            <summary>
            Start offset of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.End">
            <summary>
            <see cref="P:Au.Types.RXGroup.Start"/> + <see cref="P:Au.Types.RXGroup.Length"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Length">
            <summary>
            Length of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Value">
            <summary>
            String value of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Exists">
            <summary>
            Returns true if the group exists in the subject string, false if does not exist.
            More info in <see cref="T:Au.Types.RXGroup"/> topic. Example in <see cref="T:Au.Types.RXMatch"/> topic.
            </summary>
            <remarks>
            Other ways to detect it: if a group does not exist, its Index is -1 and Value is null.
            </remarks>
        </member>
        <member name="M:Au.Types.RXGroup.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXGroup.Value"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutData">
            <summary>
            Managed version of PCRE API struct pcre2_callout_block.
            When you set <see cref="P:Au.regexp.Callout"/>, your callout function's parameter is of this type.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Most properties are pcre2_callout_block fields as documented in PCRE help. Other properties and methods are easier/safer versions of unsafe fields like offset_vector.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.Result">
            <summary>
            Sets the return value of the callout function, as documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Default 0.
            If 1, matching fails at the current point, but the testing of other matching possibilities goes ahead, just as if a lookahead assertion had failed.
            If -1 (PCRE2_ERROR_NOMATCH), the match function returns false (no match). Values less tan -2 are PCRE error codes and cause exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_number">
            <summary>
            Callout number, eg 5 for "(?C5)".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_top">
            <summary>
            One more than the number of the highest numbered captured group so far.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_last">
            <summary>
            The number of the most recently captured group.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_flags">
            <summary>
            Flags.
            1 PCRE2_CALLOUT_STARTMATCH, 2 PCRE2_CALLOUT_BACKTRACK.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.start_match">
            <summary>
            The offset within the subject string at which the current match attempt started. But depends on \K etc.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.current_position">
            <summary>
            The current offset within the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.pattern_position">
            <summary>
            The offset in the regular expression to the next item to be matched.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.next_item_length">
            <summary>
            The length of the next item to be processed in the regular expression.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string_offset">
            <summary>
            The callout string offset in the regular expression. Used with callouts like "(?C'calloutString')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string">
            <summary>
            The callout string, eg "xyz" for "(?C'xyz')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.mark">
            <summary>
            The most recently passed (*MARK), (*PRUNE), or (*THEN) item in the match, or null if no such items have been passed.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="M:Au.Types.RXCalloutData.Group(System.Int32)">
            <summary>
            Gets the start index and length of the specified group in the subject string.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>group</i> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="M:Au.Types.RXCalloutData.GroupValue(System.Int32)">
            <summary>
            Gets the value (substring) of the specified group.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>group</i> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroup">
            <summary>
            Gets the start index and length of the most recently captured group in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroupValue">
            <summary>
            Gets the value (substring) of the most recently captured group.
            </summary>
        </member>
        <member name="T:Au.Types.RXFlags">
            <summary>
            Flags for <see cref="T:Au.regexp"/> constructor.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            Many options also can be specified in regular expression (RE):
            - These can be anywhere in RE: (?i) CASELESS, (?m) MULTILINE, (?s) DOTALL, (?n) NO_AUTO_CAPTURE, (?x) EXTENDED, (?xx) EXTENDED_MORE, (?J) DUPNAMES, (?U) UNGREEDY. Can be multiple, like (?ms). Can be unset, like (?-i). RE "\Qtext\E" is like RE "text" with flag LITERAL.
            - Instead of ANCHORED can be used \A or \G at the start of RE. Or ^, except in multiline mode.
            - Instead of ENDANCHORED can be used \z at the end of RE. Or $, except in multiline mode.
            - Flag UTF is implicitly added if RE contains non-ASCII characters and there is no flag NEVER_UTF.
            - These must be at the very start and are named like flags: (*UTF), (*UCP), (*NOTEMPTY), (*NOTEMPTY_ATSTART), (*NO_AUTO_POSSESS), (*NO_DOTSTAR_ANCHOR), (*NO_START_OPT).
            - More info in <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">PCRE syntax reference</see>.
            
            Some of <b>RXFlags</b> flags also exist in <see cref="T:Au.Types.RXMatchFlags"/>. You can set them either when calling <b>regexp</b> constructor or when calling <b>regexp</b> functions that have parameter <i>more</i>. You can use different flags for each function call with the same <b>regexp</b> variable.
            </remarks>
        </member>
        <member name="F:Au.Types.RXFlags.UTF">
            <summary>
            Fully support Unicode text (case-insensitivity etc). More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2unicode.html">pcre2unicode</see>.
            This flag is implicitly added if regular expression contains non-ASCII characters and there is no flag NEVER_UTF.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatchFlags">
            <summary>
            Flags for <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and other <see cref="T:Au.regexp"/> class functions.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            These flags also exist in <see cref="T:Au.Types.RXFlags"/> (<b>regexp</b> constructor flags). You can set them either when calling constructor or when calling other functions.
            </remarks>
        </member>
        <member name="T:Au.Types.SegSep">
            <summary>
            Contains several string constants that can be used with some 'split string' functions of this library to specify separators.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Whitespace">
            <summary>
            Specifies that separators are spaces, tabs, newlines and other characters for which <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> returns true.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Word">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Line">
            <summary>
            Specifies that separators are substrings "\r\n", as well as single characters '\r' and '\n'.
            </summary>
        </member>
        <member name="T:Au.Types.SegFlags">
            <summary>
            Flags for <see cref="M:Au.ExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.SegFlags.NoEmpty">
            <summary>
            Don't return empty substrings.
            For example, is string is "one  two " and separators is " ", return {"one", "two"} instead of {"one", "", "two", ""}.
            </summary>
        </member>
        <member name="T:Au.Types.StartEnd">
            <summary>
            struct with fields int start and int end.
            </summary>
        </member>
        <member name="F:Au.Types.StartEnd.start">
            
        </member>
        <member name="F:Au.Types.StartEnd.end">
            
        </member>
        <member name="M:Au.Types.StartEnd.#ctor(System.Int32,System.Int32)">
            
        </member>
        <member name="P:Au.Types.StartEnd.Length">
            <summary>
            Returns <c>end - start</c>.
            </summary>
        </member>
        <member name="P:Au.Types.StartEnd.Range">
            <summary>
            Converts this to <see cref="P:Au.Types.StartEnd.Range"/>.
            Can be used to get substring, like <c>s[x.Range]</c> instead of <c>s[x.start..x.end]</c>.
            </summary>
        </member>
        <member name="M:Au.Types.StartEnd.Span(System.String)">
            <summary>
            Gets string span.
            </summary>
        </member>
        <member name="M:Au.Types.StartEnd.ToString">
            
        </member>
        <member name="T:Au.Types.WXType">
            <summary>
            The type of text (wildcard expression) of an <see cref="T:Au.wildex"/> variable.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Text">
            <summary>
            Simple text (option t, or no *? characters and no t r R options).
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Wildcard">
            <summary>
            Wildcard (has *? characters and no t r R options).
            <b>Match</b> calls <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.RegexPcre">
            <summary>
            PCRE regular expression (option r).
            <b>Match</b> calls <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.RegexNet">
            <summary>
            .NET egular expression (option R).
            <b>Match</b> calls <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Multi">
            <summary>
            Multiple parts (option m).
            <b>Match</b> calls <b>Match</b> for each part (see <see cref="P:Au.wildex.MultiArray"/>) and returns true if all negative (option n) parts return true (or there are no such parts) and some positive (no option n) part returns true (or there are no such parts).
            If you want to implement a different logic, call <b>Match</b> for each <see cref="P:Au.wildex.MultiArray"/> element (instead of calling <b>Match</b> for this variable).
            </summary>
        </member>
        <member name="T:Au.Types.ProcessInfo">
            <summary>
            Contains process name (like "notepad.exe"), id, name and user session id.
            </summary>
        </member>
        <member name="M:Au.Types.ProcessInfo.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Contains process name (like "notepad.exe"), id, name and user session id.
            </summary>
        </member>
        <member name="T:Au.Types.RFlags">
            <summary>
            Flags for <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.ShowErrorUI">
            <summary>
            Show error message box if fails, for example if file not found.
            Note: this does not disable exceptions. To avoid exceptions use try/catch or <see cref="M:Au.run.itSafe(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.WaitForExit">
            <summary>
            If started new process, wait until it exits.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.NeedProcessHandle">
            <summary>
            If started new process, get process handle (<see cref="P:Au.Types.RResult.ProcessHandle"/>).
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.Admin">
            <summary>
            Run new process as administrator.
            If this process isn't admin:
            - Shows UAC consent dialog.
            - Uses verb "runas", therefore other verb cannot be specified.
            - Cannot set current directory for the new process.
            - The new process does not inherit environment variables of this process.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.InheritAdmin">
            <summary>
            If this process runs as administrator, run new process as administrator too.
            Without this flag, if this process runs as administrator:
            - Starts new process as non-administrator from the shell process (explorer.exe).
            - If it fails (for example if shell process isn't running), calls <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/> and starts new process as administrator.
            - The new process does not inherit environment variables of this process.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.MostUsed">
            <summary>
            Add the app to the "Most used" list in the Start menu if launched often.
            </summary>
        </member>
        <member name="T:Au.Types.ROptions">
            <summary>
            More parameters for <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            </summary>
            <remarks>
            Implicit conversion from <b>string</b> sets <see cref="F:Au.Types.ROptions.CurrentDirectory"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.ROptions.op_Implicit(System.String)~Au.Types.ROptions">
            <summary>
            Sets <see cref="F:Au.Types.ROptions.CurrentDirectory"/>.
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.CurrentDirectory">
            <summary>
            Initial current directory for the new process.
            If null (default), the new process will inherit the curent directory of this process.
            If "", the function gets parent directory path from the <i>file</i> parameter, if possible (if full path is specified or found). If not possible, same as null.
            <note>Some programs look for their files in current directory and fail to start if it is not the program's directory.</note>
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.Verb">
            <summary>
            File's right-click menu command, also known as verb. For example "edit", "print", "properties". The default verb is bold in the menu.
            Not all menu items will work. Some may have different name than in the menu.
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.OwnerWindow">
            <summary>
            Owner window for error message boxes.
            Also, new window should be opened on the same screen. However many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.WindowState">
            <summary>
            Preferred window state.
            Many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.FlagsAdd">
            <summary>
            Flags to add to <msdn>SHELLEXECUTEINFO</msdn> field <b>fMask</b>.
            Default flags: SEE_MASK_NOZONECHECKS, SEE_MASK_NOASYNC, SEE_MASK_NOCLOSEPROCESS, SEE_MASK_CONNECTNETDRV, SEE_MASK_UNICODE, SEE_MASK_FLAG_NO_UI (if no flag <b>ShowErrorUI</b>), SEE_MASK_NO_CONSOLE (if no flag <b>WaitForExit</b>), SEE_MASK_FLAG_LOG_USAGE (if flag <b>MostUsed</b>); also SEE_MASK_INVOKEIDLIST if need.
            </summary>
        </member>
        <member name="F:Au.Types.ROptions.FlagsRemove">
            <summary>
            Flags to remove from <msdn>SHELLEXECUTEINFO</msdn> field <b>fMask</b>.
            Default flags: see <see cref="F:Au.Types.ROptions.FlagsAdd"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RResult">
            <summary>
            Results of <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RResult.ProcessExitCode">
            <summary>
            The exit code of the process.
            0 if no flag <b>WaitForExit</b> or if cannot wait.
            </summary>
            <remarks>
            Usually the exit code is 0 or a process-defined error code.
            </remarks>
        </member>
        <member name="P:Au.Types.RResult.ProcessId">
            <summary>
            The process id.
            0 if used flag <b>WaitForExit</b> or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
        </member>
        <member name="P:Au.Types.RResult.ProcessHandle">
            <summary>
            If used flag <b>NeedProcessHandle</b>, contains process handle. Later the <see cref="T:System.Threading.WaitHandle"/> variable must be disposed.
            null if no flag or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
            <example>
            This code does the same as <c>run.it(@"notepad.exe", flags: SRFlags.WaitForExit);</c>
            <code><![CDATA[
            var r = run.it(@"notepad.exe", flags: SRFlags.NeedProcessHandle);
            using(var h = r.ProcessHandle) h?.WaitOne();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.RResult.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RResult.ProcessId"/> as string.
            </summary>
        </member>
        <member name="T:Au.Types.UacIL">
            <summary>
            UAC integrity level.
            See <see cref="P:Au.uacInfo.IntegrityLevel"/>.
            </summary>
        </member>
        <member name="F:Au.Types.UacIL.Untrusted">
            <summary>The most limited rights. Rare.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Low">
            <summary>Very limited rights. Used by web browser tab processes, Windows Store apps.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Medium">
            <summary>Limited rights. Most processes (unless UAC turned off).</summary>
        </member>
        <member name="F:Au.Types.UacIL.UIAccess">
            <summary>Medium IL + can access/automate High IL windows (user interface).</summary>
        </member>
        <member name="F:Au.Types.UacIL.High">
            <summary>Most rights. Processes that run as administrator.</summary>
        </member>
        <member name="F:Au.Types.UacIL.System">
            <summary>Almost all rights. Services, some system processes.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Protected">
            <summary>Undocumented. Rare.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Unknown">
            <summary>Failed to get IL. Unlikely.</summary>
        </member>
        <member name="T:Au.Types.UacElevation">
            <summary>
            <see cref="P:Au.uacInfo.Elevation"/>.
            </summary>
        </member>
        <member name="F:Au.Types.UacElevation.Unknown">
            <summary>Failed to get. Normally it never happens.</summary>
        </member>
        <member name="F:Au.Types.UacElevation.Default">
            <summary>
            Processes in this user session cannot be elevated.
            Can be: non-administrator user session (processes have limited rights); service session (processes have all rights); UAC is turned off (most processes have administrator rights).
            </summary>
        </member>
        <member name="F:Au.Types.UacElevation.Full">
            <summary>Runs as administrator (High or System integrity level), and UAC is not turned off. Also known as "elevated".</summary>
        </member>
        <member name="F:Au.Types.UacElevation.Limited">
            <summary>Runs as standard user (Medium, UIAccess or Low integrity level) in administrator user session (because of UAC).</summary>
        </member>
        <member name="T:Au.Types.SRole">
            <summary>
            <see cref="P:Au.script.role"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRole.ExeProgram">
            <summary>
            The task runs as normal .exe program.
            It can be started from editor or not. It can run on computers where editor not installed.
            </summary>
        </member>
        <member name="F:Au.Types.SRole.MiniProgram">
            <summary>
            The task runs in Au.Task.exe process, started from editor.
            </summary>
        </member>
        <member name="F:Au.Types.SRole.EditorExtension">
            <summary>
            The task runs in editor process.
            </summary>
        </member>
        <member name="T:Au.Types.UExcept">
            <summary>
            Flags for <see cref="M:Au.script.setup(System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Boolean,Au.Types.UExcept,System.String)"/> parameter <i>exception</i>. Defines what to do on unhandled exception.
            Default flags is <b>Print</b> and <b>Exit</b>, even if <b>Setup</b> not called (with default compiler only).
            </summary>
        </member>
        <member name="F:Au.Types.UExcept.Print">
            <summary>
            Display exception info in output.
            </summary>
        </member>
        <member name="F:Au.Types.UExcept.Dialog">
            <summary>
            Show dialog with exception info.
            </summary>
        </member>
        <member name="F:Au.Types.UExcept.Exit">
            <summary>
            Call <see cref="M:System.Environment.Exit(System.Int32)"/>. It prevents slow exit (Windows error reporting, writing events to the Windows event log, etc).
            Note: then instead of <see cref="E:System.AppDomain.UnhandledException"/> event is <see cref="E:System.AppDomain.ProcessExit"/> event. But <see cref="E:Au.process.thisProcessExit"/> indicates exception as usually.
            Info: the editor setup program disables Windows error reporting for tasks with role miniProgram (default). See <msdn>WerAddExcludedApplication</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.UExcept.PrintDialogExit">
            <summary>
            Display exception info in output, show dialog with exception info, and call <see cref="M:System.Environment.Exit(System.Int32)"/>.
            Same as <c>UExcept.Print | UExcept.Dialog | UExcept.Exit</c>.
            </summary>
        </member>
        <member name="T:Au.Types.EGetIcon">
            <summary>
            For <see cref="M:Au.script.editor.GetCustomIcon(System.String,Au.Types.EGetIcon)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EGetIcon.PathToIconName">
            <summary>
            Input is a file or folder in current workspace. Can be relative path in workspace (like @"\Folder\File.cs") or full path or filename.
            Output must be icon name, like "*Pack.Icon color", where color is like #RRGGBB or color name. See menu -> Tools -> Icons.
            </summary>
        </member>
        <member name="F:Au.Types.EGetIcon.PathToIconXaml">
            <summary>
            Input is a file or folder in current workspace (see <b>PathToIconName</b>).
            Output must be icon XAML.
            </summary>
        </member>
        <member name="F:Au.Types.EGetIcon.IconNameToXaml">
            <summary>
            Input is icon name (see <b>PathToIconName</b>).
            Output must be icon XAML.
            </summary>
        </member>
        <member name="T:Au.Types.RunSingleAttribute">
            <summary>
            The default compiler adds this attribute to the main assembly if runSingle true.
            </summary>
        </member>
        <member name="T:Au.Types.RefPathsAttribute">
            <summary>
            The default compiler adds this attribute to the main assembly if using non-default references (meta r) that aren't in editor's folder or its subfolder "Libraries". Allows to find them at run time. Only if role miniProgram (default).
            </summary>
        </member>
        <member name="F:Au.Types.RefPathsAttribute.Paths">
            <summary>Dll paths separated with |.</summary>
        </member>
        <member name="M:Au.Types.RefPathsAttribute.#ctor(System.String)">
            <param name="paths">Dll paths separated with |.</param>
        </member>
        <member name="T:Au.Types.WHFlags">
            <summary>
            Flags for <see cref="M:Au.wait.forHandle(System.Double,Au.Types.WHFlags,System.IntPtr[])"/>
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.All">
            <summary>
            Wait until all handles are signaled.
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.DoEvents">
            <summary>
            While waiting, dispatch Windows messages, events, hooks etc. Like <see cref="M:Au.wait.doEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WPMCallback">
            <summary>
            Delegate type for <see cref="M:Au.wait.forPostedMessage(System.Double,Au.Types.WPMCallback)"/>.
            </summary>
            <param name="m">API <msdn>MSG</msdn>.</param>
        </member>
        <member name="T:Au.Types.WaitVariable_">
            <summary>
            Used with Wait_ etc instead of ref bool.
            </summary>
        </member>
        <member name="T:Au.Types.EFFlags">
            <summary>
            Flags for <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.Reverse">
            <summary>
            Search in reverse order. It can make faster.
            When control class or id is specified in the <i>prop</i> argument, controls are searched not in reverse order. Only UI elements in them are searched in reverse order.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.HiddenToo">
            <summary>
            The UI element can be invisible.
            Without this flag skips objects that are invisible (have state INVISIBLE) or are descendants of invisible WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Regardless of this flag, always skips invisible standard objects of nonclient area: TITLEBAR, MENUBAR, SCROLLBAR, GRIP.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.MenuToo">
            <summary>
            Always search in MENUITEM.
            Without this flag skips MENUITEM descendant objects (for speed), unless role is MENUITEM or MENUPOPUP or searching in web page.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.ClientArea">
            <summary>
            Search only in the client area of the window or control.
            Skips the title bar, standard menubars and scrollbars. Searches only in the client area root object (but will not find the object itself).
            When control class or id is specified in the <i>prop</i> argument, this flag is applied to these controls. Not applied to other controls.
            Don't use this flag when searching in elm or web page (role prefix "web:" etc) or with flag UIA.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.NotInProc">
            <summary>
            Search without loading dll into the target process.
            Disadvantages: 1. Much slower. 2. Some properties are not supported, for example HTML attributes (while searching and later). 3. And more.
            Even without this flag, the default search method is not used with Windows Store app windows, console windows, most Java windows, windows of protected processes and processes of higher [](xref:uac) integrity level, Firefox web page if its multiprocess feature is not disabled.
            Some windows have child controls that belong to a different process or thread than the window. Example - Internet Explorer. When searching in such windows, the default search method is not used when searching in these controls. Workaround - find the control(s) and search in it/them. For it can be used one of: 1. With Internet Explorer use role prefix "web:". 2. Find the control with <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/> and search in it. 3. Use <see cref="M:Au.elmFinder.Find(Au.wnd,Au.wndChildFinder)"/>.
            Don't need this flag when searching in elm (then it is inherited from the elm variable).
            See also: <see cref="P:Au.elm.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EFFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag to find objects in windows that don't support accessible objects but support UI Automation elements. For example JavaFX applications.
            Objects found with this flag never have HtmlX properties, but can have <see cref="P:Au.elm.UiaId"/>.
            This flag can be used with most other windows too.
            Don't use this flag when searching in elm (then it is inherited from the elm variable) or web page (role prefix "web:" etc).
            See also: <see cref="P:Au.elm.MiscFlags"/>.
            </summary>
        </member>
        <member name="T:Au.Types.Enum_">
            <summary>
            A workaround to add internal members to public enums.
            </summary>
        </member>
        <member name="F:Au.Types.Enum_.EFFlags_Mark">
            <summary>
            Used by tools like "Find UI element", together with ElmMiscFlags_Marked.
            </summary>
        </member>
        <member name="F:Au.Types.Enum_.EMiscFlags_Marked">
            <summary>
            Used by tools like "Find UI element", together with AFFlags_Mark.
            </summary>
        </member>
        <member name="T:Au.Types.EWFlags">
            <summary>
            Flags for <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EWFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="F:Au.Types.EWFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.EFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.EXYFlags">
            <summary>
            Flags for <see cref="M:Au.elm.fromXY(Au.Types.POINT,Au.Types.EXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EXYFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag with some windows that don't support accessible objects but support UI Automation elements.
            When this flag is not specified, the function detects most such windows and uses UI Automation API, but the detection is not perfect.
            More info: <see cref="F:Au.Types.EFFlags.UIA"/>.
            This flag can be used with most other windows too.
            </summary>
        </member>
        <member name="F:Au.Types.EXYFlags.PreferLink">
            <summary>
            Get the direct parent object if it's LINK or BUTTON.
            Usually links have one or more children of type TEXT, STATICTEXT, IMAGE or other.
            </summary>
        </member>
        <member name="F:Au.Types.EXYFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.EFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EXYFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="T:Au.Types.EMiscFlags">
            <summary>
            Flags returned by <see cref="P:Au.elm.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EMiscFlags.InProc">
            <summary>
            This UI element was retrieved by the dll loaded into its process.
            More info: <see cref="F:Au.Types.EFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EMiscFlags.UIA">
            <summary>
            This UI element was retrieved using UI Automation API.
            More info: <see cref="F:Au.Types.EFFlags.UIA"/>.
            </summary>
        </member>
        <member name="F:Au.Types.EMiscFlags.Java">
            <summary>
            This UI element was retrieved using Java Access Bridge API.
            More info: <see cref="T:Au.elm"/>.
            </summary>
        </member>
        <member name="T:Au.Types.EObjid">
            <summary>
            Object ids of window parts and some special objects.
            Used with <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>
            </summary>
            <remarks>
            Most names are as in API <msdn>AccessibleObjectFromWindow</msdn> documentation but without prefix "OBJID_".
            </remarks>
        </member>
        <member name="F:Au.Types.EObjid.QUERYCLASSNAMEIDX">
            <summary>Not uses with <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>.</summary>
        </member>
        <member name="F:Au.Types.EObjid.NATIVEOM">
            <summary>Not uses with <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>.</summary>
        </member>
        <member name="F:Au.Types.EObjid.UiaRootObjectId">
            <summary>Not uses with <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>.</summary>
        </member>
        <member name="F:Au.Types.EObjid.Java">
            <summary>
            The root Java object. Can be used when the window's class name starts with "SunAwt".
            </summary>
        </member>
        <member name="F:Au.Types.EObjid.UIA">
            <summary>
            Use UI Automation API.
            More info: <see cref="F:Au.Types.EFFlags.UIA"/>.
            </summary>
        </member>
        <member name="T:Au.Types.ERole">
            <summary>
            Standard roles of UI elements.
            Used with <see cref="P:Au.elm.RoleInt"/>
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accRole Object Roles</msdn> documentation but without prefix "ROLE_SYSTEM_". These are renamed: PUSHBUTTON to BUTTON, CHECKBUTTON to CHECKBOX, GRAPHIC to IMAGE, OUTLINE to TREE, OUTLINEITEM to TREEITEM, OUTLINEBUTTON to TREEBUTTON,
            </remarks>
        </member>
        <member name="T:Au.Types.EState">
            <summary>
            UI element state flags.
            Used by <see cref="P:Au.elm.State"/>.
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accState Object State Constants</msdn> documentation but without prefix "STATE_SYSTEM_".
            </remarks>
        </member>
        <member name="T:Au.Types.ESelect">
            <summary>
            UI element selection flags.
            Used by <see cref="M:Au.elm.Select(Au.Types.ESelect)"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>IAccessible.accSelect</msdn> documentation but without prefix "SELFLAG_".
            </remarks>
        </member>
        <member name="T:Au.Types.EEvent">
            <summary>
            Event constants for <see cref="T:Au.More.WinEventHook"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>SetWinEventHook Event Constants</msdn> documentation but without prefix "EVENT_".
            </remarks>
        </member>
        <member name="T:Au.Types.EHookFlags">
            <summary>
            Flags for <see cref="T:Au.More.WinEventHook"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>SetWinEventHook</msdn> documentation but without prefix "WINEVENT_".
            There are no flags for OUTOFCONTEXT and INCONTEXT. OUTOFCONTEXT is default (0). INCONTEXT cannot be used in managed code.
            </remarks>
        </member>
        <member name="F:Au.Types.EHookFlags.SKIPOWNTHREAD">
            <summary>Don't receive events generated by this thread.</summary>
        </member>
        <member name="F:Au.Types.EHookFlags.SKIPOWNPROCESS">
            <summary>Don't receive events generated by threads of this process.</summary>
        </member>
        <member name="T:Au.Types.EProperties">
            <summary>
            Used with <see cref="M:Au.elm.GetProperties(System.String,Au.Types.EProperties@)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.IFArea">
            <summary>
            Defines the search area for <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/> and similar functions.
            </summary>
            <remarks>
            It can be a window/control, UI element, another image or a rectangle in screen.
            Also allows to specify a rectangle in it, which makes the search area smaller and the function faster.
            Has implicit conversions from wnd, elm, Bitmap, RECT (rectangle in screen), tuple (wnd, RECT), tuple (Acc, RECT).
            Example: <c>uiimage.find((w, (left, top, width, height)), image);</c>.
            </remarks>
        </member>
        <member name="T:Au.Types.IFImage">
            <summary>
            Image(s) or color(s) for <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/> and similar functions.
            </summary>
            <remarks>
            Has implicit conversions from:
            - string - path of .png or .bmp file. If not full path, uses <see cref="P:Au.folders.ThisAppImages"/>.
            - string that starts with "resources/" or has prefix <c>"resource:"</c> - resource name; see <see cref="M:Au.More.ResourceUtil.GetGdipBitmap(System.String)"/>.
            - string with prefix <c>"image:"</c> - Base64-encoded .png image embedded in script text.
            <br/>Can be created with dialog "Find image or color in window" or with function <b>Au.Controls.KImageUtil.ImageToString</b> (in Au.Controls.dll).
            - <see cref="T:Au.Types.ColorInt"/>, <b>int</b> in 0xRRGGBB color format, <b>Color</b> - color. Alpha isn't used.
            - <see cref="T:System.Drawing.Bitmap"/> - image object.
            - <b>IFImage[]</b> - multiple images or/and colors. Action - find any. To create a different action can be used callback function (parameter <i>also</i>).
            
            Icons are not supported directly; you can use <see cref="T:Au.icon"/> to get icon and convert to bitmap.
            </remarks>
        </member>
        <member name="P:Au.Types.IFImage.Value">
            <summary>
            Gets the raw value stored in this variable. Can be string, Bitmap, ColorInt, IFImage[], null.
            </summary>
        </member>
        <member name="T:Au.Types.IFFlags">
            <summary>
            Flags for <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.IFFlags.WindowDC">
            <summary>
            Get pixels from the device context (DC) of the window client area, not from screen DC. Usually much faster.
            Can get pixels from window parts that are covered by other windows or offscreen. But not from hidden and minimized windows.
            Does not work on Windows 7 if Aero theme is turned off. Then this flag is ignored.
            Cannot find images in some windows (including Windows Store apps), and in some window parts (glass). All pixels captured from these windows/parts are black.
            If the window is DPI-scaled, the image must be captured from its non-scaled version.
            </summary>
        </member>
        <member name="F:Au.Types.IFFlags.PrintWindow">
            <summary>
            Use API <msdn>PrintWindow</msdn> to get window pixels.
            Like <b>WindowDC</b>, works with background windows, etc. Differences:
            - On Windows 8.1 and later works with all windows and all window parts.
            - Works without Aero theme too.
            - Slower than with WindowDC, although usually faster than without these flags.
            - Some windows may flicker.
            - Does not work with windows of higher UAC integrity level. Then this flag is ignored.
            </summary>
        </member>
        <member name="T:Au.Types.IFAlso">
            <summary>
            Used with <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/> and <see cref="M:Au.uiimage.wait(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>. Its callback function (parameter <i>also</i>) can return one of these values.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.OkReturn">
            <summary>
            Stop searching.
            Let the main function (<b>Find</b> or <b>Wait</b>) return current result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.OkFindMore">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.OkFindMoreOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.OkFindMoreOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.NotFound">
            <summary>
            Stop searching.
            Let <b>Find</b> return null. Let <b>Wait</b> continue waiting. But if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.FindOther">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.FindOtherOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.IFAlso.FindOtherOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="T:Au.Types.ICFlags">
            <summary>
            Flags for <see cref="M:Au.uiimage.captureUI(Au.Types.ICResult@,Au.Types.ICFlags,Au.Types.AnyWnd)"/>.
            </summary>
            <remarks>
            Only one of flags <b>Image</b>, <b>Color</b> and <b>Rectangle</b> can be used. If none, can capture image or color.
            </remarks>
        </member>
        <member name="F:Au.Types.ICFlags.Image">
            <summary>Can capture only image, not color.</summary>
        </member>
        <member name="F:Au.Types.ICFlags.Color">
            <summary>Can capture only color, not image.</summary>
        </member>
        <member name="F:Au.Types.ICFlags.Rectangle">
            <summary>Capture only rectangle, not image/color.</summary>
        </member>
        <member name="F:Au.Types.ICFlags.WindowDC">
            <summary>
            Get pixels from the client area device context (DC) of a user-selected window, not from screen DC.
            More info: <see cref="F:Au.Types.IFFlags.WindowDC"/>.
            </summary>
        </member>
        <member name="F:Au.Types.ICFlags.PrintWindow">
            <summary>
            Get pixels from the client area of a user-selected window using API <msdn>PrintWindow</msdn>.
            More info: <see cref="F:Au.Types.IFFlags.PrintWindow"/>.
            </summary>
        </member>
        <member name="T:Au.Types.ICResult">
            <summary>
            Results of <see cref="M:Au.uiimage.captureUI(Au.Types.ICResult@,Au.Types.ICFlags,Au.Types.AnyWnd)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.ICResult.image">
            <summary>
            Captured image.
            null if captured single pixel color or used flag <see cref="F:Au.Types.ICFlags.Rectangle"/>.
            </summary>
        </member>
        <member name="F:Au.Types.ICResult.color">
            <summary>
            Captured color.
            </summary>
        </member>
        <member name="F:Au.Types.ICResult.rect">
            <summary>
            Location of the captured image or rectangle, in screen coordinates.
            </summary>
        </member>
        <member name="F:Au.Types.ICResult.w">
            <summary>
            Window or control containing the captured image or rectangle, if whole image is in its client area.
            In some cases may be incorrect, for example if windows moved/opened/closed/etc while capturing.
            </summary>
        </member>
        <member name="T:Au.Types.WProp">
            <summary>
            Sets, gets, removes and lists window properties using API <msdn>SetProp</msdn> and co.
            </summary>
        </member>
        <member name="P:Au.Types.WProp.Item(System.String)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.Types.WProp.Item(System.UInt16)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.String,System.IntPtr)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            
            Later call <see cref="M:Au.Types.WProp.Remove(System.String)"/> to remove the property. If you use many unique property names and don't remove the properties, the property name strings can fill the global atom table which is of a fixed size (about 48000) and which is used by all processes for various purposes.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.UInt16,System.IntPtr)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <param name="value">Property value.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.String)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name. Other overload allows to use global atom instead, which is faster.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.UInt16)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
        </member>
        <member name="M:Au.Types.WProp.GetList">
            <summary>
            Gets list of window properties.
            Uses API <msdn>EnumPropsEx</msdn>.
            </summary>
            <remarks>
            Returns 0-length list if fails. Fails if invalid window or access denied ([](xref:uac)). Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.ToString">
            <summary>
            Calls <see cref="M:Au.Types.WProp.GetList"/> and converts to string.
            </summary>
        </member>
        <member name="T:Au.Types.WSFlags">
            <summary>
            Flags for <see cref="M:Au.wnd.SetStyle(Au.Types.WS,Au.Types.WSFlags)"/> and <see cref="M:Au.wnd.SetExStyle(Au.Types.WSE,Au.Types.WSFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WSFlags.Add">
            <summary>Add the specified styles and don't change others.</summary>
        </member>
        <member name="F:Au.Types.WSFlags.Remove">
            <summary>Remove the specified styles and don't change others.</summary>
        </member>
        <member name="F:Au.Types.WSFlags.UpdateNonclient">
            <summary>Update non-client area (frame, title bar).</summary>
        </member>
        <member name="F:Au.Types.WSFlags.UpdateClient">
            <summary>Update client area.</summary>
        </member>
        <member name="T:Au.Types.WCFlags">
            <summary>
            Flags for <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WCFlags.HiddenToo">
            <summary>Can find hidden controls.</summary>
        </member>
        <member name="F:Au.Types.WCFlags.DirectChild">
            <summary>Skip indirect descendant controls (children of children and so on).</summary>
        </member>
        <member name="T:Au.Types.WndButton">
            <summary>
            Like <see cref="T:Au.wnd"/>, but has only button, check box and radio button functions - <b>Click</b>, <b>Check</b> etc.
            See also <see cref="P:Au.wnd.AsButton"/>.
            </summary>
            <example>
            <code><![CDATA[
            wnd.find("Options").Child("Cancel").AsButton.Click();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.WndButton.W">
            <summary>
            Button handle as wnd.
            </summary>
        </member>
        <member name="M:Au.Types.WndButton.op_Implicit(Au.Types.WndButton)~Au.wnd">
            
        </member>
        <member name="M:Au.Types.WndButton.op_Explicit(Au.wnd)~Au.Types.WndButton">
            
        </member>
        <member name="M:Au.Types.WndButton.ToString">
            
        </member>
        <member name="M:Au.Types.WndButton.Click(System.Boolean)">
            <summary>
            Sends a "click" message to this button control. Does not use the mouse.
            </summary>
            <param name="useElm">Use <see cref="M:Au.elm.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            Check boxes and radio buttons also are buttons. This function can click them.
            </remarks>
            <example>
            <code><![CDATA[
            wnd.find("Options").Child("Cancel").AsButton.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.WndButton.Check(System.Boolean,System.Boolean)">
            <summary>
            Checks or unchecks this check box. Does not use the mouse.
            Calls <see cref="M:Au.Types.WndButton.SetCheckState(System.Int32,System.Boolean)"/> with state 0 or 1.
            </summary>
            <param name="on">Checks if true, unchecks if false.</param>
            <param name="useElm"></param>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Types.WndButton.SetCheckState(System.Int32,System.Boolean)">
            <summary>
            Sets checkbox state. Does not use the mouse.
            </summary>
            <param name="state">0 unchecked, 1 checked, 2 indeterminate.</param>
            <param name="useElm">Use <see cref="M:Au.elm.DoAction"/>. If false (default), posts <msdn>BM_SETCHECK</msdn> message and also BN_CLICKED notification to the parent window; if that is not possible, instead uses <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid state.</exception>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Does nothing if the check box already has the specified check state (if can get it).
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Types.WndButton.IsChecked(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Calls <see cref="M:Au.Types.WndButton.GetCheckState(System.Boolean)"/> and returns true if it returns 1.
            </summary>
        </member>
        <member name="M:Au.Types.WndButton.GetCheckState(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Returns 0 if unchecked, 1 if checked, 2 if indeterminate. Also returns 0 if this is not a button or if failed to get state.
            </summary>
            <param name="useElm">Use <see cref="P:Au.elm.State"/>. If false (default) and this button has a standard checkbox style, uses API <msdn>BM_GETCHECK</msdn>.</param>
        </member>
        <member name="T:Au.Types.WFlags">
            <summary>
            Flags of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.WFlags.HiddenToo">
            <summary>
            Can find invisible windows. See <see cref="P:Au.wnd.IsVisible"/>.
            Use this carefully. Always use <i>cn</i> (class name), not just <i>name</i>, to avoid finding a wrong window with the same name.
            </summary>
        </member>
        <member name="F:Au.Types.WFlags.CloakedToo">
            <summary>
            Can find cloaked windows. See <see cref="P:Au.wnd.IsCloaked"/>.
            Cloaked are windows hidden not in the classic way, therefore <see cref="P:Au.wnd.IsVisible"/> does not detect it, but <see cref="P:Au.wnd.IsCloaked"/> detects. For example, windows on inactive Windows 10 virtual desktops, ghost windows of inactive Windows Store apps, various hidden system windows.
            Use this carefully. Always use <i>cn</i> (class name), not just <i>name</i>, to avoid finding a wrong window with the same name.
            </summary>
        </member>
        <member name="T:Au.Types.WOwner">
            <summary>
            Used with <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> and similar functions to specify an owner object of the window.
            Can be program name (like <c>"notepad.exe"</c>), process id (<see cref="M:Au.Types.WOwner.Process(System.Int32)"/>), thread id (<see cref="M:Au.Types.WOwner.Thread(System.Int32)"/> or <see cref="P:Au.Types.WOwner.ThisThread"/>) or owner window (<see cref="M:Au.Types.WOwner.Window(Au.Types.AnyWnd)"/>).
            </summary>
        </member>
        <member name="M:Au.Types.WOwner.op_Implicit(System.String)~Au.Types.WOwner">
            <summary>Program name like "notepad.exe", or null. See <see cref="P:Au.wnd.ProgramName"/>.</summary>
        </member>
        <member name="M:Au.Types.WOwner.Process(System.Int32)">
            <summary>Process id. See <see cref="P:Au.wnd.ProcessId"/>.</summary>
        </member>
        <member name="M:Au.Types.WOwner.Thread(System.Int32)">
            <summary>Thread id. See <see cref="P:Au.wnd.ThreadId"/>.</summary>
        </member>
        <member name="P:Au.Types.WOwner.ThisThread">
            <summary>Thread id of this thread.</summary>
        </member>
        <member name="M:Au.Types.WOwner.Window(Au.Types.AnyWnd)">
            <summary>Owner window. See <see cref="P:Au.wnd.OwnerWindow"/>.</summary>
        </member>
        <member name="M:Au.Types.WOwner.GetValue(Au.wildex@,System.Int32@,System.Int32@,Au.wnd@)">
            <summary>
            Gets program name or process id or thread id or owner window.
            Other variables will be null/0.
            </summary>
            <exception cref="T:System.ArgumentException">The value is "" or 0 or contains characters \ or /.</exception>
        </member>
        <member name="P:Au.Types.WOwner.IsEmpty">
            <summary>
            Returns true if nothing was assigned to this variable.
            </summary>
        </member>
        <member name="T:Au.Types.WContains">
            <summary>
            The <i>contains</i> parameter of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> and similar functions.
            Specifies text, image or other object that must be in the window.
            </summary>
        </member>
        <member name="M:Au.Types.WContains.op_Implicit(Au.wndChildFinder)~Au.Types.WContains">
            
        </member>
        <member name="M:Au.Types.WContains.op_Implicit(Au.elmFinder)~Au.Types.WContains">
            
        </member>
        <member name="M:Au.Types.WContains.op_Implicit(Au.uiimageFinder)~Au.Types.WContains">
            
        </member>
        <member name="M:Au.Types.WContains.op_Implicit(System.String)~Au.Types.WContains">
            <summary>
            Converts from string to <see cref="T:Au.wndChildFinder"/>, <see cref="T:Au.elmFinder"/> or <see cref="T:Au.uiimageFinder"/>.
            See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of constructor of <see cref="T:Au.wndChildFinder"/>, <see cref="T:Au.elmFinder"/> or <see cref="T:Au.uiimageFinder"/>.</exception>
        </member>
        <member name="P:Au.Types.WContains.Value">
            <summary>
            Gets object stored in this variable. Can be null, <see cref="T:Au.wndChildFinder"/>, <see cref="T:Au.elmFinder"/> or <see cref="T:Au.uiimageFinder"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WFCache">
            <summary>
            Can be used with <see cref="M:Au.wndFinder.IsMatch(Au.wnd,Au.Types.WFCache)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.WFCache.CacheName">
            <summary>
            Cache window name.
            Default: false.
            </summary>
            <remarks>
            Window name is not cached by default because can be changed. Window class name and program name are always cached because cannot be changed.
            </remarks>
        </member>
        <member name="P:Au.Types.WFCache.NoTimeout">
            <summary>
            Don't auto-clear cached properties on timeout.
            </summary>
        </member>
        <member name="M:Au.Types.WFCache.Clear(System.Boolean)">
            <summary>
            Clears all cached properties, or only name.
            </summary>
            <remarks>
            Usually don't need to call this function. It is implicitly called when the variable is used with a new window.
            </remarks>
            <param name="onlyName">Clear only name (because it may change, unlike other cached properties).</param>
        </member>
        <member name="P:Au.Types.WFCache.IgnoreVisibility">
            <summary>
            Match invisible and cloaked windows too, even if the flags are not set (see <see cref="T:Au.Types.WFlags"/>).
            </summary>
        </member>
        <member name="T:Au.Types.WXYFlags">
            <summary>
            Flags for <see cref="M:Au.wnd.fromXY(Au.Types.POINT,Au.Types.WXYFlags)"/> and <see cref="M:Au.wnd.fromMouse(Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedWindow">
            <summary>
            Need top-level window. If at that point is a control, gets its top-level parent.
            Don't use together with NeedControl.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedControl">
            <summary>
            Need a control (child window). Returns default(wnd) if there is no control at that point.
            Don't use together with NeedWindow.
            Without flags NeedWindow and NeedControl the function gets control or top-level window.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.Raw">
            <summary>
            Just call API <msdn>WindowFromPhysicalPoint</msdn>.
            Faster, but skips disabled controls and in some cases gets transparent control like group box although a smaller visible sibling is there.
            Not used with flag NeedWindow.
            </summary>
        </member>
        <member name="T:Au.Types.WXYCFlags">
            <summary>
            Flags for <see cref="M:Au.wnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYCFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXYCFlags.OrThis">
            <summary>
            If the point is in this window but not in a descendant control, return this. Default - return default(wnd).
            </summary>
        </member>
        <member name="F:Au.Types.WXYCFlags.ScreenXY">
            <summary>
            The point is in screen coordinates. Default - client area.
            </summary>
        </member>
        <member name="F:Au.Types.WXYCFlags.DirectChild">
            <summary>
            Must be direct child of this. Default - any descendant.
            </summary>
        </member>
        <member name="F:Au.Types.WXYCFlags.Inside">
            <summary>
            If the point is not in client area, don't look for descendants; if with flag <b>OrThis</b> and the point is in this (non-client area), return this, else return default(wnd).
            </summary>
        </member>
        <member name="T:Au.Types.PrintMsgOptions">
            <summary>
            Options for <see cref="M:Au.wnd.more.printMsg(System.String@,Au.wnd,System.Int32,System.IntPtr,System.IntPtr,Au.Types.PrintMsgOptions,System.String)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.PrintMsgOptions.#ctor">
            
        </member>
        <member name="M:Au.Types.PrintMsgOptions.#ctor(System.Int32[])">
            <summary>
            Sets <see cref="P:Au.Types.PrintMsgOptions.Skip"/>.
            </summary>
        </member>
        <member name="P:Au.Types.PrintMsgOptions.Number">
            <summary>
            Prepend counter 1, 2, 3...
            Default true.
            </summary>
        </member>
        <member name="P:Au.Types.PrintMsgOptions.Indent">
            <summary>
            Prepend one or more tabs if the caller function (usually WndProc) is called recursively.
            Default true.
            </summary>
        </member>
        <member name="P:Au.Types.PrintMsgOptions.Skip">
            <summary>
            Ignore these messages.
            To specify a range of messages, use two array elements: first message and negative last message.
            </summary>
        </member>
        <member name="P:Au.Types.PrintMsgOptions.WindowProperties">
            <summary>
            Append window classname, name and rectangle.
            </summary>
        </member>
        <member name="T:Au.Types.WDLArgs">
            <summary>
            <see cref="M:Au.wnd.more.dragLoop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Types.WDLArgs})"/> callback function arguments.
            </summary>
        </member>
        <member name="F:Au.Types.WDLArgs.Msg">
            <summary>
            Current message retrieved by API <msdn>GetMessage</msdn>.
            API <msdn>MSG</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.WDLArgs.Cursor">
            <summary>
            Native cursor handle. The callback function can set this to temporarily set cursor.
            </summary>
        </member>
        <member name="M:Au.Types.WDLArgs.Stop">
            <summary>
            The callback function can call this to end the operation.
            </summary>
        </member>
        <member name="T:Au.Types.RWCEtc">
            <summary>
            Used with <see cref="M:Au.wnd.more.registerWindowClass(System.String,Au.Types.WNDPROC,Au.Types.RWCEtc)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WTBProgressState">
            <summary>
            Used by <see cref="M:Au.wnd.more.taskbarButton.setProgressState(Au.wnd,Au.Types.WTBProgressState)"/>.
            </summary>
        </member>
        <member name="T:Au.More.XmlUtil">
            <summary>
            Contains static functions to load <b>XElement</b> and <b>XDocument</b> in a safer way.
            </summary>
        </member>
        <member name="M:Au.More.XmlUtil.LoadElem(System.String,System.Xml.Linq.LoadOptions)">
            <summary>
            Loads XML file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)"/> and <see cref="M:Au.filesystem.waitIfLocked(System.Action,System.Int32)"/>.
            </summary>
            <param name="file">
            File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            If starts with '&lt;', loads from XML string instead.
            </param>
            <param name="options"></param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XElement.Load(System.IO.Stream)"/>.</exception>
            <remarks>
            Unlike <see cref="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)"/>, does not replace <c>\r\n</c> with <c>\n</c>.
            </remarks>
        </member>
        <member name="M:Au.More.XmlUtil.LoadDoc(System.String,System.Xml.Linq.LoadOptions)">
            <summary>
            Loads XML file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)"/> and <see cref="M:Au.filesystem.waitIfLocked(System.Action,System.Int32)"/>.
            </summary>
            <param name="file">
            File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            If starts with '&lt;', loads from XML string instead.
            </param>
            <param name="options"></param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)"/>.</exception>
            <remarks>
            Unlike <see cref="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)"/>, does not replace <c>\r\n</c> with <c>\n</c>.
            </remarks>
        </member>
        <member name="T:Au.More.GridSplitter2">
            <summary>
            Grid splitter control. Based on <see cref="T:System.Windows.Controls.GridSplitter"/>, changes its behavior.
            </summary>
            <remarks>
            Try this class when <see cref="T:System.Windows.Controls.GridSplitter"/> does not work as you want.
            
            Limitations (bad or good):
            - Splitters must be on own rows/columns. Throws exception if <b>ResizeBehavior</b> is not <b>PreviousAndNext</b> (which is default).
            - Throws exception is there are star-sized splitter rows.
            - Does not resize auto-sized rows/columns. Only pixel-sized and star-sized.
            - With UseLayoutRounding may flicker when resizing, especially when high DPI.
            </remarks>
        </member>
        <member name="M:Au.More.GridSplitter2.#ctor">
            
        </member>
        <member name="M:Au.More.GridSplitter2.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            
        </member>
        <member name="P:Au.More.GridSplitter2.ResizeNearest">
            <summary>
            Always resize only the nearest resizable row/column at each side.
            If false (default), may resize multiple star-sized rows/columns, unless with Ctrl key.
            </summary>
        </member>
        <member name="T:Au.More.ActCtx_">
            <summary>
            Activates our manifest which tells to use comctl32.dll version 6.
            The manifest is embedded in this dll, resource id 2.
            </summary>
        </member>
        <member name="T:Au.More.ArrayBuilder_`1">
            <summary>
            Like List or StringBuilder, used as a temporary variable-size array to create final fixed-size array.
            To avoid much garbage (and many reallocations when growing), uses native memory heap. See <see cref="T:Au.More.MemoryUtil"/>.
            Must be explicitly disposed to free the native memory. Does not have a finalizer because is struct (to avoid garbage).
            Does not support reference types. Does not call T.Dispose.
            </summary>
        </member>
        <member name="P:Au.More.ArrayBuilder_`1.Ptr">
            <summary>
            Gets array memory address (address of element 0).
            </summary>
        </member>
        <member name="P:Au.More.ArrayBuilder_`1.Count">
            <summary>
            Gets the number of elements.
            </summary>
        </member>
        <member name="P:Au.More.ArrayBuilder_`1.ByteCount">
            <summary>
            Gets the number of bytes in the array (Count*sizeof(T)).
            </summary>
        </member>
        <member name="P:Au.More.ArrayBuilder_`1.Capacity">
            <summary>
            Gets or sets the total number of elements (not bytes) the internal memory can hold without resizing.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">(the 'set' function) value less than Count. Instead use ReAlloc or Free.</exception>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.Alloc(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Allocates count elements. Sets Count=count.
            Frees previously allocated memory.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">Element count.</param>
            <param name="zeroInit">Set all bytes = 0. If false, the memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <param name="noExtra">Set Capacity = count. If false, allocates more if count is less thah the minimal capacity for this type.</param>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.ReAlloc(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Adds or removes elements at the end. Sets Count=count.
            Preserves Math.Min(Count, count) existing elements.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">New element count.</param>
            <param name="zeroInit">Set all added bytes = 0. If false, the added memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <param name="noExtra">Set Capacity = count. If false, allocates more if count is less thah the minimal capacity for this type.</param>
            <remarks>
            The new memory usually is at a new location. The preserved elements are copied there.
            Sets Count=count. To allocate more memory without changing Count, change Capacity instead.
            </remarks>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.Free">
            <summary>
            Frees memory. Sets Count and Capacity = 0.
            </summary>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.AddR(`0@)">
            <summary>
            Adds one element.
            The same as Add, but uses 'in'. Use to avoid copying values of big types.
            </summary>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.Add(`0)">
            <summary>
            Adds one element.
            </summary>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.Add">
            <summary>
            Adds one zero-inited element and returns its reference.
            </summary>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1._EnsureCapacity">
            <summary>
            Capacity = Math.Max(_cap * 2, s_minCap).
            </summary>
        </member>
        <member name="P:Au.More.ArrayBuilder_`1.Item(System.Int32)">
            <summary>
            Gets element reference.
            </summary>
            <param name="i">Element index.</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Au.More.ArrayBuilder_`1.ToArray">
            <summary>
            Copies elements to a new managed array.
            </summary>
        </member>
        <member name="T:Au.More.AssemblyUtil_">
            <summary>
            Assembly functions.
            </summary>
        </member>
        <member name="M:Au.More.AssemblyUtil_.IsDebug(System.Reflection.Assembly)">
            <summary>
            Returns true if the build configuration of the assembly is Debug. Returns false if Release (optimized).
            </summary>
            <remarks>
            Returns true if the assembly has <see cref="T:System.Diagnostics.DebuggableAttribute"/> and its <b>IsJITTrackingEnabled</b> is true.
            </remarks>
        </member>
        <member name="M:Au.More.AssemblyUtil_.IsLoadedWinformsWpf">
            <summary>
            Returns flags for loaded assemblies: 1 System.Windows.Forms, 2 WindowsBase (WPF).
            </summary>
        </member>
        <member name="T:Au.More.AttachThreadInput_">
            <summary>
            Calls API <msdn>AttachThreadInput</msdn> to attach/detach thread input.
            Constructor attaches thread input of this thread to that of the specified thread. <b>Dispose</b> detaches.
            </summary>
        </member>
        <member name="M:Au.More.AttachThreadInput_.#ctor(System.Int32,System.Boolean@)">
            <summary>
            Attaches thread input of this thread to that of the specified thread.
            </summary>
        </member>
        <member name="M:Au.More.AttachThreadInput_.Dispose">
            <summary>
            Detaches thread input.
            </summary>
        </member>
        <member name="P:Au.More.AttachThreadInput_.IsAttached">
            <summary>
            Returns true if AttachThreadInput succeeded and this variable is not disposed.
            </summary>
        </member>
        <member name="T:Au.More.CharPtr_">
            <summary>
            String functions that work with unmanaged char* strings.
            See also <see cref="T:Au.More.BytePtr_"/>, it works with byte* strings.
            </summary>
        </member>
        <member name="M:Au.More.CharPtr_.Length(System.Char*)">
            <summary>
            Gets the number of characters in p until '\0'.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
        </member>
        <member name="M:Au.More.CharPtr_.Length(System.Char*,System.Int32)">
            <summary>
            Gets the number of characters in p until '\0' or <i>max</i>.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
            <param name="max">Max length to scan. Returns max if does not find '\0'.</param>
        </member>
        <member name="T:Au.More.BytePtr_">
            <summary>
            String functions that work with unmanaged byte* strings.
            See also <see cref="T:Au.More.CharPtr_"/>, it works with char* strings.
            </summary>
        </member>
        <member name="M:Au.More.BytePtr_.Length(System.Byte*)">
            <summary>
            Gets the number of bytes in p until '\0'.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
        </member>
        <member name="M:Au.More.BytePtr_.Length(System.Byte*,System.Int32)">
            <summary>
            Gets the number of bytes in p until '\0' or <i>max</i>.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
            <param name="max">Max length to scan. Returns max if does not find '\0'.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiStarts(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p starts with string s. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiStartsi(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p starts with string s. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiEq(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p and string s are equal. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Managed string. Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiEqi(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p and string s are equal. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.More.BytePtr_.Eq(System.Byte*,System.Byte[])">
            <summary>
            Case-sensitive compares unmanaged string p with byte[] s and returns true if they are equal.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Managed string. Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiFindChar(System.Byte*,System.Int32,System.Byte)">
            <summary>
            Finds character in string which can be binary.
            </summary>
            <param name="p"></param>
            <param name="len">Length of p to search in.</param>
            <param name="ch">ASCII character.</param>
        </member>
        <member name="M:Au.More.BytePtr_.AsciiFindString(System.Byte*,System.Int32,System.String)">
            <summary>
            Finds substring in string which can be binary.
            Returns -1 if not found.
            </summary>
            <param name="p"></param>
            <param name="len">Length of p to search in.</param>
            <param name="s">Substring to find. Must contain only ASCII characters.</param>
        </member>
        <member name="T:Au.More.Debug_">
            <summary>
            Functions useful to debug code.
            </summary>
            <remarks>
            The Debug_.PrintX functions write to the same output as <see cref="M:Au.print.it(System.String)"/>, not to the trace listeners like <see cref="M:System.Diagnostics.Debug.Print(System.String)"/> etc do. Also they add caller's name, file and line number.
            Functions Print, PrintIf, PrintFunc and Dialog work only if DEBUG is defined, which normally is when the caller project is in Debug configuration. Else they are not called, and arguments not evaluated at run time. This is because they have [<see cref="T:System.Diagnostics.ConditionalAttribute"/>("DEBUG")].
            Note: when used in a library, the above functions depend on DEBUG of the library project and not on DEBUG of the consumer project of the library. For example, the library may be in Release configuration even if its consumer project is in Debug configuration. If your library wants to show some info only if its consumer project is in Debug config, instead you can use code like <c>if(opt.warnings.Verbose) print.warning("text");</c>; see <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>, opt.warnings.<see cref="P:Au.Types.OWarnings.Verbose"/>.
            </remarks>
        </member>
        <member name="M:Au.More.Debug_.Print(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.print.it(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            If text starts with "&lt;&gt;", it can contain output tags.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.PrintIf(System.Boolean,System.Object,System.String,System.Int32,System.String)">
            <summary>
            If condition is true, calls <see cref="M:Au.print.it(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            If text starts with "&lt;&gt;", it can contain output tags.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.PrintFunc(System.String)">
            <summary>
            Calls <see cref="M:Au.print.it(System.String)"/> with current function name.
            Works only if DEBUG is defined. Read more in class help.
            The optional argument is not used explicitly.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.PrintNativeError_(System.String,System.Int32,System.String)">
            <summary>
            In DEBUG config prints lastError.message.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.PrintNativeError_(System.Int32,System.String,System.Int32,System.String)">
            <summary>
            In DEBUG config prints lastError.messageFor(code).
            </summary>
        </member>
        <member name="M:Au.More.Debug_.Dialog(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> to show some debug info.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.CheckFlagsOpt_``1(``0,``0)">
            <summary>
            Checks flags and throws ArgumentException if some flags are invalid. The error message includes valid flag names.
            </summary>
            <param name="flags">Flags to check.</param>
            <param name="goodFlags">Valid flags.</param>
            <remarks>
            Can be used in functions that have an enum flags parameter but not all passed flags are valid for that function or object state.
            Does nothing if opt.warnings.<see cref="P:Au.Types.OWarnings.Verbose"/> == false.
            When flags are valid, this function is fast.
            </remarks>
        </member>
        <member name="P:Au.More.Debug_.IsAuDebugConfiguration">
            <summary>
            Returns true if using Debug configuration of Au.dll.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.MemoryGet_(System.Boolean)">
            <summary>
            Returns managed memory size as formatted string. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>MemorySetAnchor_</b>.</param>
        </member>
        <member name="M:Au.More.Debug_.MemoryPrint_(System.Boolean)">
            <summary>
            Prints managed memory size. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>MemorySetAnchor_</b>.</param>
        </member>
        <member name="M:Au.More.Debug_.MemorySetAnchor_">
            <summary>
            Memorizes current managed memory size, so that next call to another <b>MemoryX</b> function with fromAnchor=true (default) will get memory size difference from current memory size.
            </summary>
        </member>
        <member name="M:Au.More.Debug_.PrintLoadedAssemblies(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Prints assemblies already loaded or/and loaded in the future.
            </summary>
        </member>
        <member name="T:Au.More.GC_">
            <summary>
            <see cref="T:System.GC"/> extensions.
            </summary>
        </member>
        <member name="M:Au.More.GC_.AddObjectMemoryPressure(System.Object,System.Int64)">
            <summary>
            Calls <see cref="M:System.GC.AddMemoryPressure(System.Int64)"/>. Later, when object <i>obj</i> is garbage-collected, will call <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)"/>.
            </summary>
            <param name="obj">An object of any type.</param>
            <param name="size">Unmanaged memory size. It is passed to <b>GC.AddMemoryPressure</b> and <b>GC.RemoveMemoryPressure</b>.</param>
        </member>
        <member name="P:Au.More.GC_.UserHandleCollector">
            <summary>
            Provides a static <see cref="T:System.Runtime.InteropServices.HandleCollector"/> for USER handles, created with this code: <c>new("Au.User", 300, 3000);</c>.
            </summary>
            <remarks>
            OS refuses to create more USER objects than the process quota. Normally it is 10000, but can be min 200. It is set in registry.
            </remarks>
        </member>
        <member name="P:Au.More.GC_.GdiHandleCollector">
            <summary>
            Provides a static <see cref="T:System.Runtime.InteropServices.HandleCollector"/> for GDI handles, created with this code: <c>new("Au.GDI", 300, 3000);</c>.
            </summary>
            <remarks>
            OS refuses to create more GDI objects than the process quota. Normally it is 10000, but can be min 200. It is set in registry.
            </remarks>
        </member>
        <member name="T:Au.More.ScreenDC_">
            <summary>
            Helps to get and release screen DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            </summary>
        </member>
        <member name="T:Au.More.WindowDC_">
            <summary>
            Helps to get and release window DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            </summary>
        </member>
        <member name="T:Au.More.MemoryDC_">
            <summary>
            Helps to create and delete compatible DC (memory DC) with the 'using(...){...}' pattern.
            Uses API CreateCompatibleDC and DeleteDC.
            </summary>
        </member>
        <member name="M:Au.More.MemoryDC_.#ctor">
            <summary>
            Creates memory DC compatible with screen.
            </summary>
        </member>
        <member name="T:Au.More.FontDC_">
            <summary>
            Memory DC with selected font.
            Can be used for font measurement.
            </summary>
        </member>
        <member name="M:Au.More.FontDC_.#ctor(System.IntPtr)">
            <summary>
            Selects specified font.
            The <b>Dispose</b> method will select it out but will not destroy it.
            </summary>
            <param name="font"></param>
        </member>
        <member name="M:Au.More.FontDC_.#ctor(Au.Types.DpiOf)">
            <summary>
            Selects standard UI font for specified DPI.
            </summary>
            <param name="dpi"></param>
        </member>
        <member name="M:Au.More.FontDC_.Measure(System.String)">
            <summary>
            Measures text with API <msdn>GetTextExtentPoint32</msdn>.
            Should be single line without tabs. For drawing with API <msdn>TextOut</msdn> or <msdn>ExtTextOut</msdn>.
            </summary>
        </member>
        <member name="M:Au.More.FontDC_.Measure(System.String,System.Int32,Au.Types.TFFlags,System.Int32)">
            <summary>
            Measures text with API <msdn>DrawText</msdn>.
            Can be multiline. For drawing with API <msdn>DrawText</msdn>.
            </summary>
        </member>
        <member name="M:Au.More.FontDC_.Measure(System.String,Au.Types.TFFlags,System.Int32)">
            <summary>
            Measures text with API <msdn>DrawText</msdn>.
            Can be multiline. For drawing with API <msdn>DrawText</msdn>.
            </summary>
        </member>
        <member name="M:Au.More.Pen_.DrawLine(System.IntPtr,Au.Types.POINT,Au.Types.POINT)">
            <summary>
            Draws line and returns previous "current position".
            Don't need to select pen into DC.
            </summary>
        </member>
        <member name="T:Au.More.Handle_">
            <summary>
            Manages a kernel handle.
            Must be disposed.
            Has static functions to open process handle.
            </summary>
        </member>
        <member name="M:Au.More.Handle_.#ctor(System.IntPtr)">
            <summary>
            Attaches a kernel handle to this new variable.
            No exception when handle is invalid.
            If handle == -1, sets 0.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="P:Au.More.Handle_.Is0">
            <summary>
            _h == default.
            Info: _h never is -1.
            </summary>
        </member>
        <member name="M:Au.More.Handle_.Dispose">
            
        </member>
        <member name="M:Au.More.Handle_.OpenProcess(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Calls API OpenProcess.
            Returns default if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="processId">Process id.</param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="M:Au.More.Handle_.OpenProcess(Au.wnd,System.UInt32)">
            <summary>
            Opens window's process handle.
            This overload is more powerful: if API OpenProcess fails, it tries API GetProcessHandleFromHwnd, which can open higher integrity level processes, but only if current process is uiAccess and desiredAccess includes only PROCESS_DUP_HANDLE, PROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, SYNCHRONIZE.
            Returns default if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="w"></param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="T:Au.More.WaitHandle_">
            <summary>
            Kernel handle that is derived from WaitHandle.
            When don't need to wait, use <see cref="T:Au.More.Handle_"/>, it's more lightweight and has more creation methods.
            </summary>
        </member>
        <member name="M:Au.More.WaitHandle_.FromProcessId(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Returns null if failed.
            </summary>
            <param name="pid"></param>
            <param name="desiredAccess"></param>
        </member>
        <member name="P:Au.More.ILInstruction.RawData">
            <summary>
            Gets the raw data.
            </summary>
        </member>
        <member name="P:Au.More.ILInstruction.Data">
            <summary>
            Gets the data.
            </summary>
        </member>
        <member name="P:Au.More.ILInstruction.Address">
            <summary>
            Gets the address of the instruction.
            </summary>
        </member>
        <member name="P:Au.More.ILInstruction.InstructionIndex">
            <summary>
            Gets the index of the instruction.
            </summary>
            <value>
            The index of the instruction.
            </value>
        </member>
        <member name="P:Au.More.ILInstruction.DataValue">
            <summary>
            Gets the value as integer
            </summary>
            <value>The data value.</value>
        </member>
        <member name="P:Au.More.ILInstruction.Length">
            <summary>
            Gets the length of the instructions and operands.
            </summary>
            <value>The length.</value>
        </member>
        <member name="M:Au.More.ILInstruction.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Au.More.ILReader">
            <summary>
            Reads IL instructions from a byte stream.
            </summary>
            <remarks>Allows generated code to be viewed without debugger or enabled debug assemblies.</remarks>
        </member>
        <member name="F:Au.More.ILReader.instructionLookup">
            <summary>
            The _instruction lookup.
            </summary>
        </member>
        <member name="F:Au.More.ILReader.intermediateLanguageProvider">
            <summary>
            The IL reader provider.
            </summary>
        </member>
        <member name="M:Au.More.ILReader.#ctor(System.Reflection.MethodInfo,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Au.More.ILReader"/> class.
            </summary>
        </member>
        <member name="P:Au.More.ILReader.Instructions">
            <summary>
            Gets the instructions.
            </summary>
            <value>The instructions.</value>
        </member>
        <member name="M:Au.More.ILReader.IsInstructionPrefix(System.Int16)">
            <summary>
            Checks to see if the IL instruction is a prefix indicating the length of the instruction is two bytes long.
            </summary>
            <param name="value">The IL instruction as a byte.</param>
            <remarks>IL instructions can either be 1 or 2 bytes.</remarks>
            <returns>True if this IL instruction is a prefix indicating the instruction is two bytes long.</returns>
        </member>
        <member name="M:Au.More.ILReader.GetLookupTable">
            <summary>
            The get lookup table.
            </summary>
            <returns>
            A dictionary of IL instructions.
            </returns>
        </member>
        <member name="M:Au.More.ILReader.GetSize(System.Reflection.Emit.OperandType)">
            <summary>
            Gets the size of a operand.
            </summary>
            <param name="operandType">Defines the type of operand.</param>
            <returns>The size in bytes of the operand type.</returns>
        </member>
        <member name="T:Au.More.Jit_">
            <summary>
            JIT-compiles methods.
            </summary>
        </member>
        <member name="M:Au.More.Jit_.Compile(System.Type,System.String)">
            <summary>
            JIT-compiles method.
            Uses <b>RuntimeHelpers.PrepareMethod</b>.
            </summary>
            <param name="type">Type containing the method.</param>
            <param name="method">Method name.</param>
            <exception cref="T:System.ArgumentException">Method does not exist.</exception>
            <exception cref="T:System.Reflection.AmbiguousMatchException">Multiple overloads exist.</exception>
        </member>
        <member name="M:Au.More.Jit_.Compile(System.Type,System.String[])">
            <summary>
            JIT-compiles multiple methods of same type.
            Uses <b>RuntimeHelpers.PrepareMethod</b>.
            </summary>
            <param name="type">Type containing the methods.</param>
            <param name="methods">Method names.</param>
            <exception cref="T:System.ArgumentException">Method does not exist.</exception>
        </member>
        <member name="T:Au.More.NativeFont_">
            <summary>
            Creates and manages native font handle.
            </summary>
        </member>
        <member name="M:Au.More.NativeFont_.RegularCached(System.Int32)">
            <summary>
            Cached standard font used by most windows and controls.
            On Windows 10 it is "Segoe UI" 9 by default.
            </summary>
        </member>
        <member name="M:Au.More.NativeFont_.BoldCached(System.Int32)">
            <summary>
            Cached standard bold font used by most windows and controls.
            </summary>
        </member>
        <member name="T:Au.More.NativeScrollbar_">
            <summary>
            Manages native vertical or horizontal scrollbar of a window.
            </summary>
        </member>
        <member name="M:Au.More.NativeScrollbar_.ShowVH(Au.More.NativeScrollbar_,System.Boolean,Au.More.NativeScrollbar_,System.Boolean)">
            <summary>
            If need, shows or hides vertical and/or horizontal scrollbar of same window.
            When need to show or hide both, this function is 2 times faster than calling <see cref="P:Au.More.NativeScrollbar_.Visible"/> separately.
            </summary>
        </member>
        <member name="P:Au.More.NativeScrollbar_.Pos">
            <summary>
            Gets current scroll position (index of top visible item).
            Setter sets scroll position, clamped 0-Max. Does not invalidate the control.
            </summary>
        </member>
        <member name="P:Au.More.NativeScrollbar_.Max">
            <summary>
            Gets max scroll position. Returns 0 if no scrollbar.
            </summary>
        </member>
        <member name="P:Au.More.NativeScrollbar_.NItems">
            <summary>
            Gets or sets item count.
            Use setter to set item count when there is no scrollbar; it is used by <see cref="M:Au.More.NativeScrollbar_.KeyNavigate(System.Int32,Au.Types.KKey)"/>; asserts !Visible.
            </summary>
        </member>
        <member name="E:Au.More.NativeScrollbar_.PosChanged">
            <summary>
            When scrollbar position changed.
            The int parameter is event source: if scrollbar, it is one of Api.SB_ constants; if <see cref="P:Au.More.NativeScrollbar_.Pos"/>, it is -1; if wheel, it is -2 if down, -3 if up.
            </summary>
        </member>
        <member name="M:Au.More.NativeScrollbar_.KeyNavigate(System.Int32,Au.Types.KKey)">
            <summary>
            Calculates new focused item index when pressed key Down, Up, PageDown, PageUp, End or Home.
            </summary>
            <param name="i">Current focused item index. Can be -1.</param>
            <param name="k"></param>
            <remarks>
            This scrollbar must be vertical. Asserts.
            Returns unchanged <i>i</i> (even if -1) if <i>k</i> isn't a navigation key or if cannot change focused item.
            Works like standard list controls.
            </remarks>
        </member>
        <member name="T:Au.More.PostToThisThread_">
            <summary>
            Executes actions in same UI thread as ctor.
            Use <see cref="P:Au.More.PostToThisThread_.OfThisThread"/>. Cannot create more instances.
            </summary>
        </member>
        <member name="M:Au.More.ProcessStarter_.#ctor(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Prepares parameters for API <msdn>CreateProcess</msdn> and similar.
            </summary>
            <param name="exe">
            Full path of program file. If not full path, uses <see cref="P:Au.folders.ThisApp"/>. Uses <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            If <i>rawExe</i> true, does not use <b>Normalize</b>/<b>ThisApp</b>.
            </param>
            <param name="args">null or command line arguments.</param>
            <param name="curDir">
            Initial current directory of the new process.
            - If null, uses <c>Directory.GetCurrentDirectory()</c>.
            - Else if <i>rawCurDir</i>==true, uses raw <i>curDir</i> value.
            - Else if "", calls <c>pathname.getDirectory(exe)</c>.
            - Else calls <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
            <param name="envVar">null or environment variables to pass to the new process together with variables of this process. Format: "var1=value1\0var2=value2\0". If ends with "\0\0", will pass only these variables.</param>
            <param name="rawExe">Don't normalize <i>exe</i>.</param>
            <param name="rawCurDir">Don't normalize <i>curDir</i>.</param>
        </member>
        <member name="M:Au.More.ProcessStarter_.StartL(Au.Types.Api.PROCESS_INFORMATION@,System.Boolean,System.Boolean)">
            <summary>
            Starts process using API CreateProcess or CreateProcessAsUser, without the feedback hourglass cursor.
            </summary>
            <param name="pi">Receives CreateProcessX results. Will need to close handles in pi, eg pi.Dispose.</param>
            <param name="inheritUiaccess">If this process has UAC integrity level uiAccess, let the new process inherit it.</param>
            <param name="inheritHandles">API parameter <i>bInheritHandles</i>.</param>
        </member>
        <member name="M:Au.More.ProcessStarter_.Start(Au.More.ProcessStarter_.Result.Need,System.Boolean)">
            <summary>
            Starts process using API CreateProcess or CreateProcessAsUser, without the feedback hourglass cursor.
            </summary>
            <param name="need">Which field to set in <b>Result</b>.</param>
            <param name="inheritUiaccess">If this process has UAC integrity level uiAccess, let the new process inherit it.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.More.ProcessStarter_.StartUserIL(Au.More.ProcessStarter_.Result.Need)">
            <summary>
            Starts UAC Medium integrity level (IL) process from this admin process.
            </summary>
            <param name="need">Which field to set in <b>Result</b>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Actually the process will have the same IL and user session as the shell process (normally explorer).
            Fails if there is no shell process (API GetShellWindow fails) for more than 2 s from calling this func.
            Asserts and fails if this is not admin/system process. Caller should at first call <see cref="P:Au.uacInfo.isAdmin"/> or <see cref="P:Au.uacInfo.IntegrityLevel"/>.
            </remarks>
        </member>
        <member name="T:Au.More.ProcessStarter_.Result">
            <summary>
            Results of <see cref="T:Au.More.ProcessStarter_"/> functions.
            </summary>
        </member>
        <member name="T:Au.More.ProcessStarter_.Result.Need">
            <summary>
            Which field to set.
            </summary>
        </member>
        <member name="T:Au.More.ProcessStarter_._NetProcessObject">
            <summary>
            Creates new .NET Process object with attached handle and/or id.
            </summary>
        </member>
        <member name="P:Au.More.ProcessStarter_._NetProcessObject.IsFast">
            <summary>
            Returns true if can create such object in a fast/reliable way. Else <see cref="M:Au.More.ProcessStarter_._NetProcessObject.Create(System.IntPtr,System.Int32)"/> will use Process.GetProcessById.
            It depends on .NET framework version, because uses private methods of Process class through reflection.
            </summary>
        </member>
        <member name="M:Au.More.ProcessStarter_._NetProcessObject.Create(System.IntPtr,System.Int32)">
            <summary>
            Creates new .NET Process object with attached handle and/or id.
            Can be specified both handle and id, or one of them (then .NET will open process or get id from handle when need).
            </summary>
        </member>
        <member name="M:Au.More.ProcessStarter_._NetProcessObject.Create(Au.Types.Api.PROCESS_INFORMATION@,System.Boolean)">
            <summary>
            Creates new .NET Process object with attached handle and id.
            Closes thread handle. If suspended, resumes thread.
            </summary>
        </member>
        <member name="T:Au.More.Serializer_">
            <summary>
            Binary-serializes and deserializes multiple values of types int, string, string[], byte[] and null.
            Used mostly for sending parameters for IPC through pipe etc.
            Similar to BinaryWriter, but faster and less garbage. Much faster than BinaryFormatter, CSV, etc.
            Serializes all values into a byte[] in single call. If need to append, use BinaryWriter instead.
            </summary>
        </member>
        <member name="T:Au.More.Serializer_.Value">
            <summary>
            Type of input and output values of <see cref="T:Au.More.Serializer_"/> functions.
            Has implicit conversions from/to int and string.
            </summary>
        </member>
        <member name="M:Au.More.Serializer_.Serialize(Au.More.Serializer_.Value[])">
            <summary>
            Serializes multiple values of types int, string, string[] and null.
            The returned array can be passed to <see cref="M:Au.More.Serializer_.Deserialize(System.ReadOnlySpan{System.Byte})"/>.
            </summary>
        </member>
        <member name="M:Au.More.Serializer_.SerializeWithSize(Au.More.Serializer_.Value[])">
            <summary>
            Serializes multiple values of types int, string, string[] and null.
            Unlike <see cref="M:Au.More.Serializer_.Serialize(Au.More.Serializer_.Value[])"/>, in the first 4 bytes writes the size of data that follows.
            Can be used with pipes or other streams where data size is initially unknown: read 4 bytes as <c>int dataSize</c>; <c>var b=new byte[dataSize]</c>, read it, pass b to <see cref="M:Au.More.Serializer_.Deserialize(System.ReadOnlySpan{System.Byte})"/>. 
            </summary>
        </member>
        <member name="M:Au.More.Serializer_.Deserialize(System.ReadOnlySpan{System.Byte})">
            <summary>
            Deserializes values serialized by <see cref="M:Au.More.Serializer_.Serialize(Au.More.Serializer_.Value[])"/>.
            Returns array of values passed to <b>Serialize</b>.
            </summary>
        </member>
        <member name="T:Au.More.SharedMemory_">
            <summary>
            Memory shared by all processes using this library.
            </summary>
        </member>
        <member name="F:Au.More.SharedMemory_.Ptr">
            <summary>
            Pointer to the shared memory.
            </summary>
        </member>
        <member name="P:Au.More.SharedMemory_.ReturnDataPtr">
            <summary>
            Gets pointer to the shared memory "return data" buffer.
            Used by <see cref="M:Au.wnd.more.CopyData.Return(System.Void*,System.Int32,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Au.More.SharedMemory_.ReturnDataSize">
            <summary>
            Size of <see cref="P:Au.More.SharedMemory_.ReturnDataPtr"/> buffer, 1 MB.
            </summary>
        </member>
        <member name="T:Au.More.SharedMemory_.Mapping">
            <summary>
            Shared memory pointer and mapping handle.
            </summary>
        </member>
        <member name="P:Au.More.SharedMemory_.Mapping.Created">
            <summary>
            Created new memory. If false - opened existing.
            </summary>
        </member>
        <member name="M:Au.More.SharedMemory_.Mapping.CreateOrOpen(System.String,System.Int32)">
            <summary>
            Creates named shared memory of specified size. Opens if already exists.
            Returns <b>Mapping</b> variable that contains shared memory address in this process.
            </summary>
            <param name="name">Shared memory name. Case-insensitive.</param>
            <param name="size">Shared memory size. Ignored if the shared memory already exists.</param>
            <exception cref="T:Au.Types.AuException">The API failed.</exception>
            <remarks>
            Calls API <msdn>CreateFileMapping</msdn> and API <msdn>MapViewOfFile</msdn>.
            The shared memory is alive at least until this process ends or the returned <b>Mapping</b> variable disposed. Other processes can keep the memory alive even after that.
            </remarks>
        </member>
        <member name="T:Au.More.StaTaskScheduler_">
            <summary>Provides a scheduler that uses STA threads.</summary>
        </member>
        <member name="P:Au.More.StaTaskScheduler_.Default">
            <summary>
            Static auto-created <b>StaTaskScheduler_</b> instance with 4 threads.
            </summary>
        </member>
        <member name="F:Au.More.StaTaskScheduler_._tasks">
            <summary>Stores the queued tasks to be executed by our pool of STA threads.</summary>
        </member>
        <member name="F:Au.More.StaTaskScheduler_._threads">
            <summary>The STA threads used by the scheduler.</summary>
        </member>
        <member name="M:Au.More.StaTaskScheduler_.#ctor(System.Int32)">
            <summary>Initializes a new instance of the StaTaskScheduler class with the specified concurrency level.</summary>
            <param name="numberOfThreads">The number of threads that should be created and used by this scheduler.</param>
        </member>
        <member name="M:Au.More.StaTaskScheduler_.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a Task to be executed by this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:Au.More.StaTaskScheduler_.GetScheduledTasks">
            <summary>Provides a list of the scheduled tasks for the debugger to consume.</summary>
            <returns>An enumerable of all tasks currently scheduled.</returns>
        </member>
        <member name="M:Au.More.StaTaskScheduler_.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Determines whether a Task may be inlined.</summary>
            <param name="task">The task to be executed.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
        </member>
        <member name="P:Au.More.StaTaskScheduler_.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="M:Au.More.StaTaskScheduler_.Dispose">
            <summary>
            Cleans up the scheduler by indicating that no more tasks will be queued.
            This method blocks until all threads successfully shutdown.
            </summary>
        </member>
        <member name="T:Au.More.StringBuilder_">
            <summary>
            Provides a cached reusable instance of StringBuilder per thread. It's an optimisation that reduces the number of instances constructed and collected.
            Used like <c>using(new StringBuilder_(out var b)) { b.Append("example"); var s = b.ToString(); }</c>.
            </summary>
            <remarks>
            This is a modified copy of the .NET internal StringBuilderCache class.
            The cache uses 2 [ThreadLocal] StringBuilder instances, which allows 1 nesting level. Not error to use deeper nesting level, but then gets new StringBuilder, not from the cache.
            </remarks>
        </member>
        <member name="F:Au.More.StringBuilder_.MAX_BUILDER_SIZE">
            <summary>
            2000. The cache is not used if capacity is bigger.
            </summary>
        </member>
        <member name="M:Au.More.StringBuilder_.#ctor(System.Text.StringBuilder@,System.Int32)">
            <summary>
            Gets a new or cached/cleared StringBuilder of the specified capacity, min 200.
            </summary>
        </member>
        <member name="M:Au.More.StringBuilder_.Dispose">
            <summary>
            Releases the StringBuilder to the cache.
            </summary>
        </member>
        <member name="T:Au.More.Tables_">
            <summary>
            Lookup tables for various functions of this library.
            </summary>
        </member>
        <member name="F:Au.More.Tables_.Hex">
            <summary>
            Table for <see cref="M:Au.More.Convert2.HexDecode(System.ReadOnlySpan{System.Char})"/> and co.
            </summary>
        </member>
        <member name="P:Au.More.Tables_.LowerCase">
            <summary>
            Native-memory char[0x10000] containing lower-case versions of the first 0x10000 characters.
            </summary>
        </member>
        <member name="T:Au.More.BufferedPaint">
            <summary>
            Wraps buffered paint API <msdn>BeginBufferedPaint</msdn> etc.
            </summary>
        </member>
        <member name="M:Au.More.BufferedPaint.Init">
            <summary>
            Calls API <msdn>BufferedPaintInit</msdn>.
            </summary>
        </member>
        <member name="M:Au.More.BufferedPaint.Uninit">
            <summary>
            Calls API <msdn>BufferedPaintUnInit</msdn>.
            </summary>
        </member>
        <member name="P:Au.More.BufferedPaint.NonBufferedDC">
            <summary>
            Gets window DC.
            </summary>
        </member>
        <member name="P:Au.More.BufferedPaint.DC">
            <summary>
            Gets the buffered DC. Returns <see cref="P:Au.More.BufferedPaint.NonBufferedDC"/> if API <msdn>BeginBufferedPaint</msdn> failed.
            </summary>
        </member>
        <member name="P:Au.More.BufferedPaint.ClientRect">
            <summary>
            Gets client area rectangle.
            </summary>
        </member>
        <member name="P:Au.More.BufferedPaint.UpdateRect">
            <summary>
            Gets bounding rectangle of the update region in client area rectangle.
            </summary>
        </member>
        <member name="M:Au.More.BufferedPaint.#ctor(Au.wnd,System.Boolean)">
            <summary>
            Gets nonbuffered DC with API <msdn>BeginPaint</msdn> or <msdn>GetDC</msdn>. Then gets buffered DC with API <msdn>BeginBufferedPaint</msdn> for entire client area.
            </summary>
            <param name="w"></param>
            <param name="wmPaint">Use API <b>BeginPaint</b>/<b>EndPaint</b>. If false, uses <b>GetDC</b>/<b>ReleaseDC</b>.</param>
        </member>
        <member name="M:Au.More.BufferedPaint.Dispose">
            <summary>
            Calls API <msdn>EndBufferedPaint</msdn> and <msdn>EndPaint</msdn> or <msdn>ReleaseDC</msdn>.
            </summary>
        </member>
        <member name="T:Au.More.Convert2">
            <summary>
            Data conversion functions - compress, hex-encode, Base64, UTF8.
            </summary>
        </member>
        <member name="M:Au.More.Convert2.HexEncode(System.Void*,System.Int32,System.Boolean)">
            <summary>
            Converts binary data stored in any memory to hex-encoded string.
            </summary>
            <param name="data">The data. Can be any valid memory of specified size, for example a struct address.</param>
            <param name="size">data memory size (bytes).</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.More.Convert2.HexEncode(System.Byte[],System.Boolean)">
            <summary>
            Converts byte[] to hex-encoded string.
            </summary>
            <param name="a">The data.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>
            The result string length is 2 * array length.
            In most cases it's better to use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, then result is 4/3 of array length. Both functions are fast.
            </remarks>
        </member>
        <member name="M:Au.More.Convert2.HexEncode``1(``0,System.Boolean)">
            <summary>
            Converts a struct variable to hex-encoded string.
            </summary>
            <param name="x">Variable.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.More.Convert2.HexDecode(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts hex-encoded string to binary data as byte[].
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Hex-encoded data.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.More.Convert2.HexDecode(System.ReadOnlySpan{System.Char},System.Void*,System.Int32)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in caller's memory buffer.
            Returns the number of bytes stored in <i>decoded</i> memory. It is equal or less than <c>Math.Min(bufferSize, encoded.Length/2)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Hex-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="bufferSize">The max number of bytes that can be written to the <i>decoded</i> memory buffer.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.More.Convert2.HexDecode``1(System.ReadOnlySpan{System.Char},``0@)">
            <summary>
            Converts hex-encoded string to a struct variable.
            Returns false if decoded size != <c>sizeof(T)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">The result variable.</param>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlEncode(System.Byte[])">
            <summary>
            Converts byte[] to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="bytes">Data to encode.</param>
            <remarks>Like <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, but instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlEncode(System.Void*,System.Int32)">
            <summary>
            Converts binary data stored in any memory to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="bytes">Data to encode.</param>
            <param name="length">Number of bytes to encode.</param>
            <remarks>Instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlEncode``1(``0)">
            <summary>
            Converts a struct variable to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="x">Variable.</param>
            <remarks>Instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlEncodeLength(System.Int32)">
            <summary>
            Gets Base64-encoded string length for non-encoded length.
            It is <c>(length + 2) / 3 * 4</c>.
            </summary>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlDecodeLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets decoded data length from Base64-encoded string length.
            It is <c>(int)(len * 3L / 4)</c> minus the number of padding '=' characters (max 2).
            </summary>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlDecode(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts string containing Base64-encoded data to byte[]. Supports standard encoding and URL-safe encoding.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <remarks>Like <see cref="M:System.Convert.FromBase64String(System.String)"/>, but the string can contain '_' and '-' instead of '/' and '+'.</remarks>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlDecode(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts string containing Base64-encoded data to bytes and stores in memory of a Span variable. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or the buffer is too small.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="decodedLength"></param>
            <remarks>The string can contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlDecode(System.ReadOnlySpan{System.Char},System.Void*,System.Int32,System.Int32@)">
            <summary>
            Converts string containing Base64-encoded data to bytes and stores in any memory. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or the buffer is too small.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="bufferSize">The max number of bytes that can be written to the <i>decoded</i> memory buffer.</param>
            <param name="decodedLength">Receives the number of bytes written to the <i>decoded</i> memory buffer.</param>
            <remarks>The string can contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Base64UrlDecode``1(System.ReadOnlySpan{System.Char},``0@)">
            <summary>
            Converts string containing Base64-encoded data to a struct variable. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or decoded size != <c>sizeof(T)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">The result variable.</param>
            <remarks>The string can contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.More.Convert2.Compress(System.Byte[])">
            <summary>
            Compresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.More.Convert2.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Returns byte[] containing decompressed data.
            </summary>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.More.Convert2.Decompress(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Writes the decompressed data to a caller-provided memory stream.
            </summary>
            <param name="streamForDecompressedData">A memory stream where this function will write decompressed data. See example.</param>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
            <example>
            This code is used by the other Decompress overload.
            <code><![CDATA[
            using var stream = new MemoryStream();
            Decompress(stream, compressedData, index, count);
            return stream.ToArray();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.Convert2.ToUtf8(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Converts string to UTF-8 byte[]. Appends "\0" or some other string.
            </summary>
            <param name="chars">String or char[] or span of string/array/memory.</param>
            <param name="append">An optional ASCII string to append. For example "\0" (default) or "\r\n" or null.</param>
            <exception cref="T:System.ArgumentException"><i>append</i> contains non-ASCII characters.</exception>
        </member>
        <member name="M:Au.More.Convert2.FromUtf8(System.Byte*,System.Int32)">
            <summary>
            Converts UTF8 string to C# string (which is UTF16).
            The terminating '\0' character is not included in the returned string.
            </summary>
            <param name="utf8">UTF8 string. If null, returns null.</param>
            <param name="length">Length of <i>utf8</i>. If negative, the function finds length; then <i>utf8</i> must be '\0'-terminated.</param>
        </member>
        <member name="T:Au.More.DebugTraceListener">
            <summary>
            If defined DEBUG or TRACE, <see cref="M:Au.More.DebugTraceListener.Setup(System.Boolean)"/> replaces default trace listener with listener that overrides its <see cref="M:System.Diagnostics.DefaultTraceListener.Fail(System.String,System.String)"/> method. On failed assertion (<see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>, <see cref="M:System.Diagnostics.Trace.Assert(System.Boolean)"/>, <see cref="M:System.Diagnostics.Debug.Fail(System.String)"/>, <see cref="M:System.Diagnostics.Trace.Fail(System.String)"/>) it shows message box with buttons Exit|Debug|Ignore, unless debugger is attached or !<b>AssertUiEnabled</b>.
            </summary>
        </member>
        <member name="M:Au.More.DebugTraceListener.Setup(System.Boolean)">
            <summary>
            Replaces default trace listener.
            </summary>
            <param name="usePrint">Also set <see cref="P:Au.print.redirectDebugOutput"/> = true.</param>
        </member>
        <member name="M:Au.More.DebugTraceListener.Fail(System.String,System.String)">
            
        </member>
        <member name="T:Au.More.Dpi">
            <summary>
            Functions for high-DPI screen support.
            </summary>
            <remarks>
            To find DPI % on Windows 10: Settings -> System -> Display -> Scale and layout. If not 100%, it means high DPI. On older Windows versions it is in Control Panel -> Display.
            
            This program must be per-monitor-DPI-aware. Alse the results are undefined.
            </remarks>
        </member>
        <member name="P:Au.More.Dpi.System">
            <summary>
            Gets DPI of the primary screen at the time this process started.
            </summary>
        </member>
        <member name="M:Au.More.Dpi.OfWindow(Au.wnd,System.Boolean)">
            <summary>
            Gets DPI of a window.
            </summary>
            <param name="w">Top-level window or control. Can belong to any process.</param>
            <param name="ofScreen">
            If true, the function gets DPI for which the window is (or should be) scaled, either by the program or by the OS; it depends on window's current screen DPI.
            If false (default), gets DPI used internally by the window's program; it does not depend on whether the window is OS-scaled; it never changes for that window instance.
            </param>
            <remarks>
            If <i>ofScreen</i> is false (default), the result depends on the DPI awareness of the window:
            - per-monitor-DPI-aware - usually DPI of windows's screen.
            - system aware - system DPI (DPI of primary screen).
            - unaware - 96.
            
            To get window's internal DPI, on Windows 10 1607 and later uses API <msdn>GetDpiForWindow</msdn>. On Windows 8.1 and early Windows 10, if <see cref="P:Au.More.Dpi.SupportPMOnWin8_1"/> is true, uses API <msdn>GetDpiForMonitor</msdn>. Older Windows versions don't support per-monitor DPI.
            
            Returns the system DPI (<see cref="P:Au.More.Dpi.System"/>) if fails or if not supported on this Windows version (see <see cref="P:Au.More.Dpi.SupportPMOnWin8_1"/>).
            
            On Windows 7 and 8.0 always returns the system DPI, because of lack of Windows API; it is always correct only if <i>ofScreen</i> is true.
            </remarks>
        </member>
        <member name="M:Au.More.Dpi.OfWindow(System.Windows.Forms.Control)">
            <summary>
            Returns <c>OfWindow(w.Hwnd())</c>.
            </summary>
        </member>
        <member name="M:Au.More.Dpi.OfWindow(System.Windows.DependencyObject)">
            <summary>
            Returns <c>OfWindow(w.Hwnd())</c>.
            </summary>
        </member>
        <member name="M:Au.More.Dpi.OfScreen(System.IntPtr)">
            <summary>
            Gets DPI of a screen.
            Returns <see cref="P:Au.More.Dpi.System"/> if fails or if not supported on this Windows version (see <see cref="P:Au.More.Dpi.SupportPMOnWin8_1"/>).
            </summary>
            <remarks>
            Uses API <msdn>GetDpiForMonitor</msdn>.
            </remarks>
            <seealso cref="M:Au.screen.of(Au.wnd,Au.Types.SODefault,System.Boolean)"/>
        </member>
        <member name="P:Au.More.Dpi.SupportPMOnWin8_1">
            <summary>
            If true, <see cref="M:Au.More.Dpi.OfScreen(System.IntPtr)"/> and <see cref="M:Au.More.Dpi.OfWindow(Au.wnd,System.Boolean)"/> will support per-monitor DPI on Windows 8.1 and later.
            If false (default) - on Windows 10 1607 and later; on 8.1 will always return <see cref="P:Au.More.Dpi.System"/>.
            </summary>
            <remarks>
            This is a per-thread property. You can change/restore it before/after calling these functions.
            Before Windows 10 1607 it is difficult to support per-monitor DPI because of lack of API and OS/.NET support.
            </remarks>
        </member>
        <member name="M:Au.More.Dpi.Scale(System.Int32,Au.Types.DpiOf)">
            <summary>
            Scales <b>int</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Unscale(System.Int32,Au.Types.DpiOf)">
            <summary>
            Unscales <b>int</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Scale(Au.Types.SIZE,Au.Types.DpiOf)">
            <summary>
            Scales <b>SIZE</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Scale(System.Windows.Size,Au.Types.DpiOf)">
            <summary>
            Scales <b>System.Windows.Size</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Unscale(Au.Types.SIZE,Au.Types.DpiOf)">
            <summary>
            Unscales <b>SIZE</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Scale(Au.Types.RECT,Au.Types.DpiOf)">
            <summary>
            Scales <b>RECT</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.Unscale(Au.Types.RECT,Au.Types.DpiOf)">
            <summary>
            Unscales <b>RECT</b> if <i>dpiOf.Dpi</i> isn't 96 (100%).
            </summary>
        </member>
        <member name="M:Au.More.Dpi.GetSystemMetrics(System.Int32,Au.Types.DpiOf)">
            <summary>
            Calls API <msdn>GetSystemMetricsForDpi</msdn> if available, else <msdn>GetSystemMetrics</msdn>.
            </summary>
        </member>
        <member name="M:Au.More.Dpi.SystemParametersInfo(System.UInt32,System.Int32,System.Void*,Au.Types.DpiOf)">
            <summary>
            Calls API <msdn>SystemParametersInfoForDpi</msdn> if available, else <msdn>SystemParametersInfo</msdn>.
            Use only with <i>uiAction</i> = SPI_GETICONTITLELOGFONT, SPI_GETICONMETRICS, SPI_GETNONCLIENTMETRICS.
            </summary>
        </member>
        <member name="M:Au.More.Dpi.AdjustWindowRectEx(Au.Types.DpiOf,Au.Types.RECT@,Au.Types.WS,Au.Types.WSE,System.Boolean)">
            <summary>
            Calls API <msdn>AdjustWindowRectExForDpi</msdn> if available, else <msdn>AdjustWindowRectEx</msdn>.
            </summary>
            <remarks>
            Also adds scrollbar width or/and height if need.
            </remarks>
        </member>
        <member name="T:Au.More.Dpi.Awareness">
            <summary>
            DPI awareness of a window or process.
            </summary>
        </member>
        <member name="F:Au.More.Dpi.Awareness.Invalid">
            
        </member>
        <member name="F:Au.More.Dpi.Awareness.Unaware">
            
        </member>
        <member name="F:Au.More.Dpi.Awareness.System">
            
        </member>
        <member name="F:Au.More.Dpi.Awareness.PerMonitor">
            
        </member>
        <member name="M:Au.More.Dpi.WindowDpiAwareness(Au.wnd)">
            <summary>
            Gets DPI awareness of a window.
            </summary>
            <remarks>
            On Windows 7 and 8.0 always returns <b>System</b>, because of lack of Windows API.
            </remarks>
        </member>
        <member name="T:Au.More.Dpi.AwarenessContext">
            <summary>
            Can be used to temporarily change thread's DPI awareness context with API <msdn>SetThreadDpiAwarenessContext</msdn>.
            Does nothing if the API is unavailable (added in Windows 10 version 1607).
            </summary>
            <remarks>
            Programs that use this library should use manifest with dpiAwareness = PerMonitorV2 and dpiAware = True/PM. Then default DPI awareness context is DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2.
            </remarks>
            <example>
            <code><![CDATA[
            using var dac = new Dpi.AwarenessContext(Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_UNAWARE);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.Dpi.AwarenessContext.#ctor(System.IntPtr)">
            <summary>
            Calls API <msdn>SetThreadDpiAwarenessContext</msdn> if available.
            </summary>
            <param name="dpiContext">One of <b>DPI_AWARENESS_CONTEXT_X</b> constants, for example <see cref="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_UNAWARE"/>.</param>
        </member>
        <member name="M:Au.More.Dpi.AwarenessContext.Dispose">
            <summary>
            Restores previous DPI awareness context.
            </summary>
        </member>
        <member name="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_UNAWARE">
            
        </member>
        <member name="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_SYSTEM_AWARE">
            
        </member>
        <member name="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE">
            
        </member>
        <member name="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2">
            
        </member>
        <member name="F:Au.More.Dpi.AwarenessContext.DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED">
            
        </member>
        <member name="T:Au.More.FastBuffer`1">
            <summary>
            Memory buffer on stack with ability to expand and use heap memory. Used mostly for calling Windows API.
            Must be used with <c>[SkipLocalsInit]</c> attribute; add it to the caller function or class.
            </summary>
            <example>
            <code><![CDATA[
            print.it(api.GetEnvironmentVariable("temp"));
            
            unsafe class api : NativeApi {
            	[DllImport("kernel32.dll", EntryPoint = "GetEnvironmentVariableW", SetLastError = true)]
            	static extern int _GetEnvironmentVariable(string lpName, char* lpBuffer, int nSize);
            
            	[SkipLocalsInit]
            	internal static string GetEnvironmentVariable(string name) {
            		using FastBuffer<char> b = new(null);
            		for (; ; ) if (b.GetString(_GetEnvironmentVariable(name, b.p, b.n), out var s)) return s;
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="F:Au.More.FastBuffer`1.StackSize">
            <summary>
            A <b>FastBuffer</b> variable contains a field of this size. It is a memory buffer on stack.
            It is byte count and does not depend on T. To get count of T elements on stack: <c>StackSize/sizeof(T)</c>.
            </summary>
        </member>
        <member name="P:Au.More.FastBuffer`1.p">
            <summary>
            Memory buffer pointer.
            </summary>
        </member>
        <member name="M:Au.More.FastBuffer`1.op_Implicit(Au.More.FastBuffer{`0}@)~`0*">
            <summary>
            Returns memory buffer pointer (<see cref="P:Au.More.FastBuffer`1.p"/>).
            </summary>
        </member>
        <member name="P:Au.More.FastBuffer`1.Item(System.Int32)">
            <summary>
            Gets reference to p[i]. Does not check bounds.
            </summary>
        </member>
        <member name="P:Au.More.FastBuffer`1.n">
            <summary>
            Memory buffer length as number of elements of type T.
            </summary>
        </member>
        <member name="M:Au.More.FastBuffer`1.#ctor(System.String)">
            <summary>
            Allocates first buffer of default size. It is on stack (in this variable), and its length is StackSize/sizeof(T) elements of type T (2048 bytes or 1024 chars or 512 ints...).
            </summary>
            <param name="unused">Should be null. It makes the compiler to choose this overload. This function does not use this value.</param>
        </member>
        <member name="M:Au.More.FastBuffer`1.#ctor(System.Int32)">
            <summary>
            Allocates first buffer of specified size.
            </summary>
            <param name="n">
            Buffer length (number of elements of type T).
            If &lt;= StackSize/sizeof(T), the buffer contains StackSize/sizeof(T) elements on stack (in this variable); it is 2048 bytes or 1024 chars or 512 ints... Else allocates native memory (much slower).
            </param>
        </member>
        <member name="M:Au.More.FastBuffer`1.More(System.Int32)">
            <summary>
            Allocates new bigger buffer of specified length. Frees old buffer if need.
            </summary>
            <param name="n">Number of elements of type T.</param>
            <exception cref="T:System.ArgumentException"><i>n</i> &lt;= current buffer lenght.</exception>
        </member>
        <member name="M:Au.More.FastBuffer`1.More">
            <summary>
            Allocates new bigger buffer of at least <c>n*2</c> length. Frees old buffer if need.
            </summary>
        </member>
        <member name="M:Au.More.FastBuffer`1.Dispose">
            <summary>
            Frees allocated memory if need.
            </summary>
        </member>
        <member name="M:Au.More.FastBuffer`1.GetString(System.Int32,System.String@,Au.Types.BSFlags,System.String)">
            <summary>
            Gets API result as string, or allocates bigger buffer if old buffer was too small.
            This function can be used when T is char.
            </summary>
            <param name="r">The return value of the called Windows API function, if it returns string length or required buffer length. Or you can call <see cref="M:Au.More.FastBuffer`1.FindStringLength"/>.</param>
            <param name="s">Receives the result string if succeeded, else <i>sDefault</i> (default null).</param>
            <param name="flags">
            Use if the API function isn't like this:
            - If succeeds, returns string length without terminating null character.
            - If buffer too small, returns required buffer length.
            - If fails, returns 0.
            </param>
            <param name="sDefault">Set <i>s</i> = this string if buffer too small or <i>r</i> &lt; 1 or if the retrieved string == this string (avoid creating new string).</param>
            <returns>
            If <i>r</i> &gt; <b>n</b>, calls <c>More(r);</c> and returns false.
            Else creates new string of <i>r</i> length and returns true.
            </returns>
        </member>
        <member name="M:Au.More.FastBuffer`1.GetStringFindLength">
            <summary>
            Finds length of '\0'-terminated UTF-16 string in buffer and converts to C# string.
            This function can be used when T is char. Use when length is unknown.
            </summary>
            <remarks>
            If there is no '\0' character, gets whole buffer, and the string probably is truncated.
            </remarks>
        </member>
        <member name="M:Au.More.FastBuffer`1.FindStringLength">
            <summary>
            Finds length of '\0'-terminated UTF-16 string in buffer.
            Returns <see cref="P:Au.More.FastBuffer`1.n"/> if there is no '\0' character.
            </summary>
        </member>
        <member name="M:Au.More.FastBuffer`1.FindStringLengthAnsi">
            <summary>
            Finds length of '\0'-terminated ANSI string in buffer.
            Returns <see cref="P:Au.More.FastBuffer`1.n"/> if there is no '\0' character.
            </summary>
        </member>
        <member name="T:Au.More.Hash">
            <summary>
            Data hash functions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1(System.String)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1(System.Char*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1(System.ReadOnlySpan{System.Byte})">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1(System.Byte*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1``1(``0)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1Long(System.String)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1Long(System.Char*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1Long(System.ReadOnlySpan{System.Byte})">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1Long(System.Byte*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fnv1Long``1(``0)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fast(System.Char*,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
        </member>
        <member name="M:Au.More.Hash.Fast(System.String)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
            <param name="s">The string to hash. Can be null.</param>
        </member>
        <member name="M:Au.More.Hash.Fast(System.String,System.Int32,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            This overload hashes a substring.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.More.Hash.MD5Context">
            <summary>
            Computes MD5 hash of data.
            Multiple datas can be hashed, producing single result.
            Call <b>Add</b> one or more times. Finally use <see cref="P:Au.More.Hash.MD5Context.Hash"/> to get result.
            </summary>
            <remarks>
            Faster than the .NET MD5 hash functions.
            </remarks>
        </member>
        <member name="P:Au.More.Hash.MD5Context.IsEmpty">
            <summary>
            true if no data was added.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5Context.Add(System.Void*,System.Int32)">
            <summary>Adds data.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">size &lt; 0.</exception>
        </member>
        <member name="M:Au.More.Hash.MD5Context.Add``1(``0)">
            <summary>Adds data.</summary>
        </member>
        <member name="M:Au.More.Hash.MD5Context.Add(System.ReadOnlySpan{System.Byte})">
            <summary>Adds data.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
        </member>
        <member name="M:Au.More.Hash.MD5Context.Add(System.String)">
            <summary>Adds string converted to UTF8.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
        </member>
        <member name="P:Au.More.Hash.MD5Context.Hash">
            <summary>
            Computes final hash of datas added with <b>Add</b>.
            </summary>
            <exception cref="T:System.InvalidOperationException"><b>Add</b> was not called.</exception>
            <remarks>
            Resets state, so that if <b>Add</b> called again, it will start adding new datas.
            </remarks>
        </member>
        <member name="T:Au.More.Hash.MD5Result">
            <summary>
            Result of <see cref="P:Au.More.Hash.MD5Context.Hash"/>.
            It is 16 bytes stored in 2 long fields r1 and r2.
            If need, can be converted to byte[] with <see cref="M:Au.More.Hash.MD5Result.ToArray"/> or to hex string with <see cref="M:Au.More.Hash.MD5Result.ToString"/>.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5Result.ToString">
            <summary>
            Converts this to hex string of Length = 32.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5Result.ToArray">
            <summary>
            Converts this to byte[16].
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5Result.FromString(System.ReadOnlySpan{System.Char},Au.More.Hash.MD5Result@)">
            <summary>
            Creates <b>MD5Result</b> from hex string returned by <see cref="M:Au.More.Hash.MD5Result.ToString"/>.
            Returns false if <i>encoded</i> is invalid.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5(System.ReadOnlySpan{System.Byte})">
            <summary>
            Computes MD5 hash of data.
            Uses <see cref="T:Au.More.Hash.MD5Context"/>.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5(System.String)">
            <summary>
            Computes MD5 hash of string converted to UTF8.
            Uses <see cref="T:Au.More.Hash.MD5Context"/>.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5(System.ReadOnlySpan{System.Byte},System.Boolean)">
            <summary>
            Computes MD5 hash of data. Returns result as hex or base64 string.
            Uses <see cref="T:Au.More.Hash.MD5Context"/>.
            </summary>
        </member>
        <member name="M:Au.More.Hash.MD5(System.String,System.Boolean)">
            <summary>
            Computes MD5 hash of string converted to UTF8. Returns result as hex or base64 string.
            Uses <see cref="T:Au.More.Hash.MD5Context"/>.
            </summary>
        </member>
        <member name="M:Au.More.Hash.Crypto(System.ReadOnlySpan{System.Byte},System.String)">
            <summary>
            Computes data hash using the specified cryptographic algorithm.
            </summary>
            <param name="data"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
        </member>
        <member name="M:Au.More.Hash.Crypto(System.String,System.String)">
            <summary>
            Computes hash of string converted to UTF8, using the specified cryptographic algorithm.
            </summary>
            <param name="data"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
        </member>
        <member name="M:Au.More.Hash.Crypto(System.ReadOnlySpan{System.Byte},System.String,System.Boolean)">
            <summary>
            Computes data hash using the specified cryptographic algorithm. Returns result as hex or base64 string.
            </summary>
            <param name="data"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
            <param name="base64"></param>
        </member>
        <member name="M:Au.More.Hash.Crypto(System.String,System.String,System.Boolean)">
            <summary>
            Computes hash of string converted to UTF8, using the specified cryptographic algorithm. Returns result as hex or base64 string.
            </summary>
            <param name="data"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
            <param name="base64"></param>
        </member>
        <member name="T:Au.More.HelpUtil">
            <summary>
            Static functions to open a help topic etc.
            </summary>
        </member>
        <member name="M:Au.More.HelpUtil.AuHelp(System.String)">
            <summary>
            Opens an Au library help topic online.
            </summary>
            <param name="topic">Topic file name, like "Au.elm.find" or "elm.find" or "articles/Wildcard expression".</param>
        </member>
        <member name="M:Au.More.HelpUtil.AuHelpUrl(System.String)">
            <summary>
            Gets URL of an Au library help topic.
            </summary>
            <param name="topic">Topic file name, like "Au.elm.find" or "elm.find" or "articles/Wildcard expression".</param>
        </member>
        <member name="T:Au.More.IconImageCache">
            <summary>
            Gets <see cref="T:System.Drawing.Bitmap"/> images of same logical size to be displayed as icons. Can get file icons or load from files/resources/strings.
            </summary>
            <remarks>
            Uses memory cache and optionally file cache to avoid loading same image multiple times. Getting images from cache is much faster.
            Thread-safe.
            </remarks>
        </member>
        <member name="M:Au.More.IconImageCache.#ctor(System.Int32,System.String)">
            <param name="imageSize">Width and height of images. Min 16, max 256.</param>
            <param name="file">Path of cache file (SQLite database). If null, will be used only memory cache.</param>
        </member>
        <member name="P:Au.More.IconImageCache.Common">
            <summary>
            Common cache for icons of size 16. Used by menus, toolbars and editor.
            </summary>
            <remarks>
            If <c>script.role != SRole.ExeProgram &amp;&amp; folders.thisAppDriveType == DriveType.Removable</c>, uses cache file <c>folders.ThisAppDataLocal + @"iconCache16.db"</c>. Else uses only memory cache.
            </remarks>
        </member>
        <member name="M:Au.More.IconImageCache.Get(System.String,System.Int32,System.Boolean,System.Action{System.String,System.Exception})">
            <summary>
            Gets image from memory cache or file or resource.
            </summary>
            <param name="imageSource">File path, or resource path that starts with "resources/" or has prefix "resource:", etc. See <i>isImage</i> parameter.</param>
            <param name="dpi">DPI of window that will display the image. See <see cref="T:Au.More.Dpi"/>.</param>
            <param name="isImage">
            false - get file/folder/filetype/url/etc icon with <see cref="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)"/>. If <i>imageSource</i> is relative path of a .cs file, gets its custom icon as image; returns null if no custom icon or if editor isn't running.
            true - load image from xaml/png/etc file, resource or string with <see cref="M:Au.More.ImageUtil.LoadGdipBitmapFromFileOrResourceOrString(System.String,System.Nullable{System.ValueTuple{System.Int32,System.Nullable{Au.Types.SIZE}}})"/> or <see cref="M:Au.More.ImageUtil.LoadWpfImageElementFromFileOrResourceOrString(System.String)"/>. If editor is running, also supports icon name like "*Pack.Icon color"; see menu -> Tools -> Icons.
            
            To detect whether as string is an image, call <see cref="M:Au.More.ImageUtil.HasImageOrResourcePrefix(System.String)"/>; if it returns true, it is image.
            </param>
            <param name="onException">Action to call when fails to load image. If null, calls <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>. Parameters are image source string and exception.</param>
        </member>
        <member name="M:Au.More.IconImageCache.Dispose">
            <summary>
            Removes images from memory cache, closes database file and makes this object unusable.
            Optional; if not called, the cache will be disposed by GC or on process exit.
            </summary>
        </member>
        <member name="M:Au.More.IconImageCache.Finalize">
            
        </member>
        <member name="M:Au.More.IconImageCache.Clear(System.Boolean)">
            <summary>
            Removes images from memory cache and database file.
            </summary>
            <param name="redrawWindows">Redraw (asynchronously) all visible windows of this thread.</param>
        </member>
        <member name="T:Au.More.ImageUtil">
            <summary>
            Loads WPF and GDI+/winforms images from file, resource or string.
            </summary>
            <seealso cref="T:Au.More.ResourceUtil"/>
        </member>
        <member name="M:Au.More.ImageUtil.HasImageStringPrefix(System.String)">
            <summary>
            Returns true if string starts with "image:" or "~:".
            </summary>
        </member>
        <member name="M:Au.More.ImageUtil.HasImageOrResourcePrefix(System.String)">
            <summary>
            Returns true if string starts with "resource:" or "resources/" or "*" or "&lt;" or "imagefile:" or "image:" or "~:".
            </summary>
        </member>
        <member name="M:Au.More.ImageUtil.LoadImageStreamFromString(System.String)">
            <summary>
            Loads image as stream from Base-64 string that starts with "image:" (png) or "~:" (zipped bmp).
            </summary>
            <param name="s">Base-64 string with prefix "image:" or "~:".</param>
            <exception cref="T:System.ArgumentException">String does not start with "image:"/"~:" or is invalid Base-64.</exception>
            <exception cref="T:System.Exception"><see cref="M:Au.More.Convert2.Decompress(System.Byte[],System.Int32,System.Int32)"/> exceptions (when prefix "~:").</exception>
        </member>
        <member name="M:Au.More.ImageUtil.LoadGdipBitmapFromString(System.String)">
            <summary>
            Loads GDI+ image from Base-64 string that starts with "image:" (png) or "~:" (zipped bmp).
            </summary>
            <param name="s">Base-64 string with prefix "image:" or "~:".</param>
            <exception cref="T:System.ArgumentException">String does not start with "image:"/"~:" or is invalid Base-64.</exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Au.More.ImageUtil.LoadWpfImageFromString(System.String)">
            <summary>
            Loads WPF image from Base-64 string that starts with "image:" (png) or "~:" (zipped bmp).
            </summary>
            <param name="s">Base-64 string with prefix "image:" or "~:".</param>
            <exception cref="T:System.ArgumentException">String does not start with "image:"/"~:" or is invalid Base-64.</exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Au.More.ImageUtil.TryLoadGdipBitmapFromString(System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:Au.More.ImageUtil.LoadGdipBitmapFromString(System.String)"/> and handles exceptions. On exception returns null and optionally writes warning to the output.
            </summary>
        </member>
        <member name="M:Au.More.ImageUtil.TryLoadWpfImageFromString(System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:Au.More.ImageUtil.LoadWpfImageFromString(System.String)"/> and handles exceptions. On exception returns null and optionally writes warning to the output.
            </summary>
        </member>
        <member name="M:Au.More.ImageUtil.LoadGdipBitmapFromFileOrResourceOrString(System.String,System.Nullable{System.ValueTuple{System.Int32,System.Nullable{Au.Types.SIZE}}})">
            <summary>
            Loads GDI+ image from file, resource or string.
            </summary>
            <param name="image">
            Can be:
            - file path. Can have prefix "imagefile:".
            - resource path that starts with "resources/" or has prefix "resource:" (<see cref="M:Au.More.ResourceUtil.GetGdipBitmap(System.String)"/>)
            - Base-64 image with prefix "image:" (<see cref="M:Au.More.ImageUtil.LoadGdipBitmapFromString(System.String)"/>).
            </param>
            <param name="xaml">If not null, supports XAML images. See <see cref="M:Au.More.ImageUtil.LoadGdipBitmapFromXaml(System.String,System.Int32,System.Nullable{Au.Types.SIZE})"/>.</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Au.More.ImageUtil.LoadWpfImageFromFileOrResourceOrString(System.String)">
            <summary>
            Loads WPF image or icon from file, resource or string.
            </summary>
            <param name="image">
            Can be:
            - file path. Can have prefix "imagefile:".
            - resource path that starts with "resources/" or has prefix "resource:" (<see cref="M:Au.More.ResourceUtil.GetWpfImage(System.String)"/>)
            - Base-64 image with prefix "image:" (<see cref="M:Au.More.ImageUtil.LoadWpfImageFromString(System.String)"/>).
            </param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Au.More.ImageUtil.LoadWpfImageElementFromFileOrResourceOrString(System.String)">
            <summary>
            Loads WPF image element from file, resource or string. Supports xaml, png and other image formats supported by WPF.
            </summary>
            <param name="image">
            Can be:
            - file path; can be .xaml, .png etc; supports environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>; can have prefix "imagefile:".
            - resource path that starts with "resources/" or has prefix "resource:"; uses <see cref="M:Au.More.ResourceUtil.GetXamlObject(System.String)"/> if ends with ".xaml", else <see cref="M:Au.More.ResourceUtil.GetWpfImage(System.String)"/>.
            - Base-64 image with prefix "image:"; uses<see cref="M:Au.More.ImageUtil.LoadWpfImageFromString(System.String)"/>.
            - XAML string that starts with "&lt;".
            </param>
            <exception cref="T:System.Exception"></exception>
            <remarks>
            If <i>image</i> starts with "&lt;" or ends with ".xaml" (case-insensitive), returns object created from XAML root element. Else returns <see cref="T:System.Windows.Controls.Image"/> with <b>Source</b> = <b>BitmapFrame</b>.
            </remarks>
        </member>
        <member name="M:Au.More.ImageUtil.LoadGdipBitmapFromXaml(System.String,System.Int32,System.Nullable{Au.Types.SIZE})">
            <summary>
            Loads GDI+ image from WPF XAML file or string.
            </summary>
            <param name="image">XAML file, resource or string. See <see cref="M:Au.More.ImageUtil.LoadWpfImageElementFromFileOrResourceOrString(System.String)"/>.</param>
            <param name="dpi">DPI of window that will display the image.</param>
            <param name="size">Final image size in logical pixels (not DPI-scaled). If null, uses element's <b>DesiredSize</b> property, max 1024x1024.</param>
            <exception cref="T:System.Exception"></exception>
            <remarks>
            Calls <see cref="M:Au.More.ImageUtil.LoadWpfImageElementFromFileOrResourceOrString(System.String)"/> and <see cref="M:Au.More.ImageUtil.ConvertWpfImageElementToGdipBitmap(System.Windows.FrameworkElement,System.Int32,System.Nullable{Au.Types.SIZE})"/>.
            Don't use the <b>Tag</b> property of the bitmap. It keeps bitmap data.
            </remarks>
        </member>
        <member name="M:Au.More.ImageUtil.ConvertWpfImageElementToGdipBitmap(System.Windows.FrameworkElement,System.Int32,System.Nullable{Au.Types.SIZE})">
            <summary>
            Converts WPF image element to GDI+ image.
            </summary>
            <param name="e">For example <b>Viewbox</b>.</param>
            <param name="dpi">DPI of window that will display the image.</param>
            <param name="size">
            Final image size in logical pixels (not DPI-scaled).
            If null, uses element's <b>DesiredSize</b> property, max 1024x1024.
            If not null, sets element's <b>Width</b> and <b>Height</b>; the element should not be used in UI.
            </param>
            <remarks>
            The <b>Tag</b> property of the bitmap is array of bitmap pixels; don't replace.
            </remarks>
        </member>
        <member name="M:Au.More.ImageUtil.XamlImageToIconFile(System.IO.Stream,System.String,System.Int32[])">
            <summary>
            Converts XAML image to native icon file data.
            </summary>
            <param name="stream">Stream to write icon file data. Writes from start.</param>
            <param name="image">Image XAML. See <see cref="M:Au.More.ImageUtil.LoadWpfImageElementFromFileOrResourceOrString(System.String)"/>.</param>
            <param name="sizes">Sizes of icon images to add to the ico file. For example 16, 24, 32, 48, 64. Sizes can be 1 to 256 inclusive.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">An invalid size.</exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Au.More.ImageUtil.XamlImageToIconFile(System.String,System.String,System.Int32[])">
            
        </member>
        <member name="T:Au.More.Math2">
            <summary>
            Simple calculation functions.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MakeLparam(System.UInt32,System.UInt32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32. Returns it as nint, ready to use with Windows message API as lParam or wParam or return value.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MakeLparam(System.Int32,System.Int32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32. Returns it as nint, ready to use with Windows message API as lParam or wParam or return value.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MakeLparam(Au.Types.POINT)">
            <summary>
            Creates uint by placing (ushort)p.x in bits 1-16 and (ushort)p.y in bits 17-32. Returns it as nint, ready to use with Windows message API as lParam or wParam or return value.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MakeWord(System.UInt32,System.UInt32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MakeWord(System.Int32,System.Int32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.More.Math2.LoWord(System.IntPtr)">
            <summary>
            Gets bits 1-16 as ushort.
            Like C macro LOWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. The parameter type nint allows to avoid explicit cast from int and IntPtr (and avoid OverflowException).
            </remarks>
        </member>
        <member name="M:Au.More.Math2.HiWord(System.IntPtr)">
            <summary>
            Gets bits 17-32 as ushort.
            Like C macro HIWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. The parameter type nint allows to avoid explicit cast from int and IntPtr (and avoid OverflowException).
            </remarks>
        </member>
        <member name="M:Au.More.Math2.LoShort(System.IntPtr)">
            <summary>
            Gets bits 1-16 as short.
            Like C macro GET_X_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. The parameter type nint allows to avoid explicit cast from int and IntPtr (and avoid OverflowException).
            </remarks>
        </member>
        <member name="M:Au.More.Math2.HiShort(System.IntPtr)">
            <summary>
            Gets bits 17-32 as short.
            Like C macro GET_Y_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. The parameter type nint allows to avoid explicit cast from int and IntPtr (and avoid OverflowException).
            </remarks>
        </member>
        <member name="M:Au.More.Math2.LoByte(System.UInt16)">
            <summary>
            Gets bits 1-8 as byte.
            Like C macro LOBYTE.
            </summary>
        </member>
        <member name="M:Au.More.Math2.HiByte(System.UInt16)">
            <summary>
            Gets bits 9-16 as byte.
            Like C macro HIBYTE.
            </summary>
        </member>
        <member name="M:Au.More.Math2.NintToPOINT(System.IntPtr)">
            <summary>
            Converts <b>nint</b> containing x and y coordinates to <b>POINT</b>.
            </summary>
        </member>
        <member name="M:Au.More.Math2.MulDiv(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns <c>number * multiply / divide</c>.
            Multiplies without overflow and rounds up or down to the nearest integer.
            </summary>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.DivideByZeroException"></exception>
        </member>
        <member name="M:Au.More.Math2.PercentFromValue(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Calculates how many % of <i>whole</i> is <i>part</i>: <c>100L * part / whole</c>.
            </summary>
            <param name="whole"></param>
            <param name="part"></param>
            <param name="canRoundUp">Round down or up. If false (default), can only round down.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.More.Math2.PercentFromValue(System.Double,System.Double)">
            <summary>
            Calculates how many % of <i>whole</i> is <i>part</i>: <c>100 * part / whole</c>.
            </summary>
        </member>
        <member name="M:Au.More.Math2.PercentToValue(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns <i>percent</i> % of <i>whole</i>: <c>(long)whole * percent / 100</c>.
            </summary>
            <param name="whole"></param>
            <param name="percent"></param>
            <param name="canRoundUp">Use <see cref="M:Au.More.Math2.MulDiv(System.Int32,System.Int32,System.Int32)"/>, which can round down or up. If false (default), can only round down.</param>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:Au.More.Math2.PercentToValue(System.Double,System.Double)">
            <summary>
            Returns <i>percent</i> % of <i>whole</i>: <c>whole * percent / 100</c>.
            </summary>
        </member>
        <member name="M:Au.More.Math2.AlignUp(System.UInt32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>
            For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.
            </remarks>
        </member>
        <member name="M:Au.More.Math2.AlignUp(System.Int32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>
            For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.
            </remarks>
            <example>
            <code><![CDATA[
            for (int i = 0; i <= 20; i++) print.it(i, Math2.AlignUp(i, 4));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.Math2.Swap``1(``0@,``0@)">
            <summary>
            Swaps values of variables a and b: <c>T t = a; a = b; b = t;</c>
            </summary>
        </member>
        <member name="M:Au.More.Math2.SwapBits(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Swaps two ranges of bits.
            </summary>
            <param name="value"></param>
            <param name="i">Position of first range of bits.</param>
            <param name="j">Position of second range of bits.</param>
            <param name="n">Number of bits in each range.</param>
        </member>
        <member name="M:Au.More.Math2.SwapBits(System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Swaps two ranges of bits.
            </summary>
            <param name="value"></param>
            <param name="i">Position of first range of bits.</param>
            <param name="j">Position of second range of bits.</param>
            <param name="n">Number of bits in each range.</param>
        </member>
        <member name="M:Au.More.Math2.AngleFromXY(System.Int32,System.Int32)">
            <summary>
            Calculates angle degrees from coordinates x and y.
            </summary>
        </member>
        <member name="M:Au.More.Math2.Distance(Au.Types.POINT,Au.Types.POINT)">
            <summary>
            Calculates distance between two points.
            </summary>
        </member>
        <member name="M:Au.More.Math2.Distance(Au.Types.RECT,Au.Types.POINT)">
            <summary>
            Calculates distance between rectangle and point.
            Returns 0 if point is in rectangle.
            </summary>
        </member>
        <member name="T:Au.More.MemoryBitmap">
            <summary>
            Creates and manages native bitmap handle and memory DC (GDI device context).
            The bitmap is selected in the DC.
            </summary>
        </member>
        <member name="P:Au.More.MemoryBitmap.Hdc">
            <summary>
            DC handle.
            </summary>
        </member>
        <member name="P:Au.More.MemoryBitmap.Hbitmap">
            <summary>
            Bitmap handle.
            </summary>
        </member>
        <member name="M:Au.More.MemoryBitmap.#ctor">
            <summary>
            Does nothing. Later you can call Create or Attach.
            </summary>
        </member>
        <member name="M:Au.More.MemoryBitmap.#ctor(System.Int32,System.Int32)">
            <summary>
            Calls <see cref="M:Au.More.MemoryBitmap.Create(System.Int32,System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">width or height is less than 1.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of specified size (need with*height*4 bytes).</exception>
        </member>
        <member name="M:Au.More.MemoryBitmap.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.More.MemoryBitmap.Dispose">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.More.MemoryBitmap.Finalize">
            
        </member>
        <member name="M:Au.More.MemoryBitmap.GetHdc">
            
        </member>
        <member name="M:Au.More.MemoryBitmap.ReleaseHdc">
            
        </member>
        <member name="M:Au.More.MemoryBitmap.Delete">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.More.MemoryBitmap.Create(System.Int32,System.Int32)">
            <summary>
            Creates new memory DC and bitmap of specified size and selects it into the DC.
            Returns false if failed.
            In any case deletes previous bitmap and DC.
            </summary>
            <param name="width">Width, pixels. Must be &gt; 0.</param>
            <param name="height">Height, pixels. Must be &gt; 0.</param>
        </member>
        <member name="M:Au.More.MemoryBitmap.Attach(System.IntPtr)">
            <summary>
            Sets this variable to manage an existing bitmap.
            Selects the bitmap into a memory DC.
            Deletes previous bitmap and DC.
            </summary>
            <param name="hBitmap">Native bitmap handle.</param>
        </member>
        <member name="M:Au.More.MemoryBitmap.Detach">
            <summary>
            Deletes memory DC, clears this variable and returns its bitmap (native bitmap handle).
            The returned bitmap is not selected into a DC. Will need to delete it with API DeleteObject.
            </summary>
        </member>
        <member name="T:Au.More.MemoryUtil">
            <summary>
            Allocates memory from native heap of this process using heap API.
            Also has more functions to work with memory: copy, move, virtual alloc.
            </summary>
            <remarks>
            Uses the common heap of this process, API <msdn>GetProcessHeap</msdn>.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.Alloc(System.IntPtr,System.Boolean)">
            <summary>
            Allocates new memory block and returns its address.
            </summary>
            <param name="size">Byte count.</param>
            <param name="zeroInit">Set all bytes = 0.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>
            Calls API <msdn>HeapAlloc</msdn>.
            The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.More.MemoryUtil.Free(System.Void*)"/> when done. Call <see cref="M:Au.More.MemoryUtil.ReAlloc``1(``0*@,System.IntPtr,System.Boolean)"/> or <see cref="M:Au.More.MemoryUtil.FreeAlloc``1(``0*@,System.IntPtr,System.Boolean)"/> if need to resize.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.Alloc``1(System.IntPtr,System.Boolean)">
            <summary>
            Allocates new memory block and returns its address.
            </summary>
            <param name="count">Count of elements of type T.</param>
            <param name="zeroInit">Set all bytes = 0.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably count is too big.</exception>
            <remarks>
            Calls API <msdn>HeapAlloc</msdn>.
            The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.More.MemoryUtil.Free(System.Void*)"/> when done. Call <see cref="M:Au.More.MemoryUtil.ReAlloc``1(``0*@,System.IntPtr,System.Boolean)"/> or <see cref="M:Au.More.MemoryUtil.FreeAlloc``1(``0*@,System.IntPtr,System.Boolean)"/> if need to resize.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.ReAlloc``1(``0*@,System.IntPtr,System.Boolean)">
            <summary>
            Reallocates a memory block to make it bigger or smaller.
            </summary>
            <param name="mem">Input: old memory address; if null, allocates new memory like <see cref="M:Au.More.MemoryUtil.Alloc``1(System.IntPtr,System.Boolean)"/>. Output: new memory address. Unchanged if exception.</param>
            <param name="count">New count of elements of type T.</param>
            <param name="zeroInit">When size is growing, set all added bytes = 0.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably count is too big.</exception>
            <remarks>
            Calls API <msdn>HeapReAlloc</msdn> or <msdn>HeapAlloc</msdn>.
            Preserves data in <c>Math.Min(oldCount, newCount)</c> elements of old memory (copies from old memory if need).
            The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.More.MemoryUtil.Free(System.Void*)"/> when done. Call <b>ReAlloc</b> or <see cref="M:Au.More.MemoryUtil.FreeAlloc``1(``0*@,System.IntPtr,System.Boolean)"/> if need to resize.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.Free(System.Void*)">
            <summary>
            Frees a memory block.
            Does nothing if <i>mem</i> is null.
            </summary>
            <remarks>
            Calls API <msdn>HeapFree</msdn>.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.FreeAlloc``1(``0*@,System.IntPtr,System.Boolean)">
            <summary>
            Frees a memory block (if not null) and allocates new.
            </summary>
            <param name="mem">Input: old memory address or null. Output: new memory address; null if exception (it prevents freeing twice).</param>
            <param name="count">New count of elements of type T.</param>
            <param name="zeroInit">Set all bytes = 0.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably count is too big.</exception>
            <remarks>
            At first sets <i>mem</i> = null, to avoid double <b>Free</b> if this function throws exception. Then calls <b>Free</b> and <b>Alloc</b>.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.VirtualAlloc(System.IntPtr)">
            <summary>
            Allocates new virtual memory block with API <msdn>VirtualAlloc</msdn> and returns its address: <c>VirtualAlloc(default, size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE)</c>.
            </summary>
            <param name="size">Byte count.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>
            Faster than managed and <see cref="M:Au.More.MemoryUtil.Alloc(System.IntPtr,System.Boolean)"/> when memory size is large, more than 1 MB; else slower.
            The memory is initialized to zero (all bytes 0).
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.VirtualFree(System.Void*)">
            <summary>
            Frees a memory block allocated with <see cref="M:Au.More.MemoryUtil.VirtualAlloc(System.IntPtr)"/>.
            Does nothing if <i>mem</i> is null.
            </summary>
        </member>
        <member name="M:Au.More.MemoryUtil.Copy(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            Copies memory with <see cref="M:System.Buffer.MemoryCopy(System.Void*,System.Void*,System.Int64,System.Int64)"/>.
            </summary>
            <remarks>
            If some part of memory blocks overlaps, this function is much slower than <see cref="M:Au.More.MemoryUtil.Move(System.Void*,System.Void*,System.IntPtr)"/>. Else same speed or slightly faster.
            </remarks>
        </member>
        <member name="M:Au.More.MemoryUtil.Move(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            Copies memory with API <msdn>memmove</msdn>.
            </summary>
            <remarks>
            If some part of memory blocks overlaps, this function is much faster than <see cref="M:Au.More.MemoryUtil.Copy(System.Void*,System.Void*,System.IntPtr)"/>. Else same speed or slightly slower.
            </remarks>
        </member>
        <member name="T:Au.More.MenuItemInfo">
            <summary>
            Gets item id, text and other info of a classic menu.
            </summary>
        </member>
        <member name="M:Au.More.MenuItemInfo.FromXY(Au.Types.POINT,Au.wnd,System.Int32)">
            <summary>
            Gets info of a menu item from point.
            Returns null if fails, eg the point is not in the menu or the window is hung.
            </summary>
            <param name="pScreen">Point in screen coordinates.</param>
            <param name="w">Popup menu window, class name "#32768".</param>
            <param name="msTimeout">Timeout (ms) to use when the window is busy or hung.</param>
        </member>
        <member name="M:Au.More.MenuItemInfo.FromXY(System.Int32)">
            <summary>
            Gets info of a menu item from mouse.
            Returns null if fails, eg the point is not in a menu or the window is hung.
            </summary>
            <param name="msTimeout">Timeout (ms) to use when the window is busy or hung.</param>
        </member>
        <member name="P:Au.More.MenuItemInfo.MenuHandle">
            <summary>
            Gets the popup menu handle.
            </summary>
        </member>
        <member name="P:Au.More.MenuItemInfo.ItemId">
            <summary>
            Gets menu item id.
            </summary>
        </member>
        <member name="P:Au.More.MenuItemInfo.OwnerWindow">
            <summary>
            Gets the owner window of the popup menu.
            </summary>
        </member>
        <member name="P:Au.More.MenuItemInfo.IsSystem">
            <summary>
            true if it is a system menu, eg when right-clicked the title bar of a window.
            </summary>
        </member>
        <member name="M:Au.More.MenuItemInfo.GetText(System.Boolean,System.Boolean)">
            <summary>
            Gets menu item text.
            Returns null if failed.
            </summary>
            <param name="removeHotkey">If contains '\t' character, get substring before it.</param>
            <param name="removeAmp">Call <see cref="M:Au.More.StringUtil.RemoveUnderlineChar(System.String,System.Char)"/>.</param>
        </member>
        <member name="M:Au.More.MenuItemInfo.GetText(System.IntPtr,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets menu item text.
            Returns null if failed.
            </summary>
            <param name="menuHandle"></param>
            <param name="id"></param>
            <param name="byIndex">id is 0-based index. For example you can use it to get text of a submenu-item, because such items usually don't have id.</param>
            <param name="removeHotkey">If contains '\t' character, get substring before it.</param>
            <param name="removeAmp">Call <see cref="M:Au.More.StringUtil.RemoveUnderlineChar(System.String,System.Char)"/>.</param>
        </member>
        <member name="T:Au.More.MouseCursor">
            <summary>
            Helps to load cursors, etc. Contains native cursor handle.
            </summary>
            <remarks>
            To load cursors for winforms can be used <see cref="T:System.Windows.Forms.Cursor"/> constructors, but they don't support colors, ani cursors and custom size.
            Don't use this class to load cursors for WPF. Its <b>Cursor</b> class loads cursors correctly.
            </remarks>
        </member>
        <member name="M:Au.More.MouseCursor.#ctor(System.IntPtr)">
            <summary>
            Sets native cursor handle.
            The cursor will be destroyed when disposing this variable or when converting to object of other type.
            </summary>
        </member>
        <member name="M:Au.More.MouseCursor.Dispose">
            <summary>
            Destroys native cursor handle.
            </summary>
        </member>
        <member name="M:Au.More.MouseCursor.Finalize">
            
        </member>
        <member name="P:Au.More.MouseCursor.Handle">
            <summary>
            Gets native cursor handle.
            </summary>
        </member>
        <member name="M:Au.More.MouseCursor.Load(System.String,System.Int32)">
            <summary>
            Loads cursor from file.
            </summary>
            <returns>Returns default(MouseCursor) if failed.</returns>
            <param name="file">.cur or .ani file. If not full path, uses <see cref="P:Au.folders.ThisAppImages"/>.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI.</param>
        </member>
        <member name="M:Au.More.MouseCursor.Load(System.Byte[],System.Int32)">
            <summary>
            Creates cursor from cursor file data in memory, for example from a managed resource.
            </summary>
            <returns>Returns default(MouseCursor) if failed.</returns>
            <param name="cursorData">Data of .cur or .ani file.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI.</param>
            <remarks>
            This function creates/deletes a temporary file, because there is no good API to load cursor from memory.
            </remarks>
        </member>
        <member name="M:Au.More.MouseCursor.ToGdipCursor">
            <summary>
            Creates <see cref="T:System.Windows.Forms.Cursor"/> object that shares native cursor handle with this object.
            Returns null if <i>Handle</i> is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.More.MouseCursor.Hash(System.IntPtr)">
            <summary>
            Calculates 64-bit FNV1 hash of cursor's mask bitmap.
            Returns 0 if fails.
            </summary>
        </member>
        <member name="M:Au.More.MouseCursor.GetCurrentVisibleCursor(System.IntPtr@)">
            <summary>
            Gets current global mouse cursor.
            Returns false if cursor is hidden.
            </summary>
            <param name="cursor">Receives native handle. Don't destroy.</param>
        </member>
        <member name="M:Au.More.MouseCursor.SetArrowCursor_">
            <summary>
            Workaround for brief 'wait' cursor when mouse enters a window of current thread first time.
            Reason: default thread's cursor is 'wait'. OS shows it before the first WM_SETCURSOR sets correct cursor.
            Call eg on WM_CREATE.
            </summary>
        </member>
        <member name="T:Au.More.RecordingUtil">
            <summary>
            Functions for keyboard/mouse/etc recorder tools.
            </summary>
        </member>
        <member name="M:Au.More.RecordingUtil.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)">
            <summary>
            Converts multiple recorded mouse movements to string for <see cref="M:Au.mouse.moveRecorded(System.String,System.Double)"/>.
            </summary>
            <param name="recorded">
            List of x y distances from previous.
            The first distance is from mouse position before the first movement; at run time it will be distance from <see cref="P:Au.mouse.lastXY"/>.
            To create uint value from distance dx dy use <see cref="M:Au.More.Math2.MakeLparam(System.UInt32,System.UInt32)"/> and cast to uint.
            </param>
            <param name="withSleepTimes">
            <i>recorded</i> also contains sleep times (milliseconds) alternating with distances.
            It must start with a sleep time. Example: {time1, dist1, time2, dist2}. Another example: {time1, dist1, time2, dist2, time3}. This is invalid: {dist1, time1, dist2, time2}.
            </param>
        </member>
        <member name="T:Au.More.ResourceUtil">
            <summary>
            Gets managed resources from a .NET assembly.
            </summary>
            <remarks>
            Internally uses <see cref="T:System.Resources.ResourceManager"/>. Uses <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            Loads resources from manifest resource "AssemblyName.g.resources". To add such resource files in Visual Studio, set file build action = Resource. Don't use .resx files and the Resources page in Project Properties.
            By default loads resources from the app entry assembly. In script with role miniProgram - from the script's assembly. To specify other loaded assembly, use name like "&lt;AssemblyName&gt;file.txt".
            Does not use caching. Creates new object even when loading the resource not the first time.
            </remarks>
        </member>
        <member name="M:Au.More.ResourceUtil.Get``1(System.String)">
            <summary>
            Gets resource of any type.
            </summary>
            <param name="name">Can be resource name like "file.txt" or "sub/file.txt" or "&lt;LoadedAssemblyName&gt;file.txt". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource is of different type. This function does not convert.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
        </member>
        <member name="M:Au.More.ResourceUtil.GetStream(System.String)">
            <summary>
            Gets stream.
            </summary>
            <param name="name">Can be resource name like "file.png" or "sub/file.png" or "&lt;LoadedAssemblyName&gt;file.png". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource type is not stream.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
            <remarks>
            Don't need to dispose the stream.
            </remarks>
        </member>
        <member name="M:Au.More.ResourceUtil.GetString(System.String)">
            <summary>
            Gets string.
            </summary>
            <param name="name">Can be resource name like "myString" or "file.txt" or "sub/file.txt" or "&lt;LoadedAssemblyName&gt;file.txt". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">Unsupported resource type.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
            <remarks>
            Supports resources of type string, byte[] (UTF-8), stream (UTF-8).
            </remarks>
        </member>
        <member name="M:Au.More.ResourceUtil.GetBytes(System.String)">
            <summary>
            Gets byte[].
            </summary>
            <param name="name">Can be resource name like "file.txt" or "sub/file.txt" or "&lt;LoadedAssemblyName&gt;file.txt". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">Unsupported resource type.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
            <remarks>
            Supports resources of type byte[], string (gets UTF-8 bytes), stream.
            </remarks>
        </member>
        <member name="M:Au.More.ResourceUtil.GetGdipBitmap(System.String)">
            <summary>
            Gets GDI+ image.
            </summary>
            <param name="name">Can be resource name like "file.png" or "sub/file.png" or "&lt;LoadedAssemblyName&gt;file.png". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource type is not stream.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
        </member>
        <member name="M:Au.More.ResourceUtil.GetWpfImage(System.String)">
            <summary>
            Gets WPF image or icon that can be used as <b>ImageSource</b>.
            </summary>
            <param name="name">Can be resource name like "file.png" or "sub/file.png" or "&lt;LoadedAssemblyName&gt;file.png". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource type is not stream.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
        </member>
        <member name="M:Au.More.ResourceUtil.GetXamlObject(System.String)">
            <summary>
            Gets WPF object from XAML resource, for example image.
            Returns object of type of the XAML root object, for example Viewbox if image.
            </summary>
            <param name="name">Can be resource name like "file.xaml" or "sub/file.xaml" or "&lt;LoadedAssemblyName&gt;file.xaml". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource type is not stream.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
        </member>
        <member name="M:Au.More.ResourceUtil.GetWpfImageElement(System.String)">
            <summary>
            Gets WPF image element from xaml or other image resource.
            </summary>
            <param name="name">Can be resource name like "file.png" or "sub/file.xaml" or "&lt;LoadedAssemblyName&gt;file.png". Can have prefix "resource:".</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find assembly or resource.</exception>
            <exception cref="T:System.InvalidOperationException">The resource type is not stream.</exception>
            <exception cref="T:System.Exception">Other exceptions that may be thrown by used .NET functions.</exception>
            <remarks>
            If <i>name</i> ends with ".xaml" (case-insensitive), calls <see cref="M:Au.More.ResourceUtil.GetXamlObject(System.String)"/>. Else returns <see cref="T:System.Windows.Controls.Image"/> with <b>Source</b> = <see cref="M:Au.More.ResourceUtil.GetWpfImage(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.More.ResourceUtil.HasResourcePrefix(System.String)">
            <summary>
            Returns true if string starts with "resource:" or "resources/".
            </summary>
        </member>
        <member name="T:Au.More.SecurityUtil">
            <summary>
            Security-related functions, such as enabling privileges.
            </summary>
        </member>
        <member name="M:Au.More.SecurityUtil.SetPrivilege(System.String,System.Boolean)">
            <summary>
            Enables or disables a privilege for this process.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="privilegeName"></param>
            <param name="enable"></param>
        </member>
        <member name="T:Au.More.TreeBase`1">
            <summary>
            Base class for tree classes.
            The tree can be loaded/saved as XML.
            </summary>
            <remarks>
            Implemented in the same way as <see cref="T:System.Xml.Linq.XContainer"/>.
            </remarks>
            <example>
            Shows how to declare a <b>TreeBase</b>-derived class, load tree of nodes from an XML file, find descendant nodes, save the tree to an XML file.
            <code><![CDATA[
            using System.Xml;
            
            class MyTree : Au.More.TreeBase<MyTree>
            {
            	public string Name { get; set; }
            	public int Id { get; private set; }
            	public bool IsFolder { get; private set; }
            
            	public MyTree(string name, int id, bool isFolder) { Name = name; Id = id; IsFolder = isFolder; }
            
            	//XML element -> MyTree object
            	MyTree(XmlReader x, MyTree parent)
            	{
            		if(parent == null) { //the root XML element
            			if(x.Name != "example") throw new ArgumentException("XML root element must be 'example'");
            			IsFolder = true;
            		} else {
            			switch(x.Name) {
            			case "e": break;
            			case "f": IsFolder = true; break;
            			default: throw new ArgumentException("XML element must be 'e' or 'f'");
            			}
            #if true //two ways of reading attributes
            			Name = x["name"];
            			Id = x["id"].ToInt();
            #else
            			while(x.MoveToNextAttribute()) {
            				var v = x.Value;
            				switch(x.Name) {
            				case "name": Name = v; break;
            				case "id": Id = v.ToInt(); break;
            				}
            			}
            #endif
            			if(Name.NE()) throw new ArgumentException("no 'name' attribute in XML");
            			if(Id == 0) throw new ArgumentException("no 'id' attribute in XML");
            		}
            	}
            
            	public static MyTree Load(string file) => XmlLoad(file, (x, p) => new MyTree(x, p));
            
            	public void Save(string file) => XmlSave(file, (x, n) => n._XmlWrite(x));
            
            	//MyTree object -> XML element
            	void _XmlWrite(XmlWriter x)
            	{
            		if(Parent == null) {
            			x.WriteStartElement("example");
            		} else {
            			x.WriteStartElement(IsFolder ? "f" : "e");
            			x.WriteAttributeString("name", Name);
            			x.WriteAttributeString("id", Id.ToString());
            		}
            	}
            
            	public override string ToString() => $"{new string(' ', Level)}{(IsFolder ? 'f' : 'e')} {Name} ({Id})";
            }
            
            static void TNodeExample()
            {
            	/*
            	<example>
            	  <e name="one" id="1" />
            	  <f name="two" id="112">
            		<e name="three" id="113" />
            		<e name="four" id="114" />
            		<f name="five" id="120">
            		  <e name="six" id="121" />
            		  <e name="seven" id="122" />
            		</f>
            	  </f>
            	  <f name="eight" id="217" />
            	  <e name="ten" id="144" />
            	</example>
            	*/
            
            	var x = MyTree.Load(@"Q:\test\example.xml");
            	foreach(MyTree n in x.Descendants(true)) print.it(n);
            	//print.it(x.Descendants().FirstOrDefault(k => k.Name == "seven")); //find a descendant
            	//print.it(x.Descendants().Where(k => k.Level > 2)); //find some descendants
            	x.Save(@"Q:\test\example2.xml");
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.More.TreeBase`1.Parent">
            <summary>
            Returns the parent node. Can be null.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.RootAncestor">
            <summary>
            Returns the root ancestor node. Its <see cref="P:Au.More.TreeBase`1.Parent"/> is null.
            Returns this node if its <b>Parent</b> is null.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.Level">
            <summary>
            Gets the number of ancestors (parent, its parent and so on).
            </summary>
        </member>
        <member name="M:Au.More.TreeBase`1.IsDescendantOf(`0)">
            <summary>
            Returns true if this node is a descendant of node n.
            </summary>
            <param name="n">Can be null.</param>
        </member>
        <member name="M:Au.More.TreeBase`1.IsAncestorOf(`0)">
            <summary>
            Returns true if this node is an ancestor of node n.
            </summary>
            <param name="n">Can be null.</param>
        </member>
        <member name="P:Au.More.TreeBase`1.HasParent">
            <summary>
            Returns true if <see cref="P:Au.More.TreeBase`1.Parent"/> is not null.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.HasChildren">
            <summary>
            Returns true if this node has child nodes.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.LastChild">
            <summary>
            Gets the last child node, or null if none.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.FirstChild">
            <summary>
            Gets the first child node, or null if none.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.Next">
            <summary>
            Gets next sibling node, or null if none.
            </summary>
        </member>
        <member name="P:Au.More.TreeBase`1.Previous">
            <summary>
            Gets previous sibling node, or null if none.
            </summary>
            <remarks>
            Can be slow if there are many siblings. This class does not have a 'previous' field and therefore has to walk the linked list of siblings.
            </remarks>
        </member>
        <member name="P:Au.More.TreeBase`1.Index">
            <summary>
            Returns 0-based index of this node in parent.
            Returns -1 if no parent.
            </summary>
            <remarks>
            Can be slow if there are many siblings. This class does not have an 'index' field and therefore has to walk the linked list of siblings.
            </remarks>
        </member>
        <member name="M:Au.More.TreeBase`1.AddChild(`0,System.Boolean)">
            <summary>
            Adds node n to this node as a child.
            </summary>
            <param name="n"></param>
            <param name="first">Insert n as the first child node. If false (default), appends to the end.</param>
            <exception cref="T:System.ArgumentException">n is null, or has parent (need to <see cref="M:Au.More.TreeBase`1.Remove"/> at first), or is this node, or an ancestor of this node.</exception>
        </member>
        <member name="M:Au.More.TreeBase`1.AddSibling(`0,System.Boolean)">
            <summary>
            Inserts node n before or after this node as a sibling.
            </summary>
            <param name="n"></param>
            <param name="after">Insert n after this node. If false (default), inserts before this node.</param>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.More.TreeBase`1.AddChild(`0,System.Boolean)"/>.</exception>
            <exception cref="T:System.InvalidOperationException">This node does not have parent (<see cref="P:Au.More.TreeBase`1.Parent"/> is null).</exception>
        </member>
        <member name="M:Au.More.TreeBase`1.Remove">
            <summary>
            Removes this node from its parent.
            </summary>
            <remarks>
            After removing, the <see cref="P:Au.More.TreeBase`1.Parent"/> property is null.
            Does nothing if <b>Parent</b> is null.
            </remarks>
        </member>
        <member name="M:Au.More.TreeBase`1.Ancestors(System.Boolean,System.Boolean)">
            <summary>
            Gets ancestor nodes (parent, its parent and so on).
            The order is from <see cref="P:Au.More.TreeBase`1.Parent"/> to <see cref="P:Au.More.TreeBase`1.RootAncestor"/>.
            </summary>
            <param name="andSelf">Include this node.</param>
            <param name="noRoot">Don't include <see cref="P:Au.More.TreeBase`1.RootAncestor"/>.</param>
        </member>
        <member name="M:Au.More.TreeBase`1.AncestorsReverse(System.Boolean,System.Boolean)">
            <summary>
            Gets ancestor nodes in reverse order than <see cref="M:Au.More.TreeBase`1.Ancestors(System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
            <param name="noRoot">Don't include <see cref="P:Au.More.TreeBase`1.RootAncestor"/>.</param>
        </member>
        <member name="M:Au.More.TreeBase`1.Children(System.Boolean)">
            <summary>
            Gets all direct child nodes.
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
        </member>
        <member name="P:Au.More.TreeBase`1.Count">
            <summary>
            Gets number of direct child nodes.
            </summary>
        </member>
        <member name="M:Au.More.TreeBase`1.Descendants(System.Boolean)">
            <summary>
            Gets all descendant nodes (direct children, their children and so on).
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
        </member>
        <member name="T:Au.More.TreeBase`1.XmlNodeReader">
            <summary>
            Used with <see cref="M:Au.More.TreeBase`1.XmlLoad(System.String,Au.More.TreeBase{`0}.XmlNodeReader)"/>
            </summary>
        </member>
        <member name="T:Au.More.TreeBase`1.XmlNodeWriter">
            <summary>
            Used with <see cref="M:Au.More.TreeBase`1.XmlSave(System.String,Au.More.TreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:Au.More.TreeBase`1.XmlLoad(System.String,Au.More.TreeBase{`0}.XmlNodeReader)">
            <summary>
            Loads XML file and creates tree of nodes from it.
            Returns the root node.
            </summary>
            <param name="file">XML file. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <param name="nodeReader">Callback function that reads current XML element and creates/returns new node. See example.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.XmlReader.Create(System.String)"/>.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <example><see cref="T:Au.More.TreeBase`1"/></example>
        </member>
        <member name="M:Au.More.TreeBase`1.XmlLoad(System.Xml.XmlReader,Au.More.TreeBase{`0}.XmlNodeReader)">
            <summary>
            Reads XML and creates tree of nodes.
            Returns the root node.
            </summary>
            <param name="x"></param>
            <param name="nodeReader"></param>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <remarks>More info: <see cref="M:Au.More.TreeBase`1.XmlLoad(System.String,Au.More.TreeBase{`0}.XmlNodeReader)"/>.</remarks>
            <example><see cref="T:Au.More.TreeBase`1"/></example>
        </member>
        <member name="M:Au.More.TreeBase`1.XmlSave(System.String,Au.More.TreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Saves tree of nodes (this and descendants) to an XML file.
            </summary>
            <param name="file">XML file. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <param name="nodeWriter">Callback function that writes node's XML start element (see <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/>) and attributes (see <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String)"/>). Must not write children and end element. Also should not write value, unless your reader knows how to read it.</param>
            <param name="sett">XML formatting settings. Optional.</param>
            <param name="children">If not null, writes these nodes as if they were children of this node.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.XmlWriter.Create(System.String)"/> and other <b>XmlWriter</b> methods.</exception>
            <remarks>
            Uses <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>. It ensures that existing file data is not damaged on exception etc.
            </remarks>
            <example><see cref="T:Au.More.TreeBase`1"/></example>
        </member>
        <member name="M:Au.More.TreeBase`1.XmlSave(System.Xml.XmlWriter,Au.More.TreeBase{`0}.XmlNodeWriter,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Writes tree of nodes (this and descendants) to an <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="x"></param>
            <param name="nodeWriter"></param>
            <param name="children"></param>
            <remarks>More info: <see cref="M:Au.More.TreeBase`1.XmlSave(System.String,Au.More.TreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})"/>.</remarks>
            <exception cref="T:System.Exception">Exceptions of <b>XmlWriter</b> methods.</exception>
            <example><see cref="T:Au.More.TreeBase`1"/></example>
        </member>
        <member name="T:Au.More.WaitableTimer">
            <summary>
            Wraps a waitable timer handle.
            </summary>
            <remarks>
            More info: API <msdn>CreateWaitableTimer</msdn>.
            </remarks>
        </member>
        <member name="M:Au.More.WaitableTimer.Create(System.Boolean,System.String)">
            <summary>
            Calls API <msdn>CreateWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="manualReset"></param>
            <param name="timerName">Timer name. If a timer with this name already exists, opens it if possible. If null, creates unnamed timer.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
        </member>
        <member name="M:Au.More.WaitableTimer.Open(System.String,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Calls API <msdn>OpenWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="timerName">Timer name. Fails if it does not exist; to open-or-create use <see cref="M:Au.More.WaitableTimer.Create(System.Boolean,System.String)"/>.</param>
            <param name="access">.See <msdn>Synchronization Object Security and Access Rights</msdn>. The default value TIMER_MODIFY_STATE|SYNCHRONIZE allows to set and wait.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
            <param name="inheritHandle"></param>
            <param name="noException">If fails, return null, don't throw exception. Supports <see cref="T:Au.lastError"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the timer does not exist.</exception>
        </member>
        <member name="M:Au.More.WaitableTimer.Set(System.Int64,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="dueTime">
            The time after which the state of the timer is to be set to signaled. It is relative time (from now).
            If positive, in milliseconds. If negative, in 100 nanosecond intervals (microseconds*10), see <msdn>FILETIME</msdn>.
            Also can be 0, to set minimal time.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
            <exception cref="T:System.OverflowException">dueTime*10000 is greater than long.MaxValue.</exception>
        </member>
        <member name="M:Au.More.WaitableTimer.SetAbsolute(System.DateTime,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="dueTime">The UTC date/time at which the state of the timer is to be set to signaled.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
        </member>
        <member name="T:Au.More.WindowsHook">
            <summary>
            Wraps API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <remarks>
            Hooks are used to receive notifications about various system events. Keyboard and mouse input, window messages, various window events.
            
            Threads that use hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.opt.wait"/>).
            
            <note type="important">The variable should be disposed when don't need, or at least unhooked, either explicitly (call <b>Dispose</b> or <b>Unhook</b> in same thread) or with 'using' pattern. Can do it in hook procedure.</note>
            
            <note type="warning">Avoid many hooks. Each low-level keyboard or mouse hook makes the computer slower, even if the hook procedure is fast. On each input event (key down, key up, mouse move, click, wheel) Windows sends a message to your thread.</note>
            
            To receive hook events is used a callback function, aka hook procedure. Hook procedures of some hook types can block some events (call <b>BlockEvent</b> or return true). Blocked events are not sent to apps and older hooks.
            
            Delegates of hook procedures are protected from GC until called <b>Dispose</b> or until the thread ends, even of unreferenced <b>WindowsHook</b> variables.
            
            UI element functions may fail in hook procedures of low-level keyboard and mouse hooks. Workarounds exist.
            
            Exists an alternative way to monitor keyboard or mouse events - raw input API. Good: less overhead; can detect from which device the input event came. Bad: cannot block events; incompatible with low-level keyboard hooks. This library does not have functions to make the API easier to use.
            </remarks>
        </member>
        <member name="M:Au.More.WindowsHook.Keyboard(System.Action{Au.Types.HookData.Keyboard},System.Boolean,System.Boolean)">
            <summary>
            Sets a low-level keyboard hook (WH_KEYBOARD_LL).
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible. More info: <see cref="P:Au.More.WindowsHook.LowLevelHooksTimeout"/>.
            If calls <see cref="M:Au.Types.HookData.Keyboard.BlockEvent"/> or <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>(true), the event is not sent to apps and other hooks.
            Event data cannot be modified.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not whole variable.</note>
            </param>
            <param name="ignoreAuInjected">Don't call the hook procedure for events sent by functions of this library. Default true.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            var stop = false;
            using var hook = WindowsHook.Keyboard(x => {
            	print.it(x);
            	if(x.vkCode == KKey.Escape) { stop = true; x.BlockEvent(); }
            });
            dialog.show("hook");
            //or
            //wait.forMessagesAndCondition(-10, () => stop); //wait max 10 s for Esc key
            //print.it("the end");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.Mouse(System.Action{Au.Types.HookData.Mouse},System.Boolean,System.Boolean)">
            <summary>
            Sets a low-level mouse hook (WH_MOUSE_LL).
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible. More info: <see cref="P:Au.More.WindowsHook.LowLevelHooksTimeout"/>.
            If calls <see cref="M:Au.Types.HookData.Mouse.BlockEvent"/> or <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>(true), the event is not sent to apps and other hooks.
            Event data cannot be modified.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not whole variable.</note>
            </param>
            <param name="ignoreAuInjected">Don't call the hook procedure for events sent by functions of this library. Default true.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            var stop = false;
            using var hook = WindowsHook.Mouse(x => {
            	print.it(x);
            	if(x.Event == HookData.MouseEvent.RightButton) { stop = x.IsButtonUp; x.BlockEvent(); }
            });
            dialog.show("hook");
            //or
            //wait.forMessagesAndCondition(-10, () => stop); //wait max 10 s for right-click
            //print.it("the end");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CBT hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            Hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled. For some events you can modify some fields of event data.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not the variable.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using var hook = WindowsHook.ThreadCbt(x => {
            	print.it(x.code);
            	switch(x.code) {
            	case HookData.CbtEvent.ACTIVATE:
            		print.it(x.Hwnd);
            		break;
            	case HookData.CbtEvent.CREATEWND:
            		var c=x.CreationInfo->lpcs;
            		print.it(x.Hwnd, c->x, c->lpszName);
            		c->x=500;
            		break;
            	}
            	return false;
            });
            dialog.showOkCancel("hook");
            //new Form().ShowDialog(); //to test MINMAX
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_GETMESSAGE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled. As a workaround, you can set msg->message=0. Also can modify other fields.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using var hook = WindowsHook.ThreadGetMessage(x => {
            	print.it(x.msg->ToString(), x.PM_NOREMOVE);
            });
            dialog.show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_GETMESSAGE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using var hook = WindowsHook.ThreadKeyboard(x => {
            	print.it(x.key, 0 != (x.lParam & 0x80000000) ? "up" : "", x.lParam, x.PM_NOREMOVE);
            	return false;
            });
            dialog.show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_MOUSE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using var hook = WindowsHook.ThreadMouse(x => {
            	print.it(x.message, x.m->pt, x.m->hwnd, x.PM_NOREMOVE);
            	return false;
            });
            dialog.show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CALLWNDPROC hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using var hook = WindowsHook.ThreadCallWndProc(x => {
            	ref var m = ref *x.msg;
            	wnd.more.printMsg(out var s, m.hwnd, m.message, m.wParam, m.lParam);
            	print.it(s, x.sentByOtherThread);
            });
            dialog.show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CALLWNDPROCRET hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.More.WindowsHook"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <see cref="M:Au.More.WindowsHook.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32,System.Boolean)"/>
            </example>
        </member>
        <member name="M:Au.More.WindowsHook.Hook(System.Int32)">
            <summary>
            Sets the hook.
            </summary>
            <param name="threadId">If the hook type is a thread hook - thread id, or 0 for current thread. Else not used and must be 0.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:System.InvalidOperationException">The hook is already set.</exception>
            <exception cref="T:System.ArgumentException">threadId not 0 and the hook type is not a thread hook.</exception>
            <remarks>
            Usually don't need to call this function, because the <b>WindowsHook</b> static methods that return a new <b>WindowsHook</b> object by default call it.
            </remarks>
        </member>
        <member name="M:Au.More.WindowsHook.Unhook">
            <summary>
            Removes the hook.
            </summary>
            <remarks>
            Does nothing if already removed or wasn't set.
            Later you can call <see cref="M:Au.More.WindowsHook.Hook(System.Int32)"/> to set hook again.
            Note: call <see cref="M:Au.More.WindowsHook.Dispose"/> instead if will not need to hook again.
            </remarks>
        </member>
        <member name="P:Au.More.WindowsHook.IsSet">
            <summary>
            Returns true if the hook is set.
            </summary>
        </member>
        <member name="M:Au.More.WindowsHook.Dispose">
            <summary>
            Calls <see cref="M:Au.More.WindowsHook.Unhook"/> and disposes this object.
            </summary>
        </member>
        <member name="M:Au.More.WindowsHook.Finalize">
            <summary>
            Writes warning if the variable is not disposed. Cannot dispose in finalizer.
            </summary>
        </member>
        <member name="P:Au.More.WindowsHook.LowLevelHooksTimeout">
            <summary>
            Gets the max time in milliseconds allowed by Windows for low-level keyboard and mouse hook procedures.
            </summary>
            <remarks>
            Gets registry value HKEY_CURRENT_USER\Control Panel\Desktop:LowLevelHooksTimeout. If it is missing, returns 300; it is the default value used by Windows. If greater than 1000, returns 1000, because Windows 10 ignores bigger values.
            
            If a hook procedure takes more time, Windows does not wait. Then its return value is ignored, and the event is passed to other apps, hooks, etc. After several such cases Windows may fully or partially disable the hook. This class detects such cases; then restores the hook and writes a warning to the output. If the warning is rare, you can ignore it. If frequent, it means your hook procedure is too slow.
            
            Callback functions of keyboard and mouse triggers are called in a hook procedure, therefore must be as fast as possible. More info: <see cref="T:Au.Triggers.TriggerFuncs"/>.
            
            More info: <msdn>registry LowLevelHooksTimeout</msdn>.
            
            Note: After changing the timeout in registry, it is not applied immediately. Need to log off/on.
            </remarks>
        </member>
        <member name="M:Au.More.WindowsHook.IgnoreModInOtherHooks_(System.Int64)">
            <summary>
            Let other hooks (in all processes) ignore modifier keys for timeMS milliseconds. If 0 - restore.
            Used by mouse triggers.
            Returns the timeout time (Environment.TickCount64 + timeMS) or 0.
            </summary>
        </member>
        <member name="M:Au.More.WindowsHook.IgnoreLShiftCaps_(System.Int64)">
            <summary>
            Let all hooks (in all processes) ignore LShift and CapsLock for timeMS milliseconds. If 0 - restore.
            Returns the timeout time (Environment.TickCount64 + timeMS) or 0.
            Used when turning off CapsLock with Shift.
            </summary>
        </member>
        <member name="T:Au.More.WinEventHook">
            <summary>
            Helps with UI element event hooks. See API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The thread that uses hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.opt.wait"/>).
            
            <note type="important">The variable should be disposed when don't need, or at least unhooked, either explicitly (call <b>Dispose</b> or <b>Unhook</b> in same thread) or with 'using' pattern. Can do it in hook procedure.</note>
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            using var hook = new WinEventHook(EEvent.SYSTEM_FOREGROUND, 0, x => {
            	print.it(x.w);
            	var e = x.GetElm();
            	print.it(e);
            	if(x.w.ClassNameIs("Shell_TrayWnd")) stop = true;
            });
            dialog.show("hook");
            //or
            //wait.forMessagesAndCondition(-10, () => stop); //wait max 10 s for activated taskbar
            //print.it("the end");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.More.WinEventHook.#ctor(Au.Types.EEvent,Au.Types.EEvent,System.Action{Au.Types.HookData.WinEvent},System.Int32,System.Int32,Au.Types.EHookFlags)">
            <summary>
            Sets a hook for an event or a range of events.
            </summary>
            <param name="eventMin">The lowest event constant value in the range of events. Can be EEvent.MIN to indicate the lowest possible event value. Events reference: <msdn>SetWinEventHook</msdn>. Value 0 is ignored.</param>
            <param name="eventMax">The highest event constant value in the range of events. Can be EEvent.MAX to indicate the highest possible event value. If 0, uses <i>eventMin</i>.</param>
            <param name="hookProc">The hook procedure (function that handles hook events).</param>
            <param name="idProcess">The id of the process from which the hook function receives events. If 0 - all processes on the current desktop.</param>
            <param name="idThread">The native id of the thread from which the hook function receives events. If 0 - all threads.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>See <see cref="T:Au.More.WinEventHook"/>.</example>
        </member>
        <member name="M:Au.More.WinEventHook.#ctor(Au.Types.EEvent[],System.Action{Au.Types.HookData.WinEvent},System.Int32,System.Int32,Au.Types.EHookFlags)">
            <summary>
            Sets multiple hooks.
            </summary>
            <param name="events">Events. Reference: API <msdn>SetWinEventHook</msdn>. Elements with value 0 are ignored.</param>
            <param name="hookProc">The hook procedure (function that receives hook events).</param>
            <param name="idProcess">The id of the process from which the hook function receives events. If 0 - all processes on the current desktop.</param>
            <param name="idThread">The native id of the thread from which the hook function receives events. If 0 - all threads.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>See <see cref="T:Au.More.WinEventHook"/>.</example>
        </member>
        <member name="M:Au.More.WinEventHook.Hook(Au.Types.EEvent,Au.Types.EEvent,System.Int32,System.Int32,Au.Types.EHookFlags)">
            <summary>
            Sets a hook for an event or a range of events.
            </summary>
            <exception cref="T:System.InvalidOperationException">Hooks are already set and <see cref="M:Au.More.WinEventHook.Unhook"/> not called.</exception>
            <remarks>
            Parameters are the same as of the constructor, but values can be different.
            </remarks>
        </member>
        <member name="M:Au.More.WinEventHook.Hook(Au.Types.EEvent[],System.Int32,System.Int32,Au.Types.EHookFlags)">
            <summary>
            Sets multiple hooks.
            </summary>
            <exception cref="T:System.InvalidOperationException">Hooks are already set and <see cref="M:Au.More.WinEventHook.Unhook"/> not called.</exception>
            <remarks>
            Parameters are the same as of the constructor, but values can be different.
            </remarks>
        </member>
        <member name="M:Au.More.WinEventHook.Add(Au.Types.EEvent,Au.Types.EEvent,System.Int32,System.Int32,Au.Types.EHookFlags)">
            <summary>
            Adds a hook for an event or a range of events.
            Returns an int value greater than 0 that can be used with <see cref="M:Au.More.WinEventHook.Remove(System.Int32)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Parameters are the same as of the constructor, but values can be different.
            
            This function together with <see cref="M:Au.More.WinEventHook.Remove(System.Int32)"/> can be used to temporarily add/remove one or more hooks while using the same <b>WinEventHook</b> variable and hook procedure. Don't need to call <b>Unhook</b> before.
            </remarks>
        </member>
        <member name="M:Au.More.WinEventHook.Remove(System.Int32)">
            <summary>
            Removes a hook added by <see cref="M:Au.More.WinEventHook.Add(Au.Types.EEvent,Au.Types.EEvent,System.Int32,System.Int32,Au.Types.EHookFlags)"/>.
            </summary>
            <param name="addedId">A return value of <see cref="M:Au.More.WinEventHook.Add(Au.Types.EEvent,Au.Types.EEvent,System.Int32,System.Int32,Au.Types.EHookFlags)"/>.</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.More.WinEventHook.Unhook">
            <summary>
            Removes all hooks.
            </summary>
            <remarks>
            Does nothing if already removed or wasn't set.
            Must be called from the same thread that sets the hook.
            </remarks>
        </member>
        <member name="M:Au.More.WinEventHook.Dispose">
            <summary>
            Calls <see cref="M:Au.More.WinEventHook.Unhook"/>.
            </summary>
        </member>
        <member name="M:Au.More.WinEventHook.Finalize">
            <summary>
            Writes warning if the variable is not disposed. Cannot dispose in finalizer.
            </summary>
        </member>
        <member name="T:Au.More.WinformsControlNames">
            <summary>
            Gets programming names of .NET Windows Forms controls.
            </summary>
            <remarks>
            Usually each control has a unique name. It's the Control.Name property. Useful to identify controls without a classic name/text.
            The control id of these controls is not useful, it is not constant.
            </remarks>
        </member>
        <member name="M:Au.More.WinformsControlNames.Dispose">
            
        </member>
        <member name="M:Au.More.WinformsControlNames.#ctor(Au.wnd)">
            <summary>
            Prepares to get control names.
            </summary>
            <param name="w">Any top-level or child window of that process.</param>
            <exception cref="T:Au.Types.AuWndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to allocate process memory (see <see cref="T:Au.More.ProcessMemory"/>) needed to get control names, usually because of [](xref:uac).</exception>
        </member>
        <member name="M:Au.More.WinformsControlNames.GetControlName(Au.wnd)">
            <summary>
            Gets control name.
            Returns null if fails or the name is empty.
            </summary>
            <param name="c">The control. Can be a top-level window too. Must be of the same process as the window specified in the constructor.</param>
        </member>
        <member name="M:Au.More.WinformsControlNames.IsWinformsControl(Au.wnd)">
            <summary>
            Returns true if window class name starts with "WindowsForms".
            Usually it means that we can get Windows Forms control name of w and its child controls.
            </summary>
            <param name="w">The window. Can be top-level or control.</param>
        </member>
        <member name="M:Au.More.WinformsControlNames.GetSingleControlName(Au.wnd)">
            <summary>
            Gets the programming name of a Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <param name="c">The control. Can be top-level window too.</param>
            <remarks>This function is easy to use and does not throw excaptions. However, when you need names of multiple controls of a single window, better create a WinformsControlNames instance (once) and for each control call its GetControlNameOrText method, it will be faster.</remarks>
        </member>
        <member name="T:Au.More.SegParser">
            <summary>
            Splits a string into substrings as start/end offsets or strings.
            </summary>
            <remarks>
            Can be used with foreach. Normally you don't create <b>SegParser</b> instances explicitly; instead use <see cref="M:Au.ExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/> with foreach.
            </remarks>
        </member>
        <member name="M:Au.More.SegParser.#ctor(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})">
            <summary>
            Initializes this instance to split a string.
            </summary>
            <param name="s">The string.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.SegSep"/> constants.</param>
            <param name="flags"></param>
            <param name="range">Part of the string to split.</param>
        </member>
        <member name="M:Au.More.SegParser.ToStringArray(System.Int32)">
            <summary>
            Returns segment values as string[].
            </summary>
            <param name="maxCount">The maximal number of substrings to get. If negative (default), gets all. Else if there are more substrings, the last element will contain single substring, unlike with <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/>.</param>
        </member>
        <member name="T:Au.More.StringUtil">
            <summary>
            Miscellaneous rarely used string functions. Parsing etc.
            </summary>
        </member>
        <member name="M:Au.More.StringUtil.ParseParam3Stars(System.String@,System.String[])">
            <summary>
            Parses a function parameter that can optionally have a "***name " prefix, like "***id 100".
            Returns: 0 - s does not start with "***"; i+1 - s starts with "***names[i] "; -1 - s is invalid.
            </summary>
            <param name="s">Parameter. If starts with "***" and is valid, receives the 'value' part; else unchanged. Can be null.</param>
            <param name="names">List of supported 'name'.</param>
            <remarks>
            Used to parse parameters like <i>name</i> of <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.More.StringUtil.RemoveUnderlineChar(System.String,System.Char)">
            <summary>
            Removes characters used to underline next character when the text is displayed in UI. Replaces two such caracters with single.
            </summary>
            <param name="s">Can be null.</param>
            <param name="underlineChar"></param>
            <remarks>
            Character '&amp;' (in WPF '_') is used to underline next character in displayed text of dialog controls and menu items. Two such characters are used to display single.
            The underline is displayed when using the keyboard with Alt key to select dialog controls and menu items.
            </remarks>
        </member>
        <member name="M:Au.More.StringUtil.FindUnderlineChar(System.String,System.Char)">
            <summary>
            Finds character used to underline next character when the text is displayed in UI.
            Returns its index, or -1 if not found.
            </summary>
            <param name="s">Can be null.</param>
            <param name="underlineChar"></param>
        </member>
        <member name="M:Au.More.StringUtil.CommandLineFromArray(System.String[])">
            <summary>
            Converts array of command line arguments to string that can be passed to a "start process" function, for example <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>, <see cref="M:System.Diagnostics.Process.Start"/>.
            Returns null if a is null or has 0 elements.
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:Au.More.StringUtil.CommandLineToArray(System.String)">
            <summary>
            Parses command line arguments.
            Calls API <msdn>CommandLineToArgvW</msdn>.
            Returns empty array if s is null or "".
            </summary>
        </member>
        <member name="M:Au.More.StringUtil.ParseIntAndString(System.String,System.Int32@,System.String@,System.Int32,Au.Types.STIFlags)">
            <summary>
            If string contains a number at startIndex, gets that number as int, also gets the string part that follows it, and returns true.
            For example, for string "25text" or "25 text" gets num = 25, tail = "text".
            Everything else is the same as with <see cref="M:Au.ExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/>.
            </summary>
            <param name="s"></param>
            <param name="num">Receives the number. Receives 0 if no number.</param>
            <param name="tail">Receives the string part that follows the number, or "". Receives null if no number. Can be this variable.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.More.StringUtil.StringToIntArray(System.String)">
            <summary>
            Creates int[] from string containing space-separated numbers, like "4 100 -8 0x10".
            </summary>
            <param name="s">Decimal or/and hexadecimal numbers separated by single space. If null or "", returns empty array.</param>
            <remarks>
            For vice versa use <c>string.Join(" ", array)</c>.
            </remarks>
        </member>
        <member name="M:Au.More.StringUtil.LineAndColumn(System.String,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Converts character index in string to line index and character index in that line.
            </summary>
            <param name="s"></param>
            <param name="index">Character index in string <i>s</i>.</param>
            <param name="lineIndex">Receives 0-based line index.</param>
            <param name="indexInLine">Receives 0-based character index in that line.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.More.StringUtil.LevenshteinDistance(System.String,System.String)">
            <summary>
            Calculates the Levenshtein distance between two strings, which tells how much they are different.
            </summary>
            <remarks>
            It is the number of character edits (removals, inserts, replacements) that must occur to get from string s1 to string s2.
            Can be used to measure similarity and match approximate strings with fuzzy logic.
            Uses code and info from <see href="https://www.dotnetperls.com/levenshtein"/>.
            </remarks>
        </member>
        <member name="M:Au.More.StringUtil.CommonPrefix(System.String,System.String)">
            <summary>
            Returns the number of characters common to the start of each string.
            </summary>
        </member>
        <member name="M:Au.More.StringUtil.CommonSuffix(System.String,System.String)">
            <summary>
            Returns the number of characters common to the end of each string.
            </summary>
        </member>
        <member name="T:Au.More.ProcessMemory">
            <summary>
            Allocates, writes and reads memory in other process.
            </summary>
            <remarks>
            Must be disposed. Example: <c>using(var pm=new ProcessMemory(...)) { ... }</c>.
            </remarks>
        </member>
        <member name="M:Au.More.ProcessMemory.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.More.ProcessMemory.Dispose">
            
        </member>
        <member name="M:Au.More.ProcessMemory.Finalize">
            
        </member>
        <member name="P:Au.More.ProcessMemory.ProcessHandle">
            <summary>
            Process handle.
            Opened with access PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE.
            </summary>
        </member>
        <member name="P:Au.More.ProcessMemory.Mem">
            <summary>
            Address of memory allocated in that process.
            </summary>
            <remarks>
            The address is invalid in this process.
            </remarks>
        </member>
        <member name="M:Au.More.ProcessMemory.SetMem(System.IntPtr,System.Boolean)">
            <summary>
            Sets an address of memory in that process to be used by the read and write functions.
            </summary>
            <param name="mem">A memory address in that process.</param>
            <param name="freeWhenDisposing">
            Let the Dispose method (or finalizer) call API <msdn>VirtualFreeEx</msdn> to free mem. The memory must be allocated with API <msdn>VirtualAllocEx</msdn> (by any process) or <msdn>VirtualAlloc</msdn> (by that process).
            If false, mem can be any memory in that process, and this variable will not free it. Alternatively you can use <see cref="M:Au.More.ProcessMemory.ReadOther(System.IntPtr,System.Void*,System.Int32)"/> and <see cref="M:Au.More.ProcessMemory.WriteOther(System.IntPtr,System.Void*,System.Int32)"/>.</param>
            <exception cref="T:System.InvalidOperationException">This variable already has <see cref="P:Au.More.ProcessMemory.Mem"/> != default, unless it was set by this function with <i>freeWhenDisposing</i> = false.</exception>
            <remarks>
            This function can be used if this variable was created with <i>nBytes</i> = 0. Else exception. Also exception if this function previously called with <i>freeWhenDisposing</i> = true.
            </remarks>
        </member>
        <member name="M:Au.More.ProcessMemory.ForgetMem">
            <summary>
            Clears <see cref="P:Au.More.ProcessMemory.Mem"/> but does not free the memory (and will not free later).
            The memory must be freed with API <msdn>VirtualFreeEx</msdn> by this or target process, or with API <msdn>VirtualFree</msdn> by target process.
            </summary>
        </member>
        <member name="M:Au.More.ProcessMemory.#ctor(Au.wnd,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="w">A window in that process.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <remarks>This is the preferred constructor when the process has windows. It works with windows of [](xref:uac) High integrity level when this process is Medium+uiAccess.</remarks>
            <exception cref="T:Au.Types.AuWndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of UAC) or allocate memory.</exception>
        </member>
        <member name="M:Au.More.ProcessMemory.#ctor(System.Int32,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="processId">Process id.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of [](xref:uac)) or allocate memory.</exception>
        </member>
        <member name="M:Au.More.ProcessMemory.WriteUnicodeString(System.String,System.Int32)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated UTF-16 string. For it is used (s.Length+1)*2 bytes of memory in that process (+1 for the '\0', *2 because UTF-16 character size is 2 bytes).
            Returns false if fails.
            </summary>
            <param name="s">A string in this process.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.WriteAnsiString(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated ANSI string, in default or specified encoding.
            Returns false if fails.
            </summary>
            <param name="s">A string in this process. Normal C# string (UTF-16), not ANSI.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="enc">If null, uses system default ANSI encoding.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copied string, or null if fails.
            In that process the string must be in Unicode UTF-16 format (ie not ANSI).
            </summary>
            <param name="length">Number of characters to copy, not including the terminating '\0'. In both processes a character is 2 bytes.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nChars range. If false, the returned string is of nChars length even if contains '\0' characters.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.ReadAnsiString(System.Int32,System.Int32,System.Boolean,System.Text.Encoding)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copies string, or null if fails.
            In that process the string must be in ANSI format (ie not Unicode UTF-16).
            </summary>
            <param name="length">Number bytes to copy, not including the terminating '\0'. In that process a character is 1 or more bytes (depending on encoding). In this process will be 2 bytes (normal C# string).</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nBytes range of the ANSI string.</param>
            <param name="enc">If null, uses system default ANSI encoding.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.Write(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to the memory in that process allocated by the constructor.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.WriteOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to a known memory address in that process.
            Returns false if fails.
            </summary>
            <param name="ptrDestinationInThatProcess">Memory address in that process where to copy memory from this process.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.More.ProcessMemory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="M:Au.More.ProcessMemory.Read(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies from the memory in that process allocated by the constructor to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.More.ProcessMemory.ReadOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies from a known memory address in that process to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptrSourceInThatProcess">Memory address in that process from where to copy memory.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.More.ProcessMemory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="T:Au.More.MiniProgram_">
            <summary>
            Prepares to quickly start and execute a script with role miniProgram in this preloaded task process.
            </summary>
        </member>
        <member name="M:Au.More.MiniProgram_.Init(System.IntPtr,Au.More.MiniProgram_._TaskInit@)">
            <summary>
            Called by apphost.
            </summary>
        </member>
        <member name="F:Au.More.MiniProgram_.EFlags.RefPaths">
            <summary>Has [RefPaths] attribute. It is when some meta r paths cannot be automatically resolved.</summary>
        </member>
        <member name="F:Au.More.MiniProgram_.EFlags.MTA">
            <summary>Main() with [MTAThread].</summary>
        </member>
        <member name="F:Au.More.MiniProgram_.EFlags.Console">
            <summary>Has meta console true.</summary>
        </member>
        <member name="T:Au.filesystem">
            <summary>
            Contains static functions to work with files and directories, such as copy, move, delete, find, get properties, enumerate, create directory, safe load/save, wait if locked.
            </summary>
            <remarks>
            Also you can use .NET file system classes, such as <see cref="T:System.IO.File"/> and <see cref="T:System.IO.Directory"/> in <b>System.IO</b> namespace. In the past they were too limited and unsafe to use, for example no long paths, too many exceptions, difficult to recursively enumerate directories containing protected items. Later improved, but this class still has something they don't, for example environment variables in path, safe load/save. This class does not have low-level functions to open/read/write files.
            
            Most functions support only full path. Most of them throw <b>ArgumentException</b> if passed a filename or relative path, ie in "current directory". Using current directory is unsafe.
            Most functions support extended-length paths (longer than 259). Such local paths should have <c>@"\\?\"</c> prefix, like <c>@"\\?\C:\..."</c>. Such network path should be like <c>@"\\?\UNC\server\share\..."</c>. See <see cref="M:Au.pathname.prefixLongPath(System.String)"/>, <see cref="M:Au.pathname.prefixLongPathIfNeed(System.String)"/>. Many functions support long paths even without prefix.
            
            Disk drives like <c>@"C:\"</c> or <c>"C:"</c> are directories too.
            </remarks>
        </member>
        <member name="M:Au.filesystem._DisableDeviceNotReadyMessageBox">
            <summary>
            Adds SEM_FAILCRITICALERRORS to the error mode of this process, as MSDN recommends. Once in process.
            It is to avoid unnecessary message boxes when an API tries to access an ejected CD/DVD etc.
            </summary>
        </member>
        <member name="M:Au.filesystem.getProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes, size and times.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributesEx</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>).</param>
            <param name="properties">Receives properties.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">The file/directory exist but failed to get its properties. Not thrown if used flag DontThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            You can also get most of these properties with <see cref="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </remarks>
        </member>
        <member name="M:Au.filesystem.getAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>).</param>
            <param name="attributes">Receives attributes, or 0 if failed.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">Failed. Not thrown if used flag DontThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            </remarks>
        </member>
        <member name="M:Au.filesystem._GetAttributes(System.String,System.IO.FileAttributes@,System.Boolean)">
            <summary>
            Gets attributes.
            Returns false if INVALID_FILE_ATTRIBUTES or if relative path. No exceptions.
            </summary>
        </member>
        <member name="M:Au.filesystem.exists(System.String,System.Boolean)">
            <summary>
            Gets file or directory attributes as <see cref="T:Au.Types.FAttr"/> that tells whether it exists, is directory, symbolic link, readonly, hidden, system. See examples.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>. If you need exception when fails, instead call <see cref="M:Au.filesystem.getAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default), can't find the file; if useRawPath is true, searches in "current directory".
            For symbolic links gets attributes of the link, not target; does not care whether its target exists.
            </remarks>
            <example>
            <code><![CDATA[
            var path = @"C:\Test\test.txt";
            if (filesystem.exists(path)) print.it("exists");
            if (filesystem.exists(path).isFile) print.it("exists as file");
            if (filesystem.exists(path).isDir) print.it("exists as directory");
            if (filesystem.exists(path) is FAttr { isFile: true, isReadonly: false }) print.it("exists as file and isn't readonly");
            switch (filesystem.exists(path)) {
            case 0: print.it("doesn't exist"); break;
            case 1: print.it("file"); break;
            case 2: print.it("dir"); break;
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.filesystem.ExistsAs_(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returns NotFound (0) if does not exist. Returns AccessDenied (&lt; 0) if exists but this process cannot access it and get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>. If you need exception when fails, instead call <see cref="M:Au.filesystem.getAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attributes Directory and ReparsePoint.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.filesystem.searchPath(System.String,System.String[])">
            <summary>
            Finds file or directory and returns full path.
            Returns null if cannot be found.
            </summary>
            <remarks>
            If the path argument is full path, calls <see cref="M:Au.filesystem.exists(System.String,System.Boolean)"/> and returns normalized path if exists, null if not.
            Else searches in these places:
            1. <i>dirs</i>, if used.
            2. <see cref="P:Au.folders.ThisApp"/>.
            3. Calls API <msdn>SearchPath</msdn>, which searches in process directory, Windows system directories, current directory, PATH environment variable. The search order depends on API <msdn>SetSearchPathMode</msdn> or registry settings.
            4. If path ends with ".exe", tries to get path from registry "App Paths" keys.
            </remarks>
            <param name="path">Full or relative path or just filename with extension. Supports network paths too.</param>
            <param name="dirs">0 or more directories where to search.</param>
        </member>
        <member name="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})">
            <summary>
            Gets names and other info of files and subdirectories in the specified directory.
            Returns an enumerable collection of <see cref="T:Au.Types.FEFile"/> objects containing the info.
            </summary>
            <param name="directoryPath">Full path of the directory.</param>
            <param name="flags"></param>
            <param name="filter">
            Callback function. Called for each file and subdirectory. If returns false, the file/subdirectory is not included in results.
            Can be useful when <b>Enumerate</b> is called indirectly, for example by the <see cref="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> method. If you call it directly, you can instead skip the file in your foreach loop.
            Example: <c>filter: k => k.IsDirectory || k.Name.Ends(".png", true)</c>. See <see cref="P:Au.Types.FEFile.IsDirectory"/>.
            </param>
            <param name="errorHandler">
            Callback function. Called when fails to get children of a subdirectory, when using flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/>.
            Receives the subdirectory path. Can call <see cref="T:Au.lastError"/><b>.Code</b> and throw an exception. If does not throw, the enumeration continues as if the directory is empty.
            If <i>errorHandler</i> not used, then <b>Enumerate</b> throws exception. See also: flag <see cref="F:Au.Types.FEFlags.IgnoreInaccessible"/>.
            </param>
            <exception cref="T:System.ArgumentException"><i>directoryPath</i> is invalid path or not full path.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><i>directoryPath</i> directory does not exist.</exception>
            <exception cref="T:Au.Types.AuException">Failed to get children of <i>directoryPath</i> or of a subdirectory.</exception>
            <remarks>
            Uses API <msdn>FindFirstFile</msdn>.
            
            By default gets only direct children. Use flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/> to get all descendants.
            
            The paths that this function gets are normalized, ie may not start with exact <i>directoryPath</i> string. Expanded environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>), "..", DOS path etc.
            Paths longer than <see cref="F:Au.pathname.maxDirectoryPathLength"/> have <c>@"\\?\"</c> prefix (see <see cref="M:Au.pathname.prefixLongPathIfNeed(System.String)"/>).
            
            For symbolic links and mounted folders, gets info of the link/folder and not of its target.
            
            These errors are ignored:
            1. Missing target directory of a symbolic link or mounted folder.
            2. If used flag <see cref="F:Au.Types.FEFlags.IgnoreInaccessible"/> - access denied.
            
            When an error is ignored, the function works as if that [sub]directory is empty; does not throw exception and does not call <i>errorHandler</i>.
            
            Enumeration of a subdirectory starts immediately after the subdirectory itself is retrieved.
            </remarks>
        </member>
        <member name="M:Au.filesystem._SafeDeleteExistingDirectory.Rename(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.filesystem.rename(System.String,System.String,Au.Types.FIfExists)">
            <summary>
            Renames file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newName">New name without path. Example: "name.txt".</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).
            - <i>newName</i> is invalid filename.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>MoveFileEx</msdn>.
            </remarks>
        </member>
        <member name="M:Au.filesystem.move(System.String,System.String,Au.Types.FIfExists)">
            <summary>
            Moves (changes path of) file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note>It is not the new parent directory. Use <see cref="M:Au.filesystem.moveTo(System.String,System.String,Au.Types.FIfExists)"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy security properties; sets default.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.filesystem.createDirectory(System.String,System.String)"/>).
            If path and newPath share the same parent directory, just renames the file.
            </remarks>
        </member>
        <member name="M:Au.filesystem.moveTo(System.String,System.String,Au.Types.FIfExists)">
            <summary>
            Moves file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> or <i>newDirectory</i> is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).
            - <i>path</i> is drive. To move drive content, use <see cref="M:Au.filesystem.move(System.String,System.String,Au.Types.FIfExists)"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy security properties; sets default.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.filesystem.createDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note>It is not the new parent directory. Use <see cref="M:Au.filesystem.copyTo(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">
            Callback function. Can be used when copying directory. Called for each descendant file and subdirectory.
            If returns false, the file/subdirectory is not copied.
            Example: <c>filter: k => k.IsDirectory || k.Name.Ends(".png", true)</c>. See <see cref="P:Au.Types.FEFile.IsDirectory"/>.
            </param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy security properties; sets default.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.filesystem.createDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.filesystem.copyTo(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">See <see cref="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.</param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> or <i>newDirectory</i> is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).
            - <i>path</i> is drive. To copy drive content, use <see cref="M:Au.filesystem.copy(System.String,System.String,Au.Types.FIfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy security properties; sets default.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.filesystem.createDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.filesystem.delete(System.String,System.Boolean)">
            <summary>
            Deletes file or directory.
            Does nothing if it does not exist (no exception).
            </summary>
            <param name="path">Full path.</param>
            <param name="tryRecycleBin">
            Send to the Recycle Bin. If not possible, delete anyway.
            Why could be not possible: 1. The file is in a removable drive (most removables don't have a recycle bin). 2. The file is too large. 3. The path is too long. 4. The Recycle Bin is not used on that drive (it can be set in the Recycle Bin Properties dialog). 5. This process is non-UI-interactive, eg a service. 6. Unknown reasons.
            Note: it is much slower. To delete multiple, use <see cref="M:Au.filesystem.delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)"/>.
            </param>
            <exception cref="T:System.ArgumentException">path is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If directory, also deletes all its files and subdirectories. If fails to delete some, tries to delete as many as possible.
            Deletes read-only files too.
            Does not show any message boxes etc (confirmation, error, UAC consent, progress).
            
            Some reasons why this function can fail:
            1. The file is open (in any process). Or a file in the directory is open.
            2. This process does not have security permissions to access or delete the file or directory or some of its descendants.
            3. The directory is (or contains) the "current directory" (in any process).
            </remarks>
        </member>
        <member name="M:Au.filesystem.delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Deletes multiple files or/and directories.
            The same as <see cref="M:Au.filesystem.delete(System.String,System.Boolean)"/>, but faster when using Recycle Bin.
            </summary>
            <param name="paths">string array, List or other collection. Full paths.</param>
            <param name="tryRecycleBin"></param>
            <exception cref="T:System.ArgumentException">path is not full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>).</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.filesystem._Delete(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.filesystem.createDirectory(System.String,System.String)">
            <summary>
            Creates new directory if does not exists.
            If need, creates missing parent/ancestor directories.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="path">Path of new directory.</param>
            <param name="templateDirectory">Optional path of a template directory from which to copy some properties. See API <msdn>CreateDirectoryEx</msdn>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If the directory already exists, this function does nothing, and returns false.
            Else, at first it creates missing parent/ancestor directories, then creates the specified directory.
            To create the specified directory, calls API <msdn>CreateDirectory</msdn> or <msdn>CreateDirectoryEx</msdn> (if templateDirectory is not null).
            </remarks>
        </member>
        <member name="M:Au.filesystem.createDirectoryFor(System.String)">
            <summary>
            Creates parent directory for a new file, if does not exist.
            The same as <see cref="M:Au.filesystem.createDirectory(System.String,System.String)"/>, just removes filename from <i>filePath</i>.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="filePath">Path of new file.</param>
            <exception cref="T:System.ArgumentException">Not full path. No filename.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            string path = @"D:\Test\new\test.txt";
            filesystem.createDirectoryFor(path);
            File.WriteAllText(path, "text"); //would fail if directory @"D:\Test\new" does not exist
            ]]></code>
            </example>
        </member>
        <member name="M:Au.filesystem._PreparePath(System.String)">
            <summary>
            Expands environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>). Throws ArgumentException if not full path. Normalizes. Removes or adds <c>'\\'</c> at the end.
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.filesystem._FindFilename(System.String,System.Boolean)">
            <summary>
            Finds filename, eg <c>@"b.txt"</c> in <c>@"c:\a\b.txt"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns -1.</exception>
        </member>
        <member name="M:Au.filesystem._RemoveFilename(System.String,System.Boolean)">
            <summary>
            Removes filename, eg <c>@"c:\a\b.txt"</c> -> <c>@"c:\a"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.filesystem._GetFilename(System.String,System.Boolean)">
            <summary>
            Gets filename, eg <c>@"c:\a\b.txt"</c> -> <c>@"b.txt"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.filesystem._IsSepChar(System.Char)">
            <summary>
            Returns true if character <c>c == '\\' || c == '/'</c>.
            </summary>
        </member>
        <member name="M:Au.filesystem.waitIfLocked``1(System.Func{``0},System.Int32)">
            <summary>
            This function can be used to safely open a file that may be temporarily locked (used by another process or thread). Waits while the file is locked.
            </summary>
            <returns>Returns the return value of the lambda <i>f</i>.</returns>
            <param name="f">Lambda that calls a function that creates, opens or opens/reads/closes a file.</param>
            <param name="millisecondsTimeout">Wait max this number of milliseconds. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>millisecondsTimeout</i> less than -1.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the called function.</exception>
            <remarks>
            Calls the lambda and handles <b>IOException</b>. If the exception indicates that the file is locked, waits and retries in loop.
            </remarks>
            <example>
            <code><![CDATA[
            var s1 = File.ReadAllText(file); //unsafe. Exception if the file is locked.
            
            var s2 = filesystem.waitIfLocked(() => File.ReadAllText(file)); //safe. Waits while the file is locked.
            
            using(var f = filesystem.waitIfLocked(() => File.OpenText(file))) { //safe. Waits while the file is locked.
            	var s3 = f.ReadToEnd();
            }
            
            using(var f = filesystem.waitIfLocked(() => File.Create(file))) { //safe. Waits while the file is locked.
            	f.WriteByte(1);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.filesystem.waitIfLocked(System.Action,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><i>millisecondsTimeout</i> less than -1.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the called function.</exception>
            <example>
            <code><![CDATA[
            File.WriteAllText(file, "TEXT"); //unsafe. Exception if the file is locked.
            
            filesystem.waitIfLocked(() => File.WriteAllText(file, "TEXT")); //safe. Waits while the file is locked.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.filesystem.loadText(System.String,System.Text.Encoding)">
            <summary>
            Loads text file in a safer way.
            Uses <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.filesystem.waitIfLocked``1(System.Func{``0},System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <param name="encoding">Text encoding in file. Default <b>Encoding.UTF8</b>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllText(System.String)"/>.</exception>
        </member>
        <member name="M:Au.filesystem.loadBytes(System.String)">
            <summary>
            Loads file in a safer way.
            Uses <see cref="M:System.IO.File.ReadAllBytes(System.String)"/> and <see cref="M:Au.filesystem.waitIfLocked``1(System.Func{``0},System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllBytes(System.String)"/>.</exception>
        </member>
        <member name="M:Au.filesystem.loadStream(System.String)">
            <summary>
            Loads file in a safer way.
            Uses <see cref="M:System.IO.File.OpenRead(System.String)"/> and <see cref="M:Au.filesystem.waitIfLocked``1(System.Func{``0},System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.OpenRead(System.String)"/>.</exception>
        </member>
        <member name="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)">
            <summary>
            Writes any data to a file in a safe way, using a callback function.
            </summary>
            <param name="file">
            File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            The file can exist or not; this function overwrites it. If the directory does not exist, this function creates it.
            </param>
            <param name="writer">
            Callback function (lambda etc) that creates/writes/closes a temporary file. Its parameter is the full path of the temporary file, which normally does not exist.
            May be called multiple times, because this function retries if the file is locked or if the directory does not exist (if writer throws <b>DirectoryNotFoundException</b> exception).
            </param>
            <param name="backup">Create backup file named <i>file</i> + "~backup".</param>
            <param name="tempDirectory">
            Directory for backup file and temporary file. If null or "" - <i>file</i>'s directory. Can contain environment variales etc.
            Must be in the same drive as <i>file</i>. If the directory does not exist, this function creates it.</param>
            <param name="lockedWaitMS">If cannot open file because it is open by another process etc, wait max this number of milliseconds. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of the <i>writer</i> function.</exception>
            <exception cref="T:System.IO.IOException">Failed to replace file. The <i>writer</i> function also can thow it.</exception>
            <remarks>
            The file-write functions provided by .NET and Windows API are less reliable, because:
            1. Fails if the file is temporarily open by another process or thread without sharing.
            2. Can corrupt file data. If this thread, process, PC or disk dies while writing, may write only part of data or just make empty file. Usually it happens when PC is turned off incorrectly.
            
            To protect from 1, this functions waits/retries if the file is temporarily open/locked, like <see cref="M:Au.filesystem.waitIfLocked(System.Action,System.Int32)"/>.
            To protect from 2, this function writes to a temporary file and renames/replaces the specified file using API <msdn>ReplaceFile</msdn>. Although not completely atomic, it ensures that file data is not corrupt; if cannot write all data, does not change existing file data.
            Also this function auto-creates directory if does not exist.
            
            This function is slower. Speed can be important when saving many files.
            </remarks>
        </member>
        <member name="M:Au.filesystem.saveText(System.String,System.String,System.Boolean,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Writes text to a file in a safe way, using <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.
            More info: <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <param name="text">Text to write.</param>
            <param name="encoding">Text encoding in file. Default is UTF-8 without BOM.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.filesystem.saveBytes(System.String,System.Byte[],System.Boolean,System.String,System.Int32)">
            <summary>
            Writes data to a file in a safe way, using <see cref="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])"/>.
            More info: <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <param name="bytes">Data to write.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="T:Au.filesystem.more">
            <summary>
            Miscellaneous rarely used file/directory functions.
            </summary>
        </member>
        <member name="M:Au.filesystem.more.getFileId(System.String,Au.Types.FileId@)">
            <summary>
            Gets <see cref="T:Au.Types.FileId"/> of a file or directory.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="path">Full path. Supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>).</param>
            <param name="fileId"></param>
        </member>
        <member name="M:Au.filesystem.more.IsSameFile_(System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.filesystem.more.getFileId(System.String,Au.Types.FileId@)"/> for two paths and returns true if both calls succeed and the ids are equal.
            Paths should be normalized. They are passed to API unmodified.
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="M:Au.filesystem.more.calculateDirectorySize(System.String,Au.Types.FEFlags)">
            <summary>
            Calls <see cref="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> and returns sum of all file sizes.
            With default flags, it includes sizes of all descendant files, in this directory and all subdirectories except in inaccessible [sub]directories.
            </summary>
            <param name="path">Full path.</param>
            <param name="flags"><b>Enumerate</b> flags.</param>
            <exception cref="T:System.Exception"><see cref="M:Au.filesystem.enumerate(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> exceptions. By default, no exceptions if used full path and the directory exists.</exception>
            <remarks>
            This function is slow if the directory is large.
            Don't use this function for files (throws exception) and drives (instead use <see cref="T:System.IO.DriveInfo"/>, it's fast and includes sizes of Recycle Bin and other protected hidden system directories).
            </remarks>
        </member>
        <member name="M:Au.filesystem.more.loadDll64or32Bit(System.String)">
            <summary>
            Loads an unmanaged dll from subfolder "64" or "32" depending on whether this process is 64-bit or 32-bit.
            </summary>
            <param name="fileName">Dll file name like "name.dll".</param>
            <exception cref="T:System.DllNotFoundException"></exception>
            <remarks>
            If your program uses an unmanaged dll and can run as either 64-bit or 32-bit process, you need 2 versions of the dll - 64-bit and 32-bit. Let they live in subfolders "64" and "32" of your program folder. They must have same name. This function loads correct dll version. Then [DllImport("dll")] will use the loaded dll. Don't need two different DllImport for functions ([DllImport("dll64")] and [DllImport("dll32")]).
            
            If the dll does not exist in these folders, this function also looks in:
            - subfolder "64" or "32" of folder specified in environment variable "Au.Path". For example the dll is unavailable if used in an assembly (managed dll) loaded in a nonstandard environment, eg VS forms designer or VS C# Interactive (then folders.ThisApp is "C:\Program Files (x86)\Microsoft Visual Studio\..."). Workaround: set %Au.Path% = the main Au directory and restart Windows.
            - subfolder "64" or "32" of <see cref="P:Au.folders.ThisAppTemp"/>. For example the dll may be extracted there from resources.
            </remarks>
        </member>
        <member name="T:Au.filesystem.more.DisableRedirection">
            <summary>
            Temporarily disables file system redirection, to allow this 32-bit process access the 64-bit System32 directory.
            </summary>
        </member>
        <member name="M:Au.filesystem.more.DisableRedirection.Disable">
            <summary>
            If <see cref="P:Au.osVersion.is32BitProcessAnd64BitOS"/>, calls API <msdn>Wow64DisableWow64FsRedirection</msdn>, which disables file system redirection.
            The caller can call this without checking OS and process bitness. This function checks it and it is fast.
            Always call <see cref="M:Au.filesystem.more.DisableRedirection.Revert"/> or <b>Dispose</b>, for example use <b>finally</b> or <b>using</b> statement. Not calling it is more dangerous than a memory leak. It is not called by GC.
            </summary>
        </member>
        <member name="M:Au.filesystem.more.DisableRedirection.Revert">
            <summary>
            If redirected, calls API <msdn>Wow64RevertWow64FsRedirection</msdn>.
            </summary>
        </member>
        <member name="M:Au.filesystem.more.DisableRedirection.IsSystem64PathIn32BitProcess(System.String)">
            <summary>
            Returns true if <see cref="P:Au.osVersion.is32BitProcessAnd64BitOS"/> is true and path starts with <see cref="P:Au.folders.System"/>.
            Most such paths are redirected, therefore you may want to disable redirection with this class.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of <c>@"\\?\"</c>.</param>
        </member>
        <member name="M:Au.filesystem.more.DisableRedirection.GetNonRedirectedSystemPath(System.String,System.Boolean)">
            <summary>
            If <see cref="P:Au.osVersion.is32BitProcessAnd64BitOS"/> is true and path starts with <see cref="P:Au.folders.System"/>, replaces that path part with <see cref="P:Au.folders.SystemX64"/>.
            It disables redirection to <see cref="P:Au.folders.SystemX86"/> for that path.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of <c>@"\\?\"</c>.</param>
            <param name="ifExistsOnlyThere">Don't replace path if the file or directory exists in the redirected folder or does not exist in the non-redirected folder.</param>
        </member>
        <member name="M:Au.filesystem.more.DisableRedirection.Dispose">
            <summary>
            Calls <see cref="M:Au.filesystem.more.DisableRedirection.Revert"/>.
            </summary>
        </member>
        <member name="T:Au.folders">
             <summary>
             Gets known/special folder paths (Desktop, Temp, etc).
             </summary>
             <remarks>
             Most functions return <see cref="T:Au.Types.FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with \ separator if need. Example: <c>string s = folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
             If a function cannot get folder path, the return value contains null string. Then the + operator would throw <see cref="T:Au.Types.AuException"/>.
            
             Some folders are known only on newer Windows versions or only on some computers. Some functions have a suffix like <b>_Win8</b> which means that the folder is unavailable on older Windows.
             Some known folders, although supported and registerd, may be still not created.
             
             Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by a data structure called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="T:Au.folders.shell"/> return it as <see cref="T:Au.Types.Pidl"/> or string <c>":: ITEMIDLIST"</c> that can be used with some functions of this library (<see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>, <see cref="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)"/>, <see cref="M:Au.icon.ofPidl(Au.Types.Pidl,System.Int32)"/>) but not with .NET functions.
            
             Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
             The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
             Names of folders specific to current process have prefix <b>This</b>, like <b>ThisApp</b>.
             
             Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
             <table>
             <tr>
             <td>32-bit Windows</td>
             <td>
             System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             <br/>ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </td>
             </tr>
             <tr>
             <td>64-bit Windows, 64-bit process</td>
             <td>
             System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             <br/>ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             <br/>ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             </td>
             </tr>
             <tr>
             <td>64-bit Windows, 32-bit process</td>
             <td>
             System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
             <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             <br/>SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path, not in Explorer.
             <br/>ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             <br/>ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             <br/>ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </td>
             </tr>
             </table>
             </remarks>
        </member>
        <member name="P:Au.folders.ProgramFiles">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.ProgramFilesX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.ProgramFilesCommon">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.ProgramFilesCommonX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.System">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.SystemX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="T:Au.folders.shell">
            <summary>
            Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as string like ":: 12345678..." or as <see cref="T:Au.Types.Pidl"/>.
            Functions with suffix "Pidl" gets
            </summary>
        </member>
        <member name="P:Au.folders.Temp">
            <summary>
            Temp folder (temporary files) of this user account.
            </summary>
        </member>
        <member name="P:Au.folders.ThisApp">
            <summary>
            Folder containing assemblies of this app.
            </summary>
            <remarks>
            Uses <see cref="P:System.AppContext.BaseDirectory"/>.
            </remarks>
            <seealso cref="P:Au.process.thisExePath"/>
        </member>
        <member name="P:Au.folders.ThisAppBS">
            <summary>
            <see cref="P:Au.folders.ThisApp"/> with appended backslash character.
            Returns string, not <see cref="T:Au.Types.FolderPath"/> like other functions.
            </summary>
            <remarks>
            Uses <see cref="P:System.AppContext.BaseDirectory"/>.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppTemp">
            <summary>
            Gets or sets path of folder "temporary files of this application".
            Default is <c>folders.Temp + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppDocuments">
            <summary>
            Gets or sets path of folder "user document files of this application".
            Default is <c>folders.Documents + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppData">
            <summary>
            Gets or sets path of folder "private files of this application of this user account".
            Default is <c>folders.RoamingAppData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppDataLocal">
            <summary>
            Gets or sets path of folder "local (non-roaming) private files of this application of this user account".
            Default is <c>folders.LocalAppData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppDataCommon">
            <summary>
            Gets or sets path of folder "common (all users) private files of this application".
            Default is <c>folders.ProgramData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            This function does not auto-create the folder; usually it is created when installing the application.
            Note: the ProgramData folder has special security permissions. Programs running not as administrator usually cannot write there, unless your installer changed folder security permissions.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppImages">
            <summary>
            Gets or sets path of folder "images (icons etc) of this application".
            Default is <c>ThisAppBS + "Images"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            Used by functions of these classes: <b>icon</b>, <b>popupMenu</b>, <b>toolbar</b>, <b>uiimage</b>, possibly some other.
            This function does not auto-create the folder; usually it is created when installing the application.
            </remarks>
        </member>
        <member name="P:Au.folders.ThisAppDriveBS">
            <summary>
            Gets the root directory of this application, like @"C:\" or @"\\network\folder\".
            </summary>
        </member>
        <member name="P:Au.folders.Workspace">
            <summary>
            Gets folder of current workspace.
            Available in editor process. In script process available if role is miniProgram or editorExtension. Elsewhere null.
            </summary>
        </member>
        <member name="P:Au.folders.WorkspaceDriveBS">
            <summary>
            Gets the root directory of <see cref="P:Au.folders.Workspace"/>, like @"C:\" or @"\\network\folder\".
            </summary>
        </member>
        <member name="P:Au.folders.workspaceDriveType">
            <summary>
            Gets drive type (fixed, removable, network, etc) of <see cref="P:Au.folders.WorkspaceDriveBS"/>.
            </summary>
        </member>
        <member name="P:Au.folders.thisAppDriveType">
            <summary>
            Gets drive type (fixed, removable, network, etc) of <see cref="P:Au.folders.ThisAppDriveBS"/>.
            </summary>
        </member>
        <member name="M:Au.folders.sourceCode(System.String)">
            <summary>
            Gets folder path of caller's source code file.
            </summary>
            <param name="f_">[](xref:caller_info)</param>
        </member>
        <member name="P:Au.folders.SystemX64">
            <summary>
            Gets non-redirected path of the System32 folder.
            </summary>
            <remarks>
            If this process is 32-bit and OS is 64-bit, when it uses the <see cref="P:Au.folders.System"/> folder path (<c>@"C:\WINDOWS\system32"</c>), the OS in most cases redirects it to <c>@"C:\Windows\SysWOW64"</c>, which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
            More info in class help.
            </remarks>
            <seealso cref="T:Au.filesystem.more.DisableRedirection"/>
            <seealso cref="P:Au.osVersion.is32BitProcessAnd64BitOS"/>
        </member>
        <member name="P:Au.folders.ProgramFilesX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.ProgramFilesCommonX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.folders.NetRuntime">
            <summary>
            Gets .NET runtime folder, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0</c>.
            </summary>
        </member>
        <member name="P:Au.folders.NetRuntimeBS">
            <summary>
            Gets .NET runtime folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0\</c>.
            </summary>
        </member>
        <member name="P:Au.folders.NetRuntimeDesktop">
            <summary>
            Gets .NET runtime desktop folder, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0</c>.
            </summary>
        </member>
        <member name="P:Au.folders.NetRuntimeDesktopBS">
            <summary>
            Gets .NET runtime desktop folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0\</c>.
            </summary>
        </member>
        <member name="P:Au.folders.CdDvdDrive">
            <summary>
            Gets CD/DVD drive path, like <c>@"D:\"</c>.
            Returns null if unavailable.
            </summary>
        </member>
        <member name="P:Au.folders.RemovableDrive0">
            <summary>Calls <see cref="M:Au.folders.removableDrive(System.Int32)"/>(0).</summary>
        </member>
        <member name="P:Au.folders.RemovableDrive1">
            <summary>Calls <see cref="M:Au.folders.removableDrive(System.Int32)"/>(1).</summary>
        </member>
        <member name="P:Au.folders.RemovableDrive2">
            <summary>Calls <see cref="M:Au.folders.removableDrive(System.Int32)"/>(2).</summary>
        </member>
        <member name="P:Au.folders.RemovableDrive3">
            <summary>Calls <see cref="M:Au.folders.removableDrive(System.Int32)"/>(3).</summary>
        </member>
        <member name="M:Au.folders.removableDrive(System.Int32)">
            <summary>
            Gets removable/external/USB drive path, like <c>@"F:\"</c>.
            Returns null if unavailable.
            </summary>
            <param name="driveIndex">0-based removable drive index.</param>
            <remarks>Uses <see cref="M:System.IO.DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
        </member>
        <member name="M:Au.folders.removableDrive(System.String)">
            <summary>
            Gets removable/external/USB drive name (like <c>@"F:\"</c>) by its volume label.
            Returns null if unavailable.
            </summary>
            <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
        </member>
        <member name="M:Au.folders.envVar(System.String)">
            <summary>
            Gets the value of an environment variable in current process.
            Returns null if variable not found.
            </summary>
            <seealso cref="M:System.Environment.GetEnvironmentVariable(System.String)"/>
            <seealso cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)"/>
            <seealso cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>
        </member>
        <member name="M:Au.folders.getKnownFolders">
            <summary>
            Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
            These names can be used with <see cref="M:Au.folders.getFolder(System.String)"/>.
            </summary>
        </member>
        <member name="M:Au.folders.getFolder(System.String)">
            <summary>
            Gets path of a known folder by its name as string.
            Returns null if unavailable.
            </summary>
            <param name="folderName">
            Can be:
            - name of a property of this class, like <c>"Documents"</c>, <c>"Temp"</c>, <c>"ThisApp"</c>. The property must return <b>FolderPath</b>.
            - name of a property of the nested class <see cref="T:Au.folders.shell"/>, like <c>"shell.ControlPanel"</c>. Gets <c>":: ITEMIDLIST"</c>.
            - known folder canonical name. See <see cref="M:Au.folders.getKnownFolders"/>. If has prefix <c>"shell."</c>, gets <c>":: ITEMIDLIST"</c>. Much slower, but allows to get paths of folders registered by applications.
            </param>
            <seealso cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>
        </member>
        <member name="M:Au.folders.unexpandPath(System.String,System.String@,System.String@)">
            <summary>
            If string starts with a known/special folder path, gets folder name + relative path and returns true.
            For example if string is <c>C:\Windows\System32\notepad.exe</c>, gets <c>folders.System</c> and <c>notepad.exe</c>.
            </summary>
            <param name="path">Any string. Can be null. Case-insensitive. Supports ":: ITEMIDLIST" (see <see cref="M:Au.Types.Pidl.ToHexString"/>).</param>
            <param name="folder">Receives special folder string like <c>"folders.System"</c>.</param>
            <param name="name">Receives filename or relative path in the folder.</param>
            <remarks>
            Quite slow first time in process, eg 50 ms, because gets all folder paths. Later uses cached paths.
            </remarks>
            <seealso cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>
        </member>
        <member name="T:Au.icon">
            <summary>
            Gets icons from/of files etc. Contains native icon handle.
            </summary>
            <remarks>
            Native icons must be destroyed. An <b>icon</b> variable destroys its native icon when disposing. To dispose, call <b>Dispose</b> or use <b>using</b> statement. Or use functions like <see cref="M:Au.icon.ToGdipBitmap(System.Boolean)"/>, <see cref="M:Au.icon.ToWpfImage(System.Boolean)"/>; by default they dispose the <b>icon</b> variable. It's OK to not dispose if you use few icons; GC will do it.
            </remarks>
        </member>
        <member name="M:Au.icon.#ctor(System.IntPtr)">
            <summary>
            Sets native icon handle.
            The icon will be destroyed when disposing this variable or when converting to object of other type.
            </summary>
        </member>
        <member name="M:Au.icon.Dispose">
            <summary>
            Destroys native icon handle.
            </summary>
        </member>
        <member name="M:Au.icon.Finalize">
            
        </member>
        <member name="M:Au.icon.Detach">
            <summary>
            Clears this variable and returns its native icon handle.
            </summary>
        </member>
        <member name="P:Au.icon.Handle">
            <summary>
            Gets native icon handle.
            </summary>
        </member>
        <member name="M:Au.icon.op_Implicit(Au.icon)~System.IntPtr">
            <summary>
            Gets native icon handle.
            </summary>
        </member>
        <member name="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)">
            <summary>
            Gets icon that can be displayed for a file, folder, shell object, URL or file type.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">
            Can be:
            - Path of any file or folder. Supports environment variables. If not full path, uses <see cref="P:Au.folders.ThisAppImages"/> and <see cref="M:Au.filesystem.searchPath(System.String,System.String[])"/>.
            - Any shell object, like <c>":: ITEMIDLIST"</c>, <c>@"::{CLSID-1}\::{CLSID-2}"</c>, <c>@"shell:AppsFolder\WinStoreAppId"</c>.
            - File type like <c>".txt"</c>, or protocol like <c>"http:"</c>. Use <c>"."</c> to get forder icon.
            - Path with icon resource index or negative id, like "c:\file.dll,4", "c:\file.exe,-4".
            - URL.
            </param>
            <param name="size">Icon width and height. Default 16.</param>
            <param name="flags"></param>
            <remarks>
            ITEMIDLIST can be of any file, folder, URL or a non-filesystem shell object. See <see cref="M:Au.Types.Pidl.ToHexString"/>.
            </remarks>
        </member>
        <member name="M:Au.icon.ofPidl(Au.Types.Pidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="pidl">ITEMIDLIST pointer (PIDL).</param>
            <param name="size">Icon width and height. Default 16.</param>
        </member>
        <member name="M:Au.icon.load(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts icon directly from file that contains it.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">.ico, .exe, .dll or other file that contains one or more icons. Also supports cursor files - .cur, .ani. Must be full path, without icon index. Supports environment variables (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>).</param>
            <param name="size">Icon width and height. Default 16.</param>
            <param name="index">Icon index or negative icon resource id in the .exe/.dll file.</param>
        </member>
        <member name="M:Au.icon.stock(Au.Types.StockIcon,System.Int32)">
            <summary>
            Gets a shell stock icon.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="id">Shell stock icon id.</param>
            <param name="size">Icon width and height. Default 16.</param>
        </member>
        <member name="M:Au.icon.ofThisApp(System.Int32,System.Int32)">
            <summary>
            Gets icon from unmanaged resources of this program.
            </summary>
            <returns>Returns null if not found.</returns>
            <param name="size">Icon width and height. Default 16.</param>
            <param name="resourceId">Native resource id. Default <msdn>IDI_APPLICATION</msdn> (C# compilers add app icon with this id).</param>
            <remarks>
            If role miniProgram (default), at first looks in main assembly (.dll); if not found there, looks in .exe file. Else only in .exe file.
            </remarks>
        </member>
        <member name="M:Au.icon.trayIcon(System.Int32)">
            <summary>
            Gets icon of tray icon size from unmanaged resources of this program or system.
            </summary>
            <param name="resourceId">Native resource id. Default <msdn>IDI_APPLICATION</msdn> (C# compilers add app icon with this id).</param>
            <remarks>
            Calls API <msdn>LoadIconMetric</msdn>.
            
            The icon can be in main assembly (if role miniProgram) or in the program file (.exe). If not found, loads standard icon, see API <b>LoadIconMetric</b>.
            </remarks>
        </member>
        <member name="M:Au.icon.trayIcon(System.String)">
            <summary>
            Loads icon of tray icon size from .ico file.
            </summary>
            <returns>Returns null if not found.</returns>
            <remarks>
            Calls API <msdn>LoadIconMetric</msdn>.
            </remarks>
        </member>
        <member name="M:Au.icon.GetAppIconModuleHandle_(System.Int32)">
            <summary>
            Gets native module handle of exe or dll that contains specified icon. Returns default if no icon.
            If role miniProgram, at first looks in main assembly (.dll).
            </summary>
        </member>
        <member name="M:Au.icon.ofWindow(Au.wnd,System.Int32)">
            <summary>
            Gets icon that is displayed in window title bar and in taskbar button.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="w">Window of any process.</param>
            <param name="size">Icon width and height. Default 16.</param>
        </member>
        <member name="M:Au.icon.create(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})">
            <summary>
            Creates icon at run time.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="drawCallback">Called to draw icon. If null, the icon will be completely transparent.</param>
        </member>
        <member name="M:Au.icon.ToGdipIcon">
            <summary>
            Creates <see cref="T:System.Drawing.Icon"/> object that shares native icon handle with this object.
            Returns null if <i>Handle</i> is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.icon.ToGdipBitmap(System.Boolean)">
            <summary>
            Converts native icon to GDI+ bitmap object.
            Returns null if <i>Handle</i> is default(IntPtr) or if fails to convert.
            </summary>
            <param name="destroyIcon">
            If true (default), destroys the native icon object; also clears this variable and don't need to dispose it.
            If false, later will need to dispose this variable.
            </param>
        </member>
        <member name="M:Au.icon.ToWpfImage(System.Boolean)">
            <summary>
            Converts native icon to WPF image object.
            Returns null if <i>Handle</i> is default(IntPtr) or if fails to convert.
            </summary>
            <param name="destroyIcon">
            If true (default), destroys the native icon object; also clears this variable and don't need to dispose it.
            If false, later will need to dispose this variable.
            </param>
        </member>
        <member name="P:Au.icon.Size">
            <summary>
            Gets icon size.
            Returns default if fails.
            </summary>
        </member>
        <member name="M:Au.icon.parsePathIndex(System.String,System.String@,System.Int32@)">
            <summary>
            Parses icon location string.
            Returns true if it includes icon index or resource id.
            </summary>
            <param name="s">
            Icon location. Can be <c>"path,index"</c> or <c>"path,-id"</c> or just path.
            Supports path enclosed in "" like <c>"\"path\",index"</c>, and spaces between comma and index like <c>"path, index"</c>.
            </param>
            <param name="path">Receives path without index and without "". Can be same variable as <i>s</i>.</param>
            <param name="index">Receives index/id or 0.</param>
        </member>
        <member name="P:Au.icon.debugSpeed">
            <summary>
            If not 0, "get icon" functions of this class will print (in editor's output) their execution time in milliseconds when it &gt;= this value.
            </summary>
            <remarks>
            Icons are mostly used in toolbars and menus. Getting icons of some files can be slow. For example if antivirus program scans the file. Toolbars and menus that use slow icons may start with a noticeable delay. Use this property to find too slow icons. Then you can replace them with fast icons, for example .ico files.
            </remarks>
        </member>
        <member name="M:Au.icon.ExtractIconPathFromCode_(System.Reflection.MethodInfo,System.Boolean@)">
            <summary>
            Gets icon path from code that contains string like <c>@"c:\windows\system32\notepad.exe"</c> or <c>@"%folders.System%\notepad.exe"</c> or URL/shell.
            Also supports code patterns like <c>folders.System + "notepad.exe"</c> or <c>folders.shell.RecycleBin</c>.
            Returns null if no such string/pattern.
            </summary>
            <param name="mi"></param>
            <param name="cs">The string is .cs filename or relative path, but not full path.</param>
        </member>
        <member name="T:Au.pathname">
            <summary>
            Contains static functions to work with file path strings. Parse, combine, make full, make unique, make valid, expand variables, etc.
            </summary>
            <remarks>
            Functions of this class work with strings, not with the file system. Some functions may just get file info, for example <see cref="M:Au.pathname.makeUnique(System.String,System.Boolean)"/>.
            
            Functions of this class don't throw exceptions when path is invalid (path format, invalid characters). Only <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/> throws exception if not full path.
            
            Also you can use .NET class <see cref="T:System.IO.Path"/>. In its documentation you'll find more info about paths.
            </remarks>
        </member>
        <member name="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})">
            <summary>
            If path starts with <c>"%"</c> or <c>"\"%"</c>, expands environment variables enclosed in %, else just returns path.
            Also supports known folder names, like <c>"%folders.Documents%"</c>. More info in Remarks.
            </summary>
            <param name="path">Any string. Can be null.</param>
            <param name="strict">
            What to do if path looks like starts with and environment variable or known folder but the variable/folder does not exist:
            - true - throw <b>ArgumentException</b>;
            - false - return unexpanded path;
            - null (default) - call <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/> and return unexpanded path.
            </param>
            <remarks>
            Supports known folder names. See <see cref="T:Au.folders"/>.
            Example: <c>@"%folders.Documents%\file.txt"</c>.
            Example: <c>@"%folders.shell.ControlPanel%" //gets ":: ITEMIDLIST"</c>.
            Usually known folders are used like <c>string path = folders.Documents + "file.txt"</c>. However it cannot be used when you want to store paths in text files, registry, etc. Then this feature is useful.
            To get known folder path, this function calls <see cref="M:Au.folders.getFolder(System.String)"/>.
            
            This function is called by many functions of classes <b>pathname</b>, <b>filesystem</b>, <b>icon</b>, some others, therefore all they support environment variables and known folders in path string.
            </remarks>
            <seealso cref="M:System.Environment.ExpandEnvironmentVariables(System.String)"/>
            <seealso cref="M:System.Environment.GetEnvironmentVariable(System.String)"/>
            <seealso cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)"/>
        </member>
        <member name="M:Au.pathname.isFullPath(System.String,System.Boolean)">
            <summary>
            Returns true if the string is full path, like <c>@"C:\a\b.txt"</c> or <c>@"C:"</c> or <c>@"\\server\share\..."</c>:
            </summary>
            <param name="path">Any string. Can be null.</param>
            <param name="orEnvVar">Also return true if starts with <c>"%environmentVariable%"</c> or <c>"%folders.Folder%"</c>. Note: this function does not check whether the variable/folder exists; for it use <see cref="M:Au.pathname.isFullPathExpand(System.String@,System.Nullable{System.Boolean})"/> instead.</param>
            <remarks>
            Returns true if <i>path</i> matches one of these wildcard patterns:
            - <c>@"?:\*"</c> - local path, like <c>@"C:\a\b.txt"</c>. Here ? is A-Z, a-z.
            - <c>@"?:"</c> - drive name, like <c>@"C:"</c>. Here ? is A-Z, a-z.
            - <c>@"\\*"</c> - network path, like <c>@"\\server\share\..."</c>. Or has prefix <c>@"\\?\"</c>.
            
            Supports <c>'/'</c> characters too.
            
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.pathname.isUrl(System.String)"/>) or starts with <c>"::"</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.isFullPathExpand(System.String@,System.Nullable{System.Boolean})">
            <summary>
            Expands environment variables and calls <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>.
            Returns true if the string is full path, like <c>@"C:\a\b.txt"</c> or <c>@"C:"</c> or <c>@"\\server\share\..."</c>:
            </summary>
            <param name="path">
            Any string. Can be null.
            If starts with '%' character, calls <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/> with expanded environment variables (<see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>). If it returns true, replaces the passed variable with the expanded path string.
            </param>
            <param name="strict">See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>. Shortly: null (default) - warning; true - exception; false - ignore.</param>
            <remarks>
            Returns true if <i>path</i> matches one of these wildcard patterns:
            - <c>@"?:\*"</c> - local path, like <c>@"C:\a\b.txt"</c>. Here ? is A-Z, a-z.
            - <c>@"?:"</c> - drive name, like <c>@"C:"</c>. Here ? is A-Z, a-z.
            - <c>@"\\*"</c> - network path, like <c>@"\\server\share\..."</c>. Or has prefix <c>@"\\?\"</c>.
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.pathname.isUrl(System.String)"/>) or starts with <c>"::"</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.getRootLength(System.String)">
            <summary>
            Gets the length of the drive or network folder part in path, including its separator if any.
            If the string does not start with a drive or network folder path, returns 0 or prefix length (<c>@"\\?\"</c> or <c>@"\\?\UNC\"</c>).
            </summary>
            <param name="path">Full path or any string. Can be null. Should not be <c>@"%environmentVariable%\..."</c>.</param>
            <remarks>
            Supports prefixes <c>@"\\?\"</c> and <c>@"\\?\UNC\"</c>.
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.getUrlProtocolLength(System.String)">
            <summary>
            Gets the length of the URL protocol name (also known as URI scheme) in string, including ':'.
            If the string does not start with a protocol name, returns 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
            <remarks>
            URL examples: <c>"http:"</c> (returns 5), <c>"http://www.x.com"</c> (returns 5), <c>"file:///path"</c> (returns 5), <c>"shell:etc"</c> (returns 6).
            
            The protocol can be unknown. The function just checks string format, which is an ASCII alpha character followed by one or more ASCII alpha-numeric, '.', '-', '+' characters, followed by ':' character.
            </remarks>
        </member>
        <member name="M:Au.pathname.isUrl(System.String)">
            <summary>
            Returns true if the string starts with a URL protocol name (existing or not) and ':' character.
            Calls <see cref="M:Au.pathname.getUrlProtocolLength(System.String)"/> and returns true if it's not 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
            <remarks>
            URL examples: <c>"http:"</c>, <c>"http://www.x.com"</c>, <c>"file:///path"</c>, <c>"shell:etc"</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.combine(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Combines two path parts using character <c>'\\'</c>. For example directory path and file name.
            </summary>
            <param name="s1">First part. Usually a directory.</param>
            <param name="s2">Second part. Usually a filename or relative path.</param>
            <param name="s2CanBeFullPath">s2 can be full path. If it is, ignore s1 and return s2 with expanded environment variables. If false (default), simply combines s1 and s2.</param>
            <param name="prefixLongPath">Call <see cref="M:Au.pathname.prefixLongPathIfNeed(System.String)"/> which may prepend <c>@"\\?\"</c> if the result path is very long. Default true.</param>
            <remarks>
            If s1 and s2 are null or "", returns "". Else if s1 is null or "", returns s2. Else if s2 is null or "", returns s1.
            Does not expand environment variables. For it use <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/> before, or <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/> instead. Path that starts with an environment variable here is considerd not full path.
            Similar to <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>. Main differences: has some options; supports null arguments.
            </remarks>
            <seealso cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>
        </member>
        <member name="M:Au.pathname.Combine_(System.String,System.String,System.Boolean)">
            <summary>
            Combines two path parts.
            Unlike <see cref="M:Au.pathname.combine(System.String,System.String,System.Boolean,System.Boolean)"/>, fails if some part is empty or <c>@"\"</c> or if s2 is <c>@"\\"</c>. Also does not check s2 full path.
            If fails, throws exception or returns null (if noException).
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.pathname.IsSepChar_(System.Char)">
            <summary>
            Returns true if character <c>c == '\\' || c == '/'</c>.
            </summary>
        </member>
        <member name="M:Au.pathname._EndsWithDriveWithoutSep(System.String,System.Int32)">
            <summary>
            Returns true if ends with ':' preceded by a drive letter, like "C:" or "more\C:", but not like "moreC:".
            </summary>
            <param name="s">Can be null.</param>
            <param name="length">Use when want to check drive at a middle, not at the end. Eg returns true if s is <c>@"C:\more"</c> and length is 2.</param>
        </member>
        <member name="M:Au.pathname._AddRemoveSep(System.String)">
            <summary>
            Ensures that s either ends with a valid drive path (eg <c>@"C:\"</c> but not "C:") or does not end with <c>'\\'</c> or <c>'/'</c> (unless would become empty if removed).
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)">
            <summary>
            Makes normal full path from path that can contain special substrings etc.
            </summary>
            <param name="path">Any path.</param>
            <param name="defaultParentDirectory">If path is not full path, combine it with defaultParentDirectory to make full path.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">path is not full path, and <i>defaultParentDirectory</i> is not used or does not make it full path.</exception>
            <remarks>
            The sequence of actions:
            1. If path starts with '%' character, expands environment variables and special folder names. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            2. If path is not full path but looks like URL, and used flag CanBeUrl, returns path.
            3. If path is not full path, and defaultParentDirectory is not null/"", combines path with Expand(defaultParentDirectory).
            4. If path is not full path, throws exception.
            5. Calls API <msdn>GetFullPathName</msdn>. It replaces <c>'/'</c> with <c>'\\'</c>, replaces multiple <c>'\\'</c> with single (where need), processes <c>@"\.."</c> etc, trims spaces, etc.
            6. If no flag DontExpandDosPath, if path looks like a short DOS path version (contains <c>'~'</c> etc), calls API <msdn>GetLongPathName</msdn>. It converts short DOS path to normal path, if possible, for example <c>@"c:\progra~1"</c> to <c>@"c:\program files"</c>. It is slow. It converts path only if the file exists.
            7. If no flag DontRemoveEndSeparator, removes <c>'\\'</c> character at the end, unless it is like <c>@"C:\"</c>.
            8. Appends <c>'\\'</c> character if ends with a drive name (eg <c>"C:"</c> -> <c>@"C:\"</c>).
            9. If no flag DontPrefixLongPath, calls <see cref="M:Au.pathname.prefixLongPathIfNeed(System.String)"/>, which adds <c>@"\\?\"</c> etc prefix if path is very long.
            
            Similar to <see cref="M:System.IO.Path.GetFullPath(System.String)"/>. Main differences: this function expands environment variables, does not support relative paths, trims <c>'\\'</c> at the end if need.
            </remarks>
        </member>
        <member name="M:Au.pathname.Normalize_(System.String,Au.Types.PNFlags,System.Boolean)">
            <summary>
            Same as <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/>, but skips full-path checking.
            s should be full path. If not full and not null/"", combines with current directory.
            </summary>
        </member>
        <member name="M:Au.pathname.NormalizeMinimally_(System.String,System.Boolean)">
            <summary>
            Prepares path for passing to API that support "..", DOS path etc.
            Calls Expand, _AddRemoveSep, PrefixLongPathIfNeed. Optionally throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path (only if throwIfNotFullPath is true).</exception>
        </member>
        <member name="M:Au.pathname.NormalizeForNET_(System.String)">
            <summary>
            Prepares path for passing to .NET file functions.
            Calls Expand, _AddRemoveSep. Throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.pathname.ExpandDosPath_(System.String)">
            <summary>
            Calls API GetLongPathName.
            Does not check whether s contains '~' character etc. Note: the API is slow.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.IsPossiblyDos_(System.String)">
            <summary>
            Returns true if pathOrFilename looks like a DOS filename or path.
            Examples: <c>"abcde~12"</c>, <c>"abcde~12.txt"</c>, <c>@"c:\path\abcde~12.txt"</c>, <c>"c:\abcde~12\path"</c>.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.IsShellPath_(System.String)">
            <summary>
            Returns true if starts with "::".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.IsShellPathOrUrl_(System.String)">
            <summary>
            Returns true if <c>IsShellPath_(s) || isUrl(s)</c>.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.prefixLongPath(System.String)">
            <summary>
            If path is full path (see <see cref="M:Au.pathname.isFullPath(System.String,System.Boolean)"/>) and does not start with <c>@"\\?\"</c>, prepends <c>@"\\?\"</c>.
            If path is network path (like <c>@"\\computer\folder\..."</c>), makes like <c>@"\\?\UNC\computer\folder\..."</c>.
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
            <remarks>
            Windows API kernel functions support extended-length paths, ie longer than 259 characters. But the path must have this prefix. Windows API shell functions don't support it.
            </remarks>
        </member>
        <member name="M:Au.pathname.prefixLongPathIfNeed(System.String)">
            <summary>
            Calls <see cref="M:Au.pathname.prefixLongPath(System.String)"/> if path is longer than <see cref="F:Au.pathname.maxDirectoryPathLength"/> (247).
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
        </member>
        <member name="M:Au.pathname.unprefixLongPath(System.String)">
            <summary>
            If path starts with <c>@"\\?\"</c> prefix, removes it.
            If path starts with <c>@"\\?\UNC\"</c> prefix, removes <c>@"?\UNC\"</c>.
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
        </member>
        <member name="M:Au.pathname._GetPrefixLength(System.String)">
            <summary>
            If s starts with <c>@"\\?\UNC\"</c>, returns 8.
            Else if starts with <c>@"\\?\"</c>, returns 4.
            Else returns 0.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="F:Au.pathname.maxFilePathLength">
            <summary>
            Maximal file (not directory) path length supported by all functions (native, .NET and this library).
            For longer paths need <c>@"\\?\"</c> prefix. It is supported by: most native kernel API (but not shell API), most functions of this library, some .NET functions.
            </summary>
        </member>
        <member name="F:Au.pathname.maxDirectoryPathLength">
            <summary>
            Maximal directory path length supported by all functions (native, .NET and this library).
            For longer paths need <c>@"\\?\"</c> prefix. It is supported by: most native kernel API (but not shell API), most functions of this library, some .NET functions.
            </summary>
        </member>
        <member name="M:Au.pathname.correctName(System.String,System.String)">
            <summary>
            Replaces characters that cannot be used in file names.
            </summary>
            <param name="name">Initial filename.</param>
            <param name="invalidCharReplacement">A string that will replace each invalid character. Default <c>"-"</c>.</param>
            <remarks>
            Also corrects other forms of invalid or problematic filename: trims spaces and other blank characters; replaces <c>"."</c> at the end; prepends <c>"@"</c> if a reserved name like <c>"CON"</c> or <c>"CON.txt"</c>; returns <c>"-"</c> if name is null/empty/whitespace.
            Usually returns valid filename, however it can be too long (itself or when combined with a directory path).
            </remarks>
        </member>
        <member name="M:Au.pathname.isInvalidName(System.String)">
            <summary>
            Returns true if name cannot be used for a file name, eg contains <c>'\\'</c> etc characters or is empty.
            More info: <see cref="M:Au.pathname.correctName(System.String,System.String)"/>.
            </summary>
            <param name="name">Any string. Example: "name.txt". Can be null.</param>
        </member>
        <member name="M:Au.pathname.getName(System.String)">
            <summary>
            Gets filename from path. Does not remove extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})"/>. Some differences: if ends with <c>'\\'</c> or <c>'/'</c>, gets part before it, eg <c>"B"</c> from <c>@"C:\A\B\"</c>.
            
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Also supports URL and shell parsing names like <c>@"::{CLSID-1}\0\::{CLSID-2}"</c>.
            
            Examples:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>"file.txt"</c>
            | <c>"file.txt"</c> | <c>"file.txt"</c>
            | <c>"file"</c> | <c>"file"</c>
            | <c>@"C:\A\B"</c> | <c>"B"</c>
            | <c>@"C:\A\B\"</c> | <c>"B"</c>
            | <c>@"C:\A\/B\/"</c> | <c>"B"</c>
            | <c>@"C:\"</c> | <c>""</c>
            | <c>@"C:"</c> | <c>""</c>
            | <c>@"\\network\share"</c> | <c>"share"</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"file.txt:alt.stream"</c>
            | <c>"http://a.b.c"</c> | <c>"a.b.c"</c>
            | <c>"::{A}\::{B}"</c> | <c>"::{B}"</c>
            | <c>""</c> | <c>""</c>
            | <c>null</c> | <c>null</c>
            </remarks>
        </member>
        <member name="M:Au.pathname.getNameNoExt(System.String)">
            <summary>
            Gets filename without extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename (then just removes extension). Can be null.</param>
            <remarks>
            The same as <see cref="M:Au.pathname.getName(System.String)"/>, just removes extension.
            Similar to <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})"/>. Some differences: if ends with <c>'\\'</c> or <c>'/'</c>, gets part before it, eg <c>"B"</c> from <c>@"C:\A\B\"</c>.
            
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Also supports URL and shell parsing names like <c>@"::{CLSID-1}\0\::{CLSID-2}"</c>.
            
            Examples:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>"file"</c>
            | <c>"file.txt"</c> | <c>"file"</c>
            | <c>"file"</c> | <c>"file"</c>
            | <c>@"C:\A\B"</c> | <c>"B"</c>
            | <c>@"C:\A\B\"</c> | <c>"B"</c>
            | <c>@"C:\A\B.B\"</c> | <c>"B.B"</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"file.txt:alt"</c>
            | <c>"http://a.b.c"</c> | <c>"a.b"</c>
            </remarks>
        </member>
        <member name="M:Au.pathname.getExtension(System.String)">
            <summary>
            Gets filename extension, like <c>".txt"</c>.
            Returns "" if there is no extension.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.getExtension(System.String,System.String@)">
            <summary>
            Gets filename extension and path part without the extension.
            More info: <see cref="M:Au.pathname.getExtension(System.String)"/>.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="pathWithoutExtension">Receives path part without the extension. Can be the same variable as path.</param>
        </member>
        <member name="M:Au.pathname.findExtension(System.String)">
            <summary>
            Finds filename extension, like <c>".txt"</c>.
            Returns '.' character index, or -1 if there is no extension.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Returns -1 if <c>'.'</c> is before <c>'\\'</c> or <c>'/'</c>.
            </remarks>
        </member>
        <member name="M:Au.pathname.getDirectory(System.String,System.Boolean)">
            <summary>
            Removes filename part from path.
            By default also removes separator (<c>'\\'</c> or <c>'/'</c>) if it is not after drive name (eg <c>"C:"</c>).
            Returns "" if the string is a filename.
            Returns null if the string is null or a root (like <c>@"C:\"</c> or <c>"C:"</c> or <c>@"\\server\share"</c> or <c>"http:"</c>).
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="withSeparator">Don't remove separator character(s) (<c>'\\'</c> or <c>'/'</c>). See examples.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})"/>. Some differences: skips <c>'\\'</c> or <c>'/'</c> at the end (eg from <c>@"C:\A\B\"</c> gets <c>@"C:\A"</c>, not <c>@"C:\A\B"</c>); does not replace / with \.
            
            Parses raw string. You may want to <see cref="M:Au.pathname.normalize(System.String,System.String,Au.Types.PNFlags)"/> it at first.
            
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Also supports URL and shell parsing names like <c>@"::{CLSID-1}\0\::{CLSID-2}"</c>.
            
            Examples:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>@"C:\A\B"</c>
            | <c>"file.txt"</c> | <c>""</c>
            | <c>@"C:\A\B\"</c> | <c>@"C:\A"</c>
            | <c>@"C:\A\/B\/"</c> | <c>@"C:\A"</c>
            | <c>@"C:\"</c> | <c>null</c>
            | <c>@"\\network\share"</c> | <c>null</c>
            | <c>"http:"</c> | <c>null</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"C:\aa"</c>
            | <c>"http://a.b.c"</c> | <c>"http:"</c>
            | <c>"::{A}\::{B}"</c> | <c>"::{A}"</c>
            | <c>""</c> | <c>""</c>
            | <c>null</c> | <c>null</c>
            
            Examples when <i>withSeparator</i> true:
            
            | path | result
            | - | -
            | <c>@"C:\A\B"</c> | <c>@"C:\A\"</c> (not <c>@"C:\A"</c>)
            | <c>"http://x.y"</c> | <c>"http://"</c> (not <c>"http:"</c>)
            </remarks>
        </member>
        <member name="M:Au.pathname.IsExtension_(System.String)">
            <summary>
            Returns true if s is like <c>".ext"</c> and the ext part does not contain characters <c>.\\/:</c>.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.IsProtocol_(System.String)">
            <summary>
            Returns true if s is like "protocol:" and not like "c:" or "protocol:more".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.pathname.makeUnique(System.String,System.Boolean)">
            <summary>
            Gets path with unique filename for a new file or directory. 
            If the specified path is of an existing file or directory, returns path where the filename part is modified like "file 2.txt", "file 3.txt" etc. Else returns unchanged path.
            </summary>
            <param name="path">Suggested full path.</param>
            <param name="isDirectory">The path is for a directory. The number is always appended at the very end, not before .extension.</param>
        </member>
        <member name="T:Au.shortcutFile">
            <summary>
            Creates shell shortcuts (.lnk files) and gets shortcut properties.
            </summary>
        </member>
        <member name="M:Au.shortcutFile.Dispose">
            <summary>
            Releases internally used COM objects (IShellLink, IPersistFile).
            </summary>
        </member>
        <member name="P:Au.shortcutFile.IShellLink">
            <summary>
            Returns the internally used IShellLink COM interface.
            </summary>
        </member>
        <member name="M:Au.shortcutFile.open(System.String)">
            <summary>
            Opens a shortcut file (.lnk) for getting shortcut properties.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open .lnk file.</exception>
        </member>
        <member name="M:Au.shortcutFile.create(System.String)">
            <summary>
            Creates a new <see cref="T:Au.shortcutFile"/> instance that can be used to create or replace a shortcut file.
            You can set properties and finally call <see cref="M:Au.shortcutFile.Save"/>.
            If the shortcut file already exists, <b>Save</b> replaces it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
        </member>
        <member name="M:Au.shortcutFile.openOrCreate(System.String)">
            <summary>
            Creates a new <see cref="T:Au.shortcutFile"/> instance that can be used to create or modify a shortcut file.
            Exception if file exists but cannot open it for read-write access.
            You can get and set properties and finally call <see cref="M:Au.shortcutFile.Save"/>.
            If the shortcut file already exists, <b>Save</b> updates it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open existing .lnk file.</exception>
        </member>
        <member name="M:Au.shortcutFile.Save">
            <summary>
            Saves to the shortcut file (.lnk).
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to save.</exception>
            <remarks>
            Creates parent folder if need.
            </remarks>
        </member>
        <member name="P:Au.shortcutFile.TargetPath">
            <summary>
            Gets or sets shortcut target path.
            This property is null if target isn't a file system object, eg Control Panel or URL.
            </summary>
            <remarks>The 'get' function gets path with expanded environment variables. If possible, it corrects the target of MSI shortcuts and 64-bit Program Files shortcuts where IShellLink.GetPath() lies.</remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
            <exception cref="T:System.ArgumentException">The 'set' function allows max length 259.</exception>
        </member>
        <member name="P:Au.shortcutFile.TargetPathRawMSI">
            <summary>
            Gets shortcut target path and does not correct wrong MSI shortcut target.
            </summary>
        </member>
        <member name="P:Au.shortcutFile.TargetPidl">
            <summary>
            Gets or sets a non-file-system target (eg Control Panel) through its ITEMIDLIST.
            </summary>
            <remarks>
            Also can be used for any target type, but gets raw value, for example MSI shortcut target is incorrect.
            Most but not all shortcuts have this property; the 'get' function returns null if the shortcut does not have it.
            </remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.shortcutFile.TargetURL">
            <summary>
            Gets or sets a URL target.
            Note: it is a .lnk shortcut, not a .url shortcut.
            The 'get' function returns string "file:///..." if target is a file.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.shortcutFile.TargetAnyType">
            <summary>
            Gets or sets target of any type - file/folder, URL, virtual shell object (see <see cref="T:Au.Types.Pidl"/>).
            The string can be used with <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.shortcutFile.GetIconLocation(System.Int32@)">
            <summary>
            Gets custom icon file path and icon index.
            Returns null if the shortcut does not have a custom icon (then you see its target icon).
            </summary>
            <param name="iconIndex">Receives 0 or icon index or negative icon resource id.</param>
        </member>
        <member name="M:Au.shortcutFile.SetIconLocation(System.String,System.Int32)">
            <summary>
            Sets icon file path and icon index.
            </summary>
            <param name="path"></param>
            <param name="iconIndex">0 or icon index or negative icon resource id.</param>
            <exception cref="T:Au.Types.AuException"/>
            <exception cref="T:System.ArgumentException">Max length 259.</exception>
        </member>
        <member name="P:Au.shortcutFile.WorkingDirectory">
            <summary>
            Gets or sets the working directory path (Start in).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
            <exception cref="T:System.ArgumentException">The 'set' function allows max length 259.</exception>
        </member>
        <member name="M:Au.shortcutFile._Max259(System.String)">
            <summary>
            Throws if s longer than 259.
            SetPath then would throw without error description. SetIconLocation would limit to 260. SetWorkingDirectory and SetDescription succeed but corrupt the .lnk file. SetArguments OK. Others not tested, rare, never mind.
            </summary>
        </member>
        <member name="P:Au.shortcutFile.Arguments">
            <summary>
            Gets or sets the command-line arguments.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.shortcutFile.Description">
            <summary>
            Gets or sets the description text (Comment).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
            <exception cref="T:System.ArgumentException">The 'set' function allows max length 259.</exception>
        </member>
        <member name="P:Au.shortcutFile.Hotkey">
            <summary>
            Gets or sets hotkey.
            Example: <c>x.Hotkey = Keys.Control | Keys.Alt | Keys.E;</c>
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.shortcutFile.ShowState">
            <summary>
            Gets or sets the window show state.
            The value can be 1 (normal, default), 2 (minimized) or 3 (maximized).
            Most programs ignore it.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.shortcutFile.getTarget(System.String)">
            <summary>
            Gets shortcut target path or URL or virtual shell object ITEMIDLIST.
            Uses <see cref="M:Au.shortcutFile.open(System.String)"/> and <see cref="P:Au.shortcutFile.TargetAnyType"/>.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="M:Au.shortcutFile.delete(System.String)">
            <summary>
            If shortcut file exists, unregisters its hotkey and deletes it.
            </summary>
            <param name="lnkPath">.lnk file path.</param>
            <exception cref="T:Au.Types.AuException">Failed to unregister hotkey.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.filesystem.delete(System.String,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.shortcutFile._UnregisterHotkey(System.String)">
            <exception cref="T:Au.Types.AuException">Failed to open or save.</exception>
        </member>
        <member name="T:Au.sqlite">
            <summary>
            A SQLite database connection.
            Creates/opens/closes database file or in-memory database. Executes SQL, etc.
            </summary>
            <remarks>
            This class wraps a SQLite API object sqlite3* and related sqlite3_x functions. They are documented perfectly in the SQLite website.
            Uses this unmanaged dll: folders.ThisApp + @"64\sqlite3.dll". In 32-bit process - "32" instead of "64".
            
            To correctly close the database file, at first need to dipose all child objects, such as <see cref="T:Au.sqliteStatement"/>, then dispose the <b>sqlite</b> object. To dispose a static <b>ASlite</b> variable, you may want to use <see cref="E:Au.process.thisProcessExit"/> event. Although this class has a finalizer that disposes the object (closes database), you should always dispose explicitly. Finalizers don't run on process exit.
            </remarks>
            <seealso cref="T:Au.sqliteStatement"/>
            <example>
            <code><![CDATA[
            //open database file
            using var db = new sqlite(@"Q:\test\sqlite.db");
            //create table
            db.Execute("CREATE TABLE IF NOT EXISTS test(id INTEGER PRIMARY KEY, name TEXT, x INT, guid BLOB, array BLOB)");
            
            //add 2 rows of data
            using(var trans = db.Transaction()) { //optional, but makes much faster when making multiple changes, and ensures that all or none of these changes are written to the database
            	using(var p = db.Statement("INSERT OR REPLACE INTO test VALUES(?, ?, :x, ?, ?)")) {
            		//assume we want to add values of these variables to the database table
            		int id = 1; string name = "TEXT"; long x = -10; Guid guid = Guid.NewGuid(); int[] arr = new int[] { 1, 2, 3 };
            		//add first row
            		p.Bind(1, id);
            		p.Bind(2, name).BindStruct(4, guid).Bind(5, arr);
            		p.Bind(":x", x);
            		p.Step();
            		//add second row
            		p.Reset().Bind(1, 2).Bind(":x", 123456789012345).Step(); //unbound columns are null
            	}
            	//update single row
            	db.Execute("UPDATE test SET name=?2 WHERE id=?1", 2, "two");
            	//write all this to database
            	trans.Commit();
            }
            
            //get data
            using(var p = db.Statement("SELECT * FROM test")) {
            	while(p.Step()) { //for each row of results
            		print.it(p.GetInt(0), p.GetText(1), p.GetLong(2));
            		print.it(p.GetStruct<Guid>("guid"));
            		print.it(p.GetArray<int>("array"));
            		print.it("----");
            	}
            }
            //get single value
            if(db.Get(out string s1, "SELECT name FROM test WHERE id=?", 1)) print.it(s1); else print.it("not found");
            if(db.Get(out int i1, "PRAGMA page_size")) print.it(i1);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.sqlite.#ctor(System.String,Au.Types.SLFlags,System.String)">
            <summary>
            Opens or creates a database file.
            </summary>
            <param name="file">
            Database file. Can be:
            - Full path. Supports environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>
            - ":memory:" - create a private, temporary in-memory database.
            - "" - create a private, temporary on-disk database.
            - Starts with "file:" - see <google>sqlite3_open_v2</google>.
            </param>
            <param name="flags"><google>sqlite3_open_v2</google> flags. Default: read-write, create file if does not exist (and parent directory).</param>
            <param name="sql">
            SQL to execute. For example, one or more ;-separated PRAGMA statements to configure the database connection. Or even "CREATE TABLE IF NOT EXISTS ...".
            This function also always executes "PRAGMA foreign_keys=ON;PRAGMA secure_delete=ON;".
            </param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.SLException">Failed to open database or execute sql.</exception>
            <remarks>
            Calls <google>sqlite3_open_v2</google>.
            <note>If a variable of this class is used by multiple threads, use <c>lock(variable) {  }</c> where need.</note>
            </remarks>
        </member>
        <member name="M:Au.sqlite.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.sqlite.Dispose">
            <summary>
            Calls sqlite3_close_v2.
            If fails, writes warning to the output.
            </summary>
        </member>
        <member name="M:Au.sqlite.Finalize">
            
        </member>
        <member name="M:Au.sqlite.op_Implicit(Au.sqlite)~System.IntPtr">
            <summary>sqlite3*</summary>
        </member>
        <member name="P:Au.sqlite.Handle">
            <summary>sqlite3*</summary>
        </member>
        <member name="M:Au.sqlite.Execute(System.String)">
            <summary>
            Calls sqlite3_exec to execute one or more SQL statements that don't return data.
            </summary>
            <param name="sql">SQL statement, or several ;-separated statements.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.sqlite.Execute(System.String,System.Object[])">
            <summary>
            Executes single SQL statement that does not return data. Binds values.
            </summary>
            <param name="sql">Single SQL statement.</param>
            <param name="bind">
            Values that will replace <c>?</c> characters in sql.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.sqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.sqlite"/>.
            </param>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Statement(System.String)">
            <summary>
            Returns <c>new Statement(this, sql)</c>.
            </summary>
            <param name="sql">Single SQL statement. This function does not execute it.</param>
            <seealso cref="T:Au.sqliteStatement"/>
        </member>
        <member name="M:Au.sqlite.Statement(System.String,System.Object[])">
            <summary>
            Returns <c>new Statement(this, sql).BindAll(bind)</c>.
            </summary>
            <param name="sql">Single SQL statement. This function does not execute it.</param>
            <param name="bind">
            Values that will replace <c>?</c> characters in sql. Optional.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.sqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.sqlite"/>.
            </param>
            <seealso cref="T:Au.sqliteStatement"/>
            <seealso cref="M:Au.sqliteStatement.BindAll(System.Object[])"/>
        </member>
        <member name="M:Au.sqlite.Get(System.Int32@,System.String,System.Object[])">
            <summary>
            Executes single SQL statement and gets single value.
            Returns false if the statement returned no data.
            </summary>
            <param name="value">Receives data.</param>
            <param name="sql">SQL statement.</param>
            <param name="bind">
            Values that will replace <c>?</c> characters in sql.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.sqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.sqlite"/>.
            </param>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
            <remarks>
            The Get(out int, ...) overload also can be used to get uint, short, ushort, byte, sbyte, enum. Will need to cast from int.
            The Get(out long, ...) overload also can be used to get ulong, 64-bit enum, maybe DateTime.
            The Get(out double, ...) overload also can be used to get float.
            Use <see cref="M:Au.sqlite.GetStruct``1(``0@,System.String,System.Object[])"/> for other value types - decimal, Guid, Rect, etc.
            </remarks>
        </member>
        <member name="M:Au.sqlite.Get(System.Int64@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Get(System.Boolean@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Get(System.Double@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Get(System.String@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Get``1(``0[]@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Get``1(System.Collections.Generic.List{``0}@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.GetStruct``1(``0@,System.String,System.Object[])">
            <summary>See <see cref="M:Au.sqlite.Get(System.Int32@,System.String,System.Object[])"/>.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqlite.Any(System.String,System.Object[])">
            <summary>
            Executes single SQL statement and returns true if it returns at least one row of data.
            More info: <see cref="M:Au.sqlite.Get(System.Int32@,System.String,System.Object[])"/>.
            </summary>
            <remarks>This function is similar to the <b>GetX</b> functions, but it does not retrieve the data.</remarks>
        </member>
        <member name="P:Au.sqlite.LastInsertRowid">
            <summary>
            sqlite3_last_insert_rowid.
            </summary>
        </member>
        <member name="P:Au.sqlite.Changes">
            <summary>
            sqlite3_changes.
            </summary>
        </member>
        <member name="P:Au.sqlite.IsInTransaction">
            <summary>
            0 == sqlite3_get_autocommit.
            </summary>
        </member>
        <member name="M:Au.sqlite.Transaction(System.String,System.String)">
            <summary>
            Returns <c>new SLTransaction(this, sql, sqlOfDispose)</c>.
            See <see cref="M:Au.Types.SLTransaction.#ctor(Au.sqlite,System.String,System.String)"/>.
            </summary>
            <param name="sql">SQL to execute now. Default "BEGIN".</param>
            <param name="sqlOfDispose">SQL to execute when disposing the <b>SLTransaction</b> variable. Default "ROLLBACK".</param>
        </member>
        <member name="M:Au.sqlite.TableExists(System.String)">
            <summary>
            Returns true if the table exists.
            </summary>
            <param name="table">Table name.</param>
            <remarks>
            This function is slower than "CREATE TABLE IF NOT EXISTS...".
            </remarks>
        </member>
        <member name="P:Au.sqlite.IsUtf16">
            <summary>
            Returns true if default database text encoding is not UTF-8.
            </summary>
        </member>
        <member name="T:Au.sqliteStatement">
            <summary>
            Creates and executes a SQLite prepared statement.
            </summary>
            <remarks>
            This class wraps a SQLite API object sqlite3_stmt* and related sqlite3_x functions. They are documented perfectly in the SQLite website.
            More info and example: <see cref="T:Au.sqlite"/>.
            <note type="important">A variable of this class can be used by multiple threads, but not simultaneously. Use <c>lock(database) {  }</c> where need.</note>
            </remarks>
        </member>
        <member name="M:Au.sqliteStatement.#ctor(Au.sqlite,System.String,System.Boolean)">
            <summary>
            Calls sqlite3_prepare16_v3.
            </summary>
            <param name="db"></param>
            <param name="sql">Single SQL statement.</param>
            <param name="persistent">Use flag SQLITE_PREPARE_PERSISTENT.</param>
            <exception cref="T:System.ArgumentNullException">db is null.</exception>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.sqliteStatement.Dispose">
            <summary>
            Calls sqlite3_finalize.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.Finalize">
            
        </member>
        <member name="M:Au.sqliteStatement.op_Implicit(Au.sqliteStatement)~System.IntPtr">
            <summary>sqlite3_stmt*</summary>
        </member>
        <member name="P:Au.sqliteStatement.Handle">
            <summary>sqlite3_stmt*</summary>
        </member>
        <member name="P:Au.sqliteStatement.DB">
            
        </member>
        <member name="M:Au.sqliteStatement.Step">
            <summary>
            Calls sqlite3_step.
            Returns true if results data available (sqlite3_step returned SQLITE_ROW).
            </summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Reset(System.Boolean,System.Boolean)">
            <summary>
            Calls sqlite3_reset and/or sqlite3_clear_bindings. Returns this.
            </summary>
            <param name="resetStatement">Call sqlite3_reset. Default true.</param>
            <param name="clearBindings">Call sqlite3_clear_bindings. Default true.</param>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.Int32)">
            <summary>Calls sqlite3_bind_int. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.UInt32)">
            <summary>Calls sqlite3_bind_int. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.Int64)">
            <summary>Calls sqlite3_bind_int64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.UInt64)">
            <summary>Calls sqlite3_bind_int64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.Boolean)">
            <summary>Calls sqlite3_bind_int(value ? 1 : 0). Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind``1(Au.Types.SLIndexOrName,``0)">
            <summary>Binds an enum value as int or long. Calls sqlite3_bind_int or sqlite3_bind_int64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.Double)">
            <summary>Calls sqlite3_bind_double. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.String)">
            <summary>Calls sqlite3_bind_text16. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.Void*,System.Int64)">
            <summary>Calls sqlite3_bind_blob64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind(Au.Types.SLIndexOrName,System.ReadOnlySpan{System.Byte})">
            <summary>Calls sqlite3_bind_blob64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind``1(Au.Types.SLIndexOrName,``0[])">
            <summary>Calls sqlite3_bind_blob64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.Bind``1(Au.Types.SLIndexOrName,System.Collections.Generic.List{``0})">
            <summary>Calls sqlite3_bind_blob64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.sqliteStatement.BindStruct``1(Au.Types.SLIndexOrName,``0)">
            <summary>Binds a value as blob. Calls sqlite3_bind_blob64. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>Can be any value type that does not contain fields of reference types. Examples: Guid, Point, int, decimal.</remarks>
        </member>
        <member name="M:Au.sqliteStatement.BindNull(Au.Types.SLIndexOrName)">
            <summary>Calls sqlite3_bind_null. Returns this.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>Usually don't need to call this function. Unset parameter values are null. The Bind(string/void*/ReadOnlySpan/Array/List) functions set null too if the value is null.</remarks>
        </member>
        <member name="M:Au.sqliteStatement.BindObject(System.Int32,System.Object)">
            <summary>
            Used by <see cref="M:Au.sqliteStatement.BindAll(System.Object[])"/>.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.BindAll(System.Object[])">
            <summary>
            Binds multiple values of any supported types.
            Returns this.
            </summary>
            <param name="values">
            Values that will replace <c>?</c> characters in sql.
            Read about SQL parameters in SQLite website. Example: <see cref="T:Au.sqlite"/>.
            Supported types:
            - int, uint, byte, sbyte, short, ushort - calls sqlite3_bind_int.
            - bool - calls sqlite3_bind_int(true?1:0).
            - long, ulong - calls sqlite3_bind_int64.
            - double, float - calls sqlite3_bind_double.
            - string - calls sqlite3_bind_text16.
            - decimal - calls sqlite3_bind_blob64.
            - Guid - calls sqlite3_bind_blob64.
            - byte[] - calls sqlite3_bind_blob64.
            - An enum type - calls sqlite3_bind_int or sqlite3_bind_int64.
            </param>
            <exception cref="T:System.NotSupportedException">A value is of an unsupported type.</exception>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>
            For each parameter calls a <b>sqlite3_bind_x</b> function depending on type. Uses index 1, 2 and so on.
            This function is an alternative to calling <b>BindX</b> functions for each parameter. However it supports less types and adds boxing overhead.
            Does not call sqlite3_reset and sqlite3_clear_bindings. If need, call <see cref="M:Au.sqliteStatement.Reset(System.Boolean,System.Boolean)"/> before.
            </remarks>
        </member>
        <member name="M:Au.sqliteStatement.GetInt(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int(column)</c>.
            </summary>
            <remarks>
            Use this function to get integer values of size 4, 2 or 1 bytes: int, uint, short, ushort, byte, sbyte, enum.
            </remarks>
        </member>
        <member name="M:Au.sqliteStatement.GetLong(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int64(column)</c>.
            </summary>
            <remarks>
            Use this function to get integer values of size 8 bytes: long, ulong, 64-bit enum, maybe DateTime.
            </remarks>
        </member>
        <member name="M:Au.sqliteStatement.GetBool(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int64(column) != 0</c>.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.GetDouble(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_double(column)</c>.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.GetText(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_text(column)</c> as string.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.GetBlob(Au.Types.SLIndexOrName,System.Int32@)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> and gets blob size.
            </summary>
            <param name="column"></param>
            <param name="nBytes">Blob size.</param>
        </member>
        <member name="M:Au.sqliteStatement.GetArray``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as array.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.GetList``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as List.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.GetStruct``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as a variable of any value type that does not have fields of reference types.
            </summary>
        </member>
        <member name="P:Au.sqliteStatement.ColumnCount">
            <summary>
            sqlite3_column_count.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.ColumnName(System.Int32)">
            <summary>
            sqlite3_column_name.
            </summary>
        </member>
        <member name="M:Au.sqliteStatement.ColumnIndex(System.String)">
            <summary>
            Finds column by name in results.
            Returns 0-based index, or -1 if not found.
            </summary>
            <param name="name">Column name in results, as returned by sqlite3_column_name. Case-sensitive.</param>
        </member>
        <member name="M:Au.sqliteStatement._WarnGet(System.String)">
            <summary>
            Called by GetX functions when sqlite3_column_x returns null/0.
            Shows warning if sqlite3_errcode is not 0 or Row.
            Does not throw exception because it is not thread-safe.
            </summary>
        </member>
        <member name="T:Au.dialog">
            <summary>
            Standard dialogs to show information or get user input.
            </summary>
            <remarks>
            You can use static functions (less code) or create class instances (more options).
            More info: <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            
            Uses task dialog API <msdn>TaskDialogIndirect</msdn>.
            
            Cannot be used in services. Instead use <b>MessageBox.Show</b> with option ServiceNotification or DefaultDesktopOnly, or API <msdn>MessageBox</msdn> with corresponding flags.
            </remarks>
            <example>
            Simple examples.
            <code><![CDATA[
            dialog.show("Info");
            
            string s = "More info.";
            dialog.showInfo("Info", s);
            
            if(!dialog.showYesNo("Continue?", "More info.")) return;
            
            switch(dialog.show("Save?", "More info.", "1 Save|2 Don't Save|0 Cancel")) {
            case 1: print.it("save"); break;
            case 2: print.it("don't"); break;
            default: print.it("cancel"); break;
            }
            
            if(!dialog.showInput(out string s, "Example")) return;
            print.it(s);
            ]]></code>
            
            This example creates a class instance, sets properties, shows dialog, uses events, uses result.
            <code><![CDATA[
            var d = new dialog();
            d.SetText("Main text.", "More text.\nSupports <A HREF=\"link data\">links</A> if you subscribe to HyperlinkClicked event.");
            d.SetButtons("1 OK|2 Cancel|3 Custom|4 Custom2");
            d.SetIcon(DIcon.Warning);
            d.SetExpandedText("Expanded info\nand more info.", true);
            d.CanBeMinimized = true;
            d.SetCheckbox("Check");
            d.SetRadioButtons("1 r1|2 r2");
            d.SetTimeout(30, "OK");
            d.HyperlinkClicked += e => { dialog.show("link clicked", e.LinkHref, owner: e.hwnd); };
            d.ButtonClicked += e => { print.it(e.Button); if(e.Button == 4) e.DontCloseDialog = true; };
            d.ProgressBar = true; d.Timer += e => { e.d.Send.Progress(e.TimerTimeMS / 100); };
            var r = d.ShowDialog();
            print.it(r, d.Controls.IsChecked, d.Controls.RadioId);
            switch(r) { case 1: print.it("OK"); break; case dialog.Timeout: print.it("timeout"); break; }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.dialog.options">
            <summary>
            Default options used by <see cref="T:Au.dialog"/> class functions.
            </summary>
        </member>
        <member name="P:Au.dialog.options.defaultTitle">
            <summary>
            Default title bar text.
            Default value - <see cref="P:Au.script.name"/>. In exe it is exe file name like "Example.exe".
            </summary>
        </member>
        <member name="P:Au.dialog.options.rtlLayout">
            <summary>
            Right-to-left layout.
            </summary>
            <seealso cref="P:Au.dialog.RtlLayout"/>
        </member>
        <member name="P:Au.dialog.options.topmostIfNoOwnerWindow">
            <summary>
            If there is no owner window, let the dialog be always on top of most other windows.
            Default true.
            </summary>
            <seealso cref="P:Au.dialog.Topmost"/>
        </member>
        <member name="P:Au.dialog.options.defaultScreen">
            <summary>
            Show dialogs on this screen when screen is not explicitly specified (<see cref="P:Au.dialog.Screen"/>) and there is no owner window.
            The <b>screen</b> must be lazy or empty.
            </summary>
            <exception cref="T:System.ArgumentException"><b>screen</b> with <b>Handle</b>. Must be lazy or empty.</exception>
            <example>
            <code><![CDATA[
            dialog.options.defaultScreen = screen.index(1, lazy: true);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.dialog.options.useAppIcon">
            <summary>
            If icon not specified, use <see cref="F:Au.Types.DIcon.App"/>.
            </summary>
        </member>
        <member name="P:Au.dialog.options.autoOwnerWindow">
            <summary>
            If owner window not specified, use the active window of current thread as owner window (disable it, etc).
            </summary>
            <seealso cref="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.dialog.#ctor(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Initializes a new <see cref="T:Au.dialog"/> instance and sets main properties.
            Parameters etc are of <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
        </member>
        <member name="M:Au.dialog.SetTitleBarText(System.String)">
            <summary>
            Changes title bar text.
            If you don't call this method or title is null or "", dialogs will use <see cref="P:Au.dialog.options.defaultTitle"/>.
            </summary>
        </member>
        <member name="M:Au.dialog.SetText(System.String,System.String)">
            <summary>
            Sets text.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
        </member>
        <member name="M:Au.dialog.SetIcon(Au.Types.DIcon)">
            <summary>
            Sets common icon. Or custom icom from app resources.
            </summary>
        </member>
        <member name="M:Au.dialog.SetIcon(System.Object)">
            <summary>
            Sets custom icon.
            </summary>
            <param name="icon">Icon of size 32 or 16 (or more if high DPI). Can be <see cref="T:Au.icon"/>, <b>Icon</b>, <b>IntPtr</b> (native icon handle), <b>Bitmap</b>.</param>
        </member>
        <member name="F:Au.dialog.Timeout">
            <summary>
            The return value of <b>ShowX</b> functions on timeout.
            </summary>
        </member>
        <member name="M:Au.dialog._Buttons.MarshalButtons(Au.dialog._Api.TASKDIALOGCONFIG@)">
            <summary>
            Sets c.pButtons, c.cButtons, c.pRadioButtons and c.cRadioButtons.
            Later call MarshalFreeButtons.
            </summary>
        </member>
        <member name="M:Au.dialog._Buttons.MarshalFreeButtons(Au.dialog._Api.TASKDIALOGCONFIG@)">
            <summary>
            Frees memory allocated by MarshalButtons and sets the c members to null/0.
            </summary>
        </member>
        <member name="M:Au.dialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)">
            <summary>
            Sets common and/or custom buttons and custom buttons style.
            </summary>
            <param name="buttons">
            Common and/or custom buttons, like with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            These ids should be negative if you use <i>customButtons</i> too, because ids of <i>customButtons</i> are 1, 2, ... .
            </param>
            <param name="asCommandLinks">Custom buttons style. If false - row of classic buttons. If true - column of command-link buttons that can have multiline text.</param>
            <param name="customButtons">
            Additional custom buttons. All will be custom, even if named "OK" etc.
            List of labels without ids. Can be string like "One|Two|..." or string[] or List&lt;string&gt;.
            Button ids will be 1, 2, ... .
            <see cref="P:Au.dialog.DefaultButton"/> will be 1. You can change it later.
            </param>
        </member>
        <member name="P:Au.dialog.DefaultButton">
            <summary>
            Specifies which button responds to the Enter key.
            If 0 or not set, auto-selects.
            </summary>
            <value>Button id.</value>
        </member>
        <member name="M:Au.dialog.SetRadioButtons(System.String,System.Int32)">
            <summary>
            Adds radio buttons.
            </summary>
            <param name="buttons">A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="defaultId">Check the radio button that has this id. If omitted or 0, checks the first. If negative, does not check.</param>
            <remarks>
            To get selected radio button id after closing the dialog, use <see cref="P:Au.dialog.Controls"/>.
            </remarks>
        </member>
        <member name="M:Au.dialog.SetCheckbox(System.String,System.Boolean)">
            <summary>
            Adds check box (if text is not null/empty).
            </summary>
            <remarks>
            To get check box state after closing the dialog, use <see cref="P:Au.dialog.Controls"/>.
            </remarks>
        </member>
        <member name="M:Au.dialog.SetExpandedText(System.String,System.Boolean)">
            <summary>
            Adds text that the user can show and hide.
            </summary>
            <param name="text">Text.</param>
            <param name="showInFooter">Show the text at the bottom of the dialog.</param>
        </member>
        <member name="M:Au.dialog.SetExpandControl(System.Boolean,System.String,System.String)">
            <summary>
            Set properties of the control that shows and hides text added by <see cref="M:Au.dialog.SetExpandedText(System.String,System.Boolean)"/>.
            </summary>
            <param name="defaultExpanded"></param>
            <param name="collapsedText"></param>
            <param name="expandedText"></param>
        </member>
        <member name="M:Au.dialog.SetFooter(System.String)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text, optionally preceded by an icon character and |, like "i|Text". Icons: x error, ! warning, i info, v shield, a app.</param>
        </member>
        <member name="M:Au.dialog.SetFooter(System.String,Au.Types.DIcon)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon"></param>
        </member>
        <member name="M:Au.dialog.SetFooter(System.String,System.Object)">
            <summary>
            Adds text and custom icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">Icon of size 16 (or more if high DPI). Can be <see cref="T:Au.icon"/>, <b>Icon</b>, <b>IntPtr</b> (native icon handle), <b>Bitmap</b>.</param>
        </member>
        <member name="M:Au.dialog.SetEditControl(Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds Edit or Combo control.
            </summary>
            <param name="editType">Control type/style.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="comboItems">Combo box items used when <i>editType</i> is Combo.</param>
            <remarks>
            To get control text after closing the dialog, use <see cref="P:Au.dialog.Controls"/>.
            
            Dialogs with an input field cannot have a progress bar.
            </remarks>
        </member>
        <member name="P:Au.dialog.Width">
            <summary>
            Sets the width of the dialog's client area.
            The actual width will depend on DPI (the Windows setting "scale" or "text size").
            If less than default width, will be used default width.
            </summary>
            <seealso cref="F:Au.Types.DFlags.Wider"/>
        </member>
        <member name="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)">
            <summary>
            Sets owner window.
            The owner window will be disabled, and this dialog will be on top of it.
            This window will be in owner's screen, if screen was not explicitly specified with the <see cref="P:Au.dialog.Screen"/> property. <see cref="P:Au.dialog.options.defaultScreen"/> is ignored.
            </summary>
            <param name="owner">Owner window, or one of its child/descendant controls. Can be Control (eg Form) or wnd (window handle). Can be null.</param>
            <param name="ownerCenter">Show the dialog in the center of the owner window. <see cref="M:Au.dialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and <see cref="P:Au.dialog.Screen"/> are ignored.</param>
            <param name="dontDisable">Don't disable the owner window. If false, disables if it belongs to this thread.</param>
            <seealso cref="P:Au.dialog.options.autoOwnerWindow"/>
        </member>
        <member name="M:Au.dialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Sets dialog position in screen.
            </summary>
            <param name="x">X position in <see cref="P:Au.dialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.dialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="rawXY">x y are relative to the primary screen (ignore <see cref="P:Au.dialog.Screen"/> etc).</param>
        </member>
        <member name="P:Au.dialog.Screen">
            <summary>
            Sets the screen (display monitor) where to show the dialog in multi-screen environment.
            If not set, will be used owner window's screen or <see cref="P:Au.dialog.options.defaultScreen"/>.
            More info: <see cref="T:Au.screen"/>, <see cref="M:Au.wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.dialog.SetTimeout(System.Int32,System.String,System.Boolean)">
            <summary>
            Let the dialog close itself after <i>closeAfterS</i> seconds. Then <see cref="M:Au.dialog.ShowDialog"/> returns <see cref="F:Au.dialog.Timeout"/>.
            Example: <c>d.SetTimeout(30, "OK");</c>
            </summary>
        </member>
        <member name="P:Au.dialog.RtlLayout">
            <summary>
            Right-to left layout.
            Default = <see cref="P:Au.dialog.options.rtlLayout"/>.
            </summary>
        </member>
        <member name="P:Au.dialog.CanBeMinimized">
            <summary>
            Add 'Minimize' button to the title bar.
            </summary>
        </member>
        <member name="P:Au.dialog.ProgressBar">
            <summary>
            Show progress bar.
            </summary>
        </member>
        <member name="P:Au.dialog.ProgressBarMarquee">
            <summary>
            Show progress bar that does not indicate which part of the work is already done.
            </summary>
        </member>
        <member name="P:Au.dialog.Topmost">
            <summary>
            Makes the dialog window topmost or non-topmost.
            If true, will set topmost style when creating the dialog. If false, will not set.
            If null (default), the dialog will be topmost if both these are true: no owner window, <see cref="P:Au.dialog.options.topmostIfNoOwnerWindow"/> is true (default).
            </summary>
        </member>
        <member name="M:Au.dialog.ShowDialog">
            <summary>
            Shows the dialog.
            Returns selected button id.
            Call this method after setting text and other properties.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="E:Au.dialog.Created">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.Destroyed">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.Timer">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.ButtonClicked">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.HyperlinkClicked">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.HelpF1">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.dialog.OtherEvents">
            <summary>
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="M:Au.dialog.ShowDialogNoWait">
            <summary>
            Shows the dialog in new thread and returns without waiting until it is closed.
            </summary>
            <remarks>
            Calls <see cref="M:Au.dialog.ThreadWaitForOpen"/>, therefore the dialog is already open when this function returns.
            More info: <see cref="M:Au.dialog.showNoWait(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="P:Au.dialog.Result">
            <summary>
            Selected button id. The same as the <see cref="M:Au.dialog.ShowDialog"/> return value.
            </summary>
            <remarks>
            If the result is still unavailable (the dialog still not closed):
            - If called from the same thread that called <see cref="M:Au.dialog.ShowDialog"/>, returns 0.
            - If called from another thread, waits until the dialog is closed.
            
            Note: <see cref="M:Au.dialog.ShowDialogNoWait"/> calls <see cref="M:Au.dialog.ShowDialog"/> in another thread.
            </remarks>
        </member>
        <member name="P:Au.dialog.Controls">
            <summary>
            After closing the dialog contains values of checkbox, radio buttons and/or text edit control.
            null if no controls.
            </summary>
        </member>
        <member name="M:Au.dialog.ThreadWaitForOpen">
            <summary>
            Can be used by other threads to wait until the dialog is open.
            If returns true, the dialog is open and you can send messages to it.
            If returns false, the dialog is already closed or failed to show.
            </summary>
        </member>
        <member name="M:Au.dialog.ThreadWaitForClosed">
            <summary>
            Can be used by other threads to wait until the dialog is closed.
            </summary>
        </member>
        <member name="P:Au.dialog.IsOpen">
            <summary>
            Returns true if the dialog is open and your code can send messages to it.
            </summary>
        </member>
        <member name="P:Au.dialog.DialogWindow">
            <summary>
            Gets dialog window handle as wnd.
            Returns default(wnd) if the dialog is not open.
            </summary>
        </member>
        <member name="P:Au.dialog.Send">
            <summary>
            Allows to modify dialog controls while it is open, and close the dialog.
            </summary>
            <remarks>
            Example: <c>d.Send.Close();</c> .
            Example: <c>d.Send.ChangeText2("new text", false);</c> .
            Example: <c>d.Send.Message(DNative.TDM.CLICK_VERIFICATION, 1);</c> .
            
            Can be used only while the dialog is open. Before showing the dialog returns null. After closing the dialog the returned variable is deactivated; its method calls are ignored.
            Can be used in dialog event handlers. Also can be used in another thread, for example with <see cref="M:Au.dialog.showNoWait(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.dialog.showProgress(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
        </member>
        <member name="P:Au.dialog.EditControl">
            <summary>
            Gets edit control handle as wnd.
            </summary>
        </member>
        <member name="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog.
            Returns selected button id.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">
            Button ids and labels. Examples: "OK|Cancel", "1 &amp;Save|2 Do&amp;n't Save|0 Cancel".
            If omitted, null or "", the dialog will have OK button, id 1.
            Common buttons: OK, Yes, No, Retry, Cancel, Close.
            More info in Remarks.
            </param>
            <param name="flags"></param>
            <param name="icon"></param>
            <param name="owner">Owner window. See <see cref="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footer">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.dialog.options.defaultTitle"/>.</param>
            <param name="controls">Can be used to add more controls and later get their values: checkbox, radio buttons, text input.</param>
            <param name="defaultButton">id of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.dialog.Screen"/>. If default - center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.dialog.Screen"/>. If default - center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, after this time (seconds) auto-close the dialog and return <see cref="F:Au.dialog.Timeout"/>.</param>
            <param name="onLinkClick">
            A link-clicked event handler function, eg lambda. Enables hyperlinks in small-font text.
            Example:
            <code><![CDATA[
            dialog.show("", "Text <a href=\"example\">link</a>.", onLinkClick: e => { print.it(e.LinkHref); });
            ]]></code>
            </param>
            <remarks>
            Tip: Use named arguments. Example: <c>dialog.show("Text", icon: DIcon.Info, title: "Title")</c> .
            
            This function allows you to use many dialog features, but not all. Alternatively you can create a <b>dialog</b> class instance, set properties and call <b>ShowDialog</b>. Example in <see cref="T:Au.dialog"/> class help.
            
            ##### More info about the <i>buttons</i> parameter
            
            Missing ids are auto-generated, for example "OK|Cancel|100 Custom1|Custom2" is the same as "1 OK|2 Cancel|100 Custom1|101 Custom2".
            
            The first in the list button is default, ie responds to the Enter key. For example, "2 No|1 Yes" adds Yes and No buttons and makes No default.
            
            To create keyboard shortcuts, use &amp; character in custom button labels. Use &amp;&amp; for literal &amp;. Example: "1 &amp;Tuesday[]2 T&amp;hursday[]3 Saturday &amp;&amp; Sunday".
            
            Trims newlines around ids and labels. For example, "\r\n1 One\r\n|\r\n2\r\nTwo\r\n\r\n" is the same as "1 One|2 Two".
            
            There are 6 <i>common buttons</i>: OK, Yes, No, Retry, Cancel, Close. Buttons that have other labels are <i>custom buttons</i>.
            How common buttons are different:
            	1. DFlags.CommandLinks does not change their style.
            	2. They have keyboard shortcuts that cannot be changed. Inserting &amp; in a label makes it a custom button.
            	3. Button Cancel can be selected with the Esc key. It also adds X (Close) button in title bar, which selects Cancel.
            	4. Always displayed in standard order (eg Yes No, never No Yes). But you can for example use "2 No|1 Yes" to set default button = No.
            	5. The displayed button label is localized, ie different when the Windows UI language is not English.
            
            You can use flag <see cref="F:Au.Types.DFlags.CommandLinks"/> to change the style of custom buttons.
            
            See also: <see cref="M:Au.dialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            if(1 != dialog.show("Continue?", null, "1 OK|2 Cancel", icon: DIcon.Info)) return;
            print.it("OK");
            
            switch(dialog.show("Save changes?", "More info.", "1 Save|2 Don't Save|0 Cancel")) {
            case 1: print.it("save"); break;
            case 2: print.it("don't"); break;
            default: print.it("cancel"); break;
            }
            ]]></code>
            
            <code><![CDATA[
            var con = new DControls { Checkbox = "Check", RadioButtons = "1 One|2 Two|3 Three", EditType = DEdit.Combo, EditText = "zero", ComboboxValues = new string[] { "one", "two" } };
            var r = dialog.show("Main text", "More text.", "1 OK|2 Cancel", expandedText: "Expanded text", controls: con, secondsTimeout: 30);
            print.it(r, con.IsChecked, con.RadioId, con.EditText);
            switch(r) {
            case 1: print.it("OK"); break;
            case dialog.Timeout: print.it("timeout"); break;
            default: print.it("Cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Info icon.
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Warning icon.
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Error icon.
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showOkCancel(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with OK and Cancel buttons.
            Returns true if selected OK.
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showYesNo(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with Yes and No buttons.
            Returns true if selected Yes.
            Calls <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showInput(System.String@,System.String,System.String,Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String},Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a text edit field and gets that text.
            Returns true if selected OK (or a custom button with id 1), else false.
            </summary>
            <param name="s">Variable that receives the text.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type. It can be simple text (DEdit.Text, default), multiline, number, password or combo box.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="comboItems">Combo box items used when <i>editType</i> is Combo.</param>
            <param name="flags"></param>
            <param name="owner">Owner window. See <see cref="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footer">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.dialog.options.defaultTitle"/>.</param>
            <param name="controls">Can be used to add more controls and later get their values: checkbox, radio buttons.</param>
            <param name="x">X position in <see cref="P:Au.dialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.dialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, after this time (seconds) auto-close the dialog and return <see cref="F:Au.dialog.Timeout"/>.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <param name="buttons">
            Buttons. A list of strings "id text" separated by |, like "1 OK|2 Cancel|10 Browse...". See <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            Note: this function returns true only when clicked button with id 1.
            Usually custom buttons are used with <i>onButtonClick</i> function, which for example can get button id or disable closing the dialog.
            </param>
            <param name="onButtonClick">A button-clicked event handler function. See examples.</param>
            <remarks>
            This function allows you to use many dialog features, but not all. Alternatively you can create a <b>dialog</b> class instance, call <see cref="M:Au.dialog.SetEditControl(Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String})"/> or use the <i>controls</i> parameter, set other properties and call <b>ShowDialog</b>.
            </remarks>
            <example>
            Simple.
            <code><![CDATA[
            string s;
            if(!dialog.showInput(out s, "Example")) return;
            print.it(s);
            
            if(!dialog.showInput(out var s2, "Example")) return;
            print.it(s2);
            ]]></code>
            
            With checkbox.
            <code><![CDATA[
            var con = new DControls { Checkbox = "Check" };
            if(!dialog.showInput(out var s, "Example", "Comments.", controls: con)) return;
            print.it(s, con.IsChecked);
            ]]></code>
            
            With <i>onButtonClick</i> function.
            <code><![CDATA[
            int r = 0;
            dialog.showInput(out string s, "Example", buttons: "OK|Cancel|Later", onButtonClick: e => r = e.Button);
            print.it(r);
            
            if(!dialog.showInput(out string s, "Example", flags: DFlags.CommandLinks, buttons: "OK|Cancel|10 Set text", onButtonClick: e => {
            	if(e.Button == 10) { e.EditText = "text"; e.DontCloseDialog = true; }
            })) return;
            
            if(!dialog.showInput(out string s2, "Example", "Try to click OK while text is empty.", onButtonClick: e => {
            	if(e.Button == 1 && e.EditText.NE()) {
            		dialog.show("Text cannot be empty.", owner: e.hwnd);
            		e.d.EditControl.Focus();
            		e.DontCloseDialog = true;
            	}
            })) return;
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showInputNumber(System.Int32@,System.String,System.String,System.Nullable{System.Int32},Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a number edit field and gets that number.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="i">Variable that receives the number.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="flags"></param>
            <param name="owner">Owner window. See <see cref="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.dialog.showInput(System.String@,System.String,System.String,Au.Types.DEdit,System.String,System.Collections.Generic.IEnumerable{System.String},Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/> and converts string to int.
            </remarks>
            <example>
            <code><![CDATA[
            int i;
            if(!dialog.showInputNumber(out i, "Example")) return;
            print.it(i);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showList(Au.Types.DStringList,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns 1-based index of the selected button. Returns 0 if clicked the X (close window) button or pressed Esc.
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or string[] or List&lt;string&gt;. See <see cref="M:Au.dialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window. See <see cref="M:Au.dialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footer">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.dialog.options.defaultTitle"/>.</param>
            <param name="controls">Can be used to add more controls and later get their values: checkbox, radio buttons, text input.</param>
            <param name="defaultButton">id (1-based index) of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.dialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.dialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, after this time (seconds) auto-close the dialog and return <see cref="F:Au.dialog.Timeout"/>.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a <b>dialog</b> class instance, set properties and call ShowDialog. Example in <see cref="T:Au.dialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            int r = dialog.showList("One|Two|Three", "Example", y: -1, secondsTimeout: 15);
            if(r <= 0) return; //X/Esc or timeout
            print.it(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
            <seealso cref="M:Au.popupMenu.showSimple(Au.Types.DStringList,Au.Types.MSFlags,System.Nullable{Au.Types.POINT},System.Nullable{Au.Types.RECT},Au.Types.AnyWnd)"/>
        </member>
        <member name="M:Au.dialog.showProgress(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in new thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.dialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.dialog.IsOpen"/>, <see cref="M:Au.dialog.ThreadWaitForClosed"/>, <see cref="P:Au.dialog.Result"/> (when closed), <see cref="P:Au.dialog.Controls"/> (when closed), <see cref="P:Au.dialog.DialogWindow"/>, <see cref="P:Au.dialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            Most parameters are the same as with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a <b>dialog</b> class instance, set properties and call <see cref="M:Au.dialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = dialog.showProgress(false, "Working", buttons: "1 Stop", y: -1);
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { print.it(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	50.ms(); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.dialog.showNoWait(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog like <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.dialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.dialog.IsOpen"/>, <see cref="M:Au.dialog.ThreadWaitForClosed"/>, <see cref="P:Au.dialog.Result"/> (when closed), <see cref="P:Au.dialog.Controls"/> (when closed), <see cref="P:Au.dialog.DialogWindow"/>, <see cref="P:Au.dialog.Send"/>; through the Send property you can modify controls and close the dialog (see example).
            Parameters are the same as with <see cref="M:Au.dialog.show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a <b>dialog</b> class instance, set properties and call <see cref="M:Au.dialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            dialog.showNoWait("Simple example");
            
            var d = dialog.showNoWait("Another example", "text", "1 OK|2 Cancel", y: -1, secondsTimeout: 30);
            2.s(); //do something while the dialog is open
            d.Send.ChangeText2("new text", false);
            2.s(); //do something while the dialog is open
            d.ThreadWaitForClosed(); print.it(d.Result); //wait until the dialog is closed and get result. Optional, just an example.
            ]]></code>
            </example>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="T:Au.osdRect">
            <summary>
            Shows mouse-transparent rectangle on screen. Its interior can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws rectangle in it.
            </remarks>
            <example>
            <code><![CDATA[
            using(var x = new osdRect()) {
            	x.Rect = (300, 300, 100, 100);
            	x.Color = Color.SlateBlue;
            	x.Thickness = 4;
            	x.Show();
            	for(int i = 0; i < 5; i++) {
            		250.ms();
            		x.Visible = !x.Visible;
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.osdRect.#ctor">
            
        </member>
        <member name="P:Au.osdRect.Color">
            <summary>
            Gets or sets rectangle color.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            x.Color = 0xFF0000; //red
            x.Color = Color.Orange;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.osdRect.Thickness">
            <summary>
            Gets or sets rectangle frame width.
            Used only if <see cref="P:Au.Types.OsdWindow.Opacity"/> is 0 (default).
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.osdRect.OnPaint(System.IntPtr,System.Drawing.Graphics,Au.Types.RECT)">
            <summary>
            Called when the OSD window must be drawn or redrawn. Draws rectangle. More info: <see cref="M:Au.Types.OsdWindow.OnPaint(System.IntPtr,System.Drawing.Graphics,Au.Types.RECT)"/>.
            </summary>
        </member>
        <member name="T:Au.osdText">
            <summary>
            Shows mouse-transparent text on screen. Its background can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws text in it.
            Most properties cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.osdText.Dispose(System.Boolean)">
            
        </member>
        <member name="P:Au.osdText.XY">
            <summary>
            Coordinates.
            Default: null. Screen center.
            </summary>
            <remarks>
            Not used if <see cref="P:Au.osdText.Rect"/> is set.
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new osdText { Text = "Text" };
            m.XY = new PopupXY(Coord.Center, Coord.Max); //bottom-center of the work area of the primary screen
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.osdText.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            Normally don't need to use this property. If not used, the OSD window size depends on text etc, and position on <see cref="P:Au.osdText.XY"/>.
            This property can be changed after creating OSD window.
            </remarks>
            <seealso cref="M:Au.osdText.Measure"/>
        </member>
        <member name="P:Au.osdText.ResizeWhenContentChanged">
            <summary>
            When changing text, resize/move the OSD window if need.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.osdText.Text">
            <summary>
            Text in OSD window.
            </summary>
            <remarks>
            This property can be changed after creating OSD window; then the window is not moved/resized, unless <see cref="P:Au.osdText.ResizeWhenContentChanged"/> is true.
            </remarks>
        </member>
        <member name="P:Au.osdText.Font">
            <summary>
            Font.
            If not set, uses <see cref="P:Au.osdText.defaultSmallFont"/>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.TextColor">
            <summary>
            Text color.
            Default: <see cref="P:Au.osdText.defaultTextColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.BackColor">
            <summary>
            Background color.
            Default: <see cref="P:Au.osdText.defaultBackColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            Not used for completely transparent OSD.
            </remarks>
        </member>
        <member name="P:Au.osdText.BorderColor">
            <summary>
            Border color.
            Default: <see cref="P:Au.osdText.defaultBorderColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            No border if <see cref="P:Au.Types.OsdWindow.Opacity"/>==0 or <b>BorderColor</b>==<see cref="P:Au.osdText.BackColor"/>.
            </remarks>
        </member>
        <member name="P:Au.osdText.BackgroundImage">
            <summary>
            Background image.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.IsOfImageSize">
            <summary>
            When used <see cref="P:Au.osdText.BackgroundImage"/>, the OSD window has the same size as the image, plus borders.
            Else OSD window size is calculated from sizes of text and icon. Then image is displayed scaled or clipped if need.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.WrapWidth">
            <summary>
            Maximal text width.
            Default: 0 - no limit (depends on screen width etc).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.TextFormatFlags">
            <summary>
            Gets or sets text format flags.
            Default: TFFlags.NOPREFIX | TFFlags.WORDBREAK | TFFlags.EXPANDTABS.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.Icon">
            <summary>
            Icon or image at the left. Can be <see cref="T:Au.icon"/>, <b>Icon</b> or <b>System.Drawing.Image</b>. Any size.
            For example <i>System.Drawing.SystemIcons.Information</i> or <c>icon.stock(StockIcon.INFO)</c>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Window shadows can be disabled. See <msdn>SPI_SETDROPSHADOW</msdn>.
            </remarks>
        </member>
        <member name="P:Au.osdText.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.SecondsTimeout">
            <summary>
            Close the OSD window after this time, seconds.
            If 0 (default), depends on text length. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.osdText.ShowMode">
            <summary>
            See <see cref="T:Au.Types.OsdMode"/>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.osdText.#ctor">
            
        </member>
        <member name="M:Au.osdText.Show">
            <summary>
            Shows the OSD window. Creates if need.
            By default does not wait; the window will be closed after <see cref="P:Au.osdText.SecondsTimeout"/>.
            </summary>
            <remarks>
            Depending on <see cref="P:Au.osdText.ShowMode"/>, creates the OSD window in this or new thread.
            If the OSD window is already created, just shows it if hidden. Many properties can be changed only before creating OSD window; call <see cref="M:Au.Types.OsdWindow.Close"/> if need.
            </remarks>
        </member>
        <member name="M:Au.osdText.OnPaint(System.IntPtr,System.Drawing.Graphics,Au.Types.RECT)">
            <summary>
            Draws OSD text etc.
            </summary>
        </member>
        <member name="M:Au.osdText.Measure">
            <summary>
            Calculates OSD window size and position.
            Can be called before showing OSD.
            </summary>
        </member>
        <member name="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)">
            <summary>
            Shows a tooltip-like OSD window with text and optionally icon.
            </summary>
            <param name="text"><see cref="P:Au.osdText.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.osdText.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.osdText.XY"/></param>
            <param name="icon"><see cref="P:Au.osdText.Icon"/></param>
            <param name="textColor"><see cref="P:Au.osdText.TextColor"/></param>
            <param name="backColor"><see cref="P:Au.osdText.BackColor"/></param>
            <param name="font">Font. If null, uses <see cref="P:Au.osdText.defaultSmallFont"/>.</param>
            <param name="name"><see cref="P:Au.Types.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.osdText.ShowMode"/></param>
            <param name="dontShow">Don't call <see cref="M:Au.osdText.Show"/>. The caller can use the return value to set some other properties and call <b>Show</b>.</param>
            <returns>Returns an <see cref="T:Au.osdText"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.osdText.ClickToClose"/>=true, <see cref="P:Au.osdText.Shadow"/>=true.
            </remarks>
        </member>
        <member name="M:Au.osdText.showTransparentText(System.String,System.Int32,Au.Types.PopupXY,System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)">
            <summary>
            Shows a big-font text with transparent background.
            </summary>
            <param name="text"><see cref="P:Au.osdText.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.osdText.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.osdText.XY"/></param>
            <param name="color"><see cref="P:Au.osdText.TextColor"/>. Default: <see cref="P:Au.osdText.defaultTransparentTextColor"/>.</param>
            <param name="font">Font. If null, uses <see cref="P:Au.osdText.defaultBigFont"/>.</param>
            <param name="name"><see cref="P:Au.Types.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.osdText.ShowMode"/></param>
            <param name="dontShow">See <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/>.</param>
            <returns>Returns an <see cref="T:Au.osdText"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.Types.OsdWindow.Opacity"/>=0.
            </remarks>
        </member>
        <member name="M:Au.osdText.showImage(System.Drawing.Image,System.Int32,Au.Types.PopupXY,System.String,Au.Types.OsdMode,System.Boolean)">
            <summary>
            Shows on-screen image.
            </summary>
            <param name="image"><see cref="P:Au.osdText.BackgroundImage"/></param>
            <param name="secondsTimeout"><see cref="P:Au.osdText.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.osdText.XY"/></param>
            <param name="name"><see cref="P:Au.Types.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.osdText.ShowMode"/></param>
            <param name="dontShow">See <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/>.</param>
            <returns>Returns an <see cref="T:Au.osdText"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.osdText.IsOfImageSize"/>=true, <see cref="P:Au.Types.OsdWindow.Opacity"/>=0, <see cref="P:Au.osdText.ClickToClose"/>=true.
            </remarks>
        </member>
        <member name="P:Au.osdText.defaultSmallFont">
            <summary>Default font for <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/> and <b>osdText</b>. Default: standard GUI font (usually Segoe UI), size 12.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Au.osdText.defaultBigFont">
            <summary>Default font for <see cref="M:Au.osdText.showTransparentText(System.String,System.Int32,Au.Types.PopupXY,System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/>. Default: standard GUI font (usually Segoe UI), size 24.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Au.osdText.defaultTextColor">
            <summary>Default text color for <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/> and <b>osdText</b>. Default: 0x(dark gray).</summary>
        </member>
        <member name="P:Au.osdText.defaultBorderColor">
            <summary>Default border color for <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/> and <b>osdText</b>. Default: 0x404040 (dark gray).</summary>
        </member>
        <member name="P:Au.osdText.defaultBackColor">
            <summary>Default background color for <see cref="M:Au.osdText.showText(System.String,System.Int32,Au.Types.PopupXY,System.Object,System.Nullable{Au.Types.ColorInt},System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/> and <b>osdText</b>. Default: 0xFFFFF0 (light yellow).</summary>
        </member>
        <member name="P:Au.osdText.defaultTransparentTextColor">
            <summary>Default text color for <see cref="M:Au.osdText.showTransparentText(System.String,System.Int32,Au.Types.PopupXY,System.Nullable{Au.Types.ColorInt},Au.Types.FontNSS,System.String,Au.Types.OsdMode,System.Boolean)"/>. Default: 0x8A2BE2 (Color.BlueViolet).</summary>
        </member>
        <member name="P:Au.osdText.defaultScreen">
            <summary>
            Default screen when <see cref="P:Au.osdText.XY"/> is not set.
            The <b>screen</b> must be lazy or empty.
            </summary>
            <exception cref="T:System.ArgumentException"><b>screen</b> with <b>Handle</b>. Must be lazy (with <b>LazyFunc</b>) or empty.</exception>
            <example>
            <code><![CDATA[
            osdText.defaultScreen = screen.index(1, lazy: true);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.MTBase">
             <summary>
             Base class of <see cref="T:Au.popupMenu"/> and <see cref="T:Au.toolbar"/>.
             </summary>
             <remarks>
             <i>image</i> argument of "add item" functions can be:
             - file/folder path (string) - the "show" function calls <see cref="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)"/> to get its icon. It also supports file type icons like ".txt", etc.
             - file path with prefix "imagefile:" or resource path that starts with "resources/" or has prefix "resource:" - the "show" function loads .png or .xaml image file or resource.
             - string with prefix "image:" - Base-64 encoded png file. Can be created with the "Find image..." dialog.
             - <see cref="T:Au.Types.FolderPath"/> - same as folder path string.
             - <see cref="T:System.Drawing.Image"/> - image.
             - <see cref="T:Au.icon"/> - icon. The "add item" function disposes it.
             - <see cref="T:Au.Types.StockIcon"/> - the "show" function calls <see cref="M:Au.icon.stock(Au.Types.StockIcon,System.Int32)"/>.
             - null - if <see cref="P:Au.MTBase.ExtractIconPathFromCode"/> true, the "show" function tries to extract a file path from action code; then calls <see cref="M:Au.icon.of(System.String,System.Int32,Au.Types.IconGetFlags)"/>. Else no image.
             - string "" - no image, even if <b>ExtractIconPathFromCode</b> true.
             
             Item images should be of size 16x16 (small icon size). If high DPI, will scale images automatically, which makes them slightly blurred. To avoid scaling, can be used XAML images, but then slower.
            
             Images are loaded on demand, when showing the menu or submenu etc. If fails to load, prints warning (<see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>).
             
             For icon/image files use full path, unless they are in <see cref="P:Au.folders.ThisAppImages"/>
             
             To add an image resource in Visual Studio, use build action "Resource" for the image file.
             </remarks>
        </member>
        <member name="P:Au.MTBase.ExtractIconPathFromCode">
            <summary>
            Extract file path or script path from item action code (for example <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/> or <see cref="M:Au.script.run(System.String,System.String[])"/> argument) and use icon of that file or script.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
            <remarks>
            Gets path from code that contains a string like <c>@"c:\windows\system32\notepad.exe"</c> or <c>@"%folders.System%\notepad.exe"</c> or URL/shell or <c>@"\folder\script.cs"</c>.
            Also supports code patterns like <c>folders.System + "notepad.exe"</c>, <c>folders.shell.RecycleBin</c>.
            
            If extracts path, also in the context menu adds item "Find file" which selects the file in Explorer or "Open script" which opens the script in editor.
            </remarks>
        </member>
        <member name="P:Au.MTBase.ActionThread">
            <summary>
            Execute item actions asynchronously in new threads.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
            <remarks>
            If current thread is a UI thread (has windows etc) or has triggers or hooks, and item action functions execute some long automations etc in current thread, current thread probably is hung during that time. Set this property = true to avoid it.
            </remarks>
        </member>
        <member name="P:Au.MTBase.ActionException">
            <summary>
            Whether to handle exceptions in item action code. If false (default), handles exceptions and on exception calls <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
        </member>
        <member name="P:Au.MTBase.PathInTooltip">
            <summary>
            If an item has file path, show it in tooltip.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
        </member>
        <member name="M:Au.MTBase._GetImage(Au.MTBase.MTItem)">
            <summary>
            Converts x.image (object containing string, Image, etc or null) to Image. Extracts icon path from code if need. Returns default if will extract async.
            </summary>
        </member>
        <member name="T:Au.MTBase.MTItem">
            <summary>
            Base of <see cref="T:Au.popupMenu.MenuItem"/> etc.
            </summary>
        </member>
        <member name="F:Au.MTBase.MTItem.extractIconPath">
            <summary>1 if need to extract, 2 if already extracted (the image field is the path), 3 if failed to extract, 4 if extracted "script.cs"</summary>
        </member>
        <member name="P:Au.MTBase.MTItem.Text">
            <summary>
            Item text.
            </summary>
        </member>
        <member name="P:Au.MTBase.MTItem.Tooltip">
            <summary>
            Item tooltip.
            </summary>
        </member>
        <member name="P:Au.MTBase.MTItem.Tag">
            <summary>
            Any value. Not used by this library.
            </summary>
        </member>
        <member name="P:Au.MTBase.MTItem.TextColor">
            
        </member>
        <member name="P:Au.MTBase.MTItem.File">
            <summary>
            Gets file or script path extracted from item action code (see <see cref="P:Au.MTBase.ExtractIconPathFromCode"/>) or sets path as it would be extracted.
            </summary>
            <remarks>
            Can be used to set file or script path when it cannot be extracted from action code.
            When you set this property, the menu/toolbar item uses icon of the specified file, and its context menu contains "Find file" or "Open script".
            </remarks>
        </member>
        <member name="M:Au.MTBase.MTItem.Set_(Au.MTBase,System.String,System.Delegate,Au.Types.MTImage,System.Int32)">
            <summary>
            Call when adding menu/toolbar item.
            Sets text and tooltip (from text). Sets clicked, image and sourceLine fields.
            Sets extractIconPath, actionThread and actionException fields from mt properties.
            </summary>
        </member>
        <member name="M:Au.MTBase.MTItem.ToString">
            
        </member>
        <member name="M:Au.MTBase.Finalize">
            
        </member>
        <member name="T:Au.popupMenu">
            <summary>
            Popup menu.
            </summary>
            <remarks>
            Can be used everywhere: in automation scripts, WPF apps, other apps, etc.
            Also can be used as a popup list and supports many items with scrollbar.
            
            Menu item text can include hotkey after '\t' character and/or tooltip after '\0' character and optional space character. Examples: <c>"Text\t Hotkey"</c>, <c>"Text\0 Tooltip"</c>, <c>"Text\t Hotkey\0 Tooltip"</c>. Character with prefix &amp; (eg 'A' in <c>"Save &amp;As"</c>) will be underlined (depends on Windows settings and <see cref="T:Au.Types.MSFlags"/>) and can be used to select the item with keyboard.
            
            Keyboard, mouse:
            - Enter, Tab, Space - close the menu and execute the focused item. Or show the submenu.
            - Esc - close the menu or current submenu.
            - Left - close current submenu.
            - Right - open submenu.
            - Down, Up, PageDown, PageUp, End, Home - focus other item.
            - underlined menu item character - close the menu and execute the item. Or show the submenu. See <see cref="F:Au.Types.MSFlags.Underline"/>.
            - Alt, Win, F10, Apps, Back - close menus.
            - click outside - close the menu.
            - middle click - close the menu.
            - right click - show context menu (if used constructor with parameters).
            
            While a menu is open, it captures many keyboard keys, even when its thread isn't the foreground thread.
            
            Not thread-safe. All functions must be called in same thread, unless documented otherwise.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new popupMenu("example");
            m["One"] = o => print.it(o);
            m["Two\0Tooltip", image: icon.stock(StockIcon.DELETE)] = o => { print.it(o); dialog.show(o.ToString()); };
            m.Submenu("Submenu", m => {
            	m["Three"] = o => print.it(o);
            	m["Four"] = o => print.it(o);
            });
            m["notepad"] = o => run.itSafe(folders.System + "notepad.exe");
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.popupMenu.MenuItem">
            <summary>
            Represents a menu item in <see cref="T:Au.popupMenu"/>.
            </summary>
            <remarks>
            Most properties cannot be changed while the menu is open. Can be changed <b>Tag</b>, <b>Tooltip</b>, <b>IsChecked</b> and <b>IsDisabled</b>.
            </remarks>
        </member>
        <member name="P:Au.popupMenu.MenuItem.Clicked">
            <summary>Gets item action.</summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.Id">
            <summary>Gets menu item id.</summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.IsSubmenu">
            <summary>true if is a submenu-item.</summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.IsSeparator">
            <summary>true if is a separator.</summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.IsDisabled">
            <summary>
            Gets or sets disabled state.
            </summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.IsChecked">
            <summary>
            Gets or sets checked state.
            </summary>
            <exception cref="T:System.InvalidOperationException">The 'set' function throws if the item isn't checkable. Use <see cref="M:Au.popupMenu.AddCheck(System.String,System.Boolean,System.Action{Au.popupMenu.MenuItem},System.Boolean,Au.Types.MTImage,System.Int32)"/> or <see cref="M:Au.popupMenu.AddRadio(System.String,System.Boolean,System.Action{Au.popupMenu.MenuItem},System.Boolean,Au.Types.MTImage,System.Int32)"/>.</exception>
        </member>
        <member name="P:Au.popupMenu.MenuItem.FontBold">
            <summary>Gets or sets whether to use bold font.</summary>
        </member>
        <member name="P:Au.popupMenu.MenuItem.BackgroundColor">
            <summary>Gets or sets background color.</summary>
        </member>
        <member name="M:Au.popupMenu.#ctor">
            <summary>
            Use this constructor for various context menus of your app.
            </summary>
            <remarks>
            Users cannot right-click a menu item and open/select it in editor.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Use this constructor in scripts.
            </summary>
            <param name="name">Menu name. Must be a unique valid filename. Currently not used. Can be null.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            This overload sets <see cref="P:Au.MTBase.ExtractIconPathFromCode"/> = true.
            
            Users can right-click an item to open/select it in editor, unless <i>f</i> = null.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.Add(System.Int32,System.String,Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item with explicitly specified id.
            </summary>
            <param name="id">Item id that <see cref="M:Au.popupMenu.Show(Au.Types.MSFlags,System.Nullable{Au.Types.POINT},System.Nullable{Au.Types.RECT},Au.Types.AnyWnd)"/> will return if clicked this item.</param>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
        </member>
        <member name="M:Au.popupMenu.Add(System.String,Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item with auto-generated id.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            Assigns id = the last specified or auto-generated id + 1. If not using explicitly specified ids, auto-generated ids are 1, 2, 3... Submenu-items, separators and items with action don't auto-generate ids.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.Add(System.String,System.Action{Au.popupMenu.MenuItem},Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item with action (callback function) that is executed on click.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="click">Action executed on click.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            This function is the same as the indexer. The difference is, <b>Add</b> returns <b>MenuItem</b> object of the added item. When using the indexer, to access the item use <see cref="P:Au.popupMenu.Last"/>. These codes are the same: <c>var v=m.Add("text", o=>{});"</c> and <c>m["text"]=o=>{}; var v=m.Last;</c>.
            </remarks>
        </member>
        <member name="P:Au.popupMenu.Item(System.String,Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item with action (callback function) that is executed on click.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
            <value>Action executed on click. Can be null.</value>
            <remarks>
            This function is the same as <see cref="M:Au.popupMenu.Add(System.String,System.Action{Au.popupMenu.MenuItem},Au.Types.MTImage,System.Boolean,System.Int32)"/>. The difference is, <b>Add</b> returns <b>MenuItem</b> object of the added item. When using the indexer, to access the item use <see cref="P:Au.popupMenu.Last"/>. These codes are the same: <c>var v=m.Add("text", o=>{});"</c> and <c>m["text"]=o=>{}; var v=m.Last;</c>.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.AddCheck(System.String,System.Boolean,System.Action{Au.popupMenu.MenuItem},System.Boolean,Au.Types.MTImage,System.Int32)">
            <summary>
            Adds menu item to be used as a checkbox.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="check">Checked state.</param>
            <param name="click">Action executed on click.</param>
            <param name="disable">Disabled state.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            When clicked, <see cref="P:Au.popupMenu.MenuItem.IsChecked"/> state is changed.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.AddRadio(System.String,System.Boolean,System.Action{Au.popupMenu.MenuItem},System.Boolean,Au.Types.MTImage,System.Int32)">
            <summary>
            Adds menu item to be used as a radio button in a group of such items.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="check">Checked state.</param>
            <param name="click">Action executed on click.</param>
            <param name="disable">Disabled state.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            When clicked an unchecked radio item, its <see cref="P:Au.popupMenu.MenuItem.IsChecked"/> state becomes true; <b>IsChecked</b> of other group items become false.
            </remarks>
        </member>
        <member name="M:Au.popupMenu.Submenu(System.String,System.Action{Au.popupMenu},Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item that opens a submenu.
            Used like <c>m.Submenu("Example", m => { /* add submenu items */ });</c>.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="opening">Action called whenever opening the submenu and should add items to it.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            The submenu is other <b>popupMenu</b> object. It inherits many properties of this menu; see property documentation.
            </remarks>
            <example>
            <code><![CDATA[
            m.Submenu("Example", m => {
            	m["A"] = o => { print.it(o); };
            	m["B"] = o => { print.it(o); };
            });
            ]]></code>
            This code shows dynamically created menu of files in a folder and subfolders. Subfolder files are retrieved when opening the submenu.
            <code><![CDATA[
            var m=new popupMenu();
            _Dir(m, new DirectoryInfo(@"C:\"));
            m.Show();
            
            static void _Dir(popupMenu m, DirectoryInfo dir) {
            	foreach (var v in dir.EnumerateFileSystemInfos()) {
            		if(v.Attributes.Has(FileAttributes.System|FileAttributes.Hidden)) continue;
            		if(v.Attributes.Has(FileAttributes.Directory)) {
            			m.Submenu(v.Name, m=> _Dir(m, v as DirectoryInfo));
            		} else {
            			m[v.Name]=o=>print.it(v.FullName);
            		}
            		m.Last.File = v.FullName;
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.popupMenu.Submenu(System.String,System.Func{Au.popupMenu},Au.Types.MTImage,System.Boolean,System.Int32)">
            <summary>
            Adds menu item that opens a reusable submenu.
            </summary>
            <param name="text">Item text. Can include hotkey, tooltip and underlined character, like <c>"Te&amp;xt\t Hotkey\0 Tooltip"</c>; more info: <see cref="T:Au.popupMenu"/>.</param>
            <param name="opening">Func called whenever opening the submenu and should return the submenu object. Can return null.</param>
            <param name="image">Item image. Read here: <see cref="T:Au.MTBase"/>.</param>
            <param name="disable">Disabled state.</param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            The caller creates the submenu (creates the <see cref="T:Au.popupMenu"/> object and adds items) and can reuse it many times. Other overload does not allow to create <b>popupMenu</b> and reuse same object.
            The submenu does not inherit properties of this menu.
            </remarks>
            <example>
            <code><![CDATA[
            var m2 = new popupMenu(); m2.AddCheck("C1"); m2.AddCheck("C2");
            m.Submenu("Submenu", () => m2);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.popupMenu.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="P:Au.popupMenu.Last">
            <summary>
            Gets the last added menu item.
            </summary>
        </member>
        <member name="P:Au.popupMenu.Items">
            <summary>
            Gets added items, except separators.
            </summary>
            <remarks>
            Allows to set properties of multiple items in single place instead of after each 'add item' code line.
            
            Does not get items in submenus. Submenus are separate <b>popupMenu</b> objects and you can use their <b>Items</b> property.
            </remarks>
        </member>
        <member name="P:Au.popupMenu.RawText">
            <summary>
            Don't use &amp; character for keyboard shortcut. Also don't use tab character for hotkey.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
        </member>
        <member name="M:Au.popupMenu.Show(Au.Types.MSFlags,System.Nullable{Au.Types.POINT},System.Nullable{Au.Types.RECT},Au.Types.AnyWnd)">
            <summary>
            Shows the menu and waits until closed.
            Returns id of the selected item when closed, or 0 if cancelled.
            </summary>
            <param name="flags"></param>
            <param name="xy">Menu position in screen. If null (default), uses mouse position by default. It depends on flags.</param>
            <param name="excludeRect">The menu should not overlap this rectangle in screen.</param>
            <param name="owner">Owner window. The menu will be automatically closed when destroying its owner window.</param>
            <exception cref="T:System.InvalidOperationException">The menu is open or is submenu.</exception>
        </member>
        <member name="P:Au.popupMenu.IsOpen">
            <summary>
            Returns true if the menu window is open.
            </summary>
        </member>
        <member name="P:Au.popupMenu.Result">
            <summary>
            After closing the menu gets the selected item, or null if cancelled.
            </summary>
        </member>
        <member name="M:Au.popupMenu.showSimple(Au.Types.DStringList,Au.Types.MSFlags,System.Nullable{Au.Types.POINT},System.Nullable{Au.Types.RECT},Au.Types.AnyWnd)">
            <summary>
            Creates and shows simple popup menu. Without images, actions, submenus.
            Returns selected item id, or 0 if cancelled.
            </summary>
            <param name="items">
            Menu items. Can be string[], List&lt;string&gt; or string like "One|Two|Three".
            Item id can be optionally specified like "1 One|2 Two|3 Three". If missing, uses id of previous non-separator item + 1. Example: "One|Two|100 Three Four" //1|2|100|101.
            For separators use null or empty strings: "One|Two||Three|Four".
            </param>
            <param name="flags"></param>
            <param name="xy">Menu position in screen. If null (default), uses mouse position by default. It depends on flags.</param>
            <param name="excludeRect">The menu should not overlap this rectangle in screen.</param>
            <param name="owner">Owner window. The menu will be automatically closed when destroying its owner window.</param>
            <remarks>
            The function adds menu items and calls <see cref="M:Au.popupMenu.Show(Au.Types.MSFlags,System.Nullable{Au.Types.POINT},System.Nullable{Au.Types.RECT},Au.Types.AnyWnd)"/>. Returns when menu closed. All parameters except <i>items</i> are same as of <b>Show</b>.
            </remarks>
            <seealso cref="M:Au.dialog.showList(Au.Types.DStringList,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,Au.Types.DControls,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>
        </member>
        <member name="M:Au.popupMenu.Close(System.Boolean)">
            <summary>
            Closes the menu and its submenus.
            </summary>
            <param name="ancestorsToo">If this is a submenu, close the root menu with all submenus.</param>
            <remarks>
            Can be called from any thread.
            Does nothing if not open.
            </remarks>
        </member>
        <member name="P:Au.popupMenu.CheckDontClose">
            <summary>
            Don't close menu when clicked a checkbox or radio item.
            This property is applied to items added afterwards; submenus inherit it.
            </summary>
        </member>
        <member name="P:Au.popupMenu.FocusedItem">
            <summary>
            Gets or sets the focused menu item.
            </summary>
            <remarks>
            The focused item visually shows the menu item that would be executed if clicked or pressed Enter, Tab or Space key. It changes when the user moves the mouse or presses navigation keys (arrows, End, Home, PageDown, PageUp).
            This property can be set before showing the menu or when it is open.
            </remarks>
        </member>
        <member name="P:Au.popupMenu.KeyboardHook">
            <summary>
            Gets or sets callback function that decides how to respond to pressed keys (default, close, ignore, block).
            </summary>
            <remarks>
            The function is called on each key down event while the menu is open. Only if current thread is not in the foreground.
            To block a key, call <see cref="M:Au.Types.HookData.Keyboard.BlockEvent"/>.
            The function must be as fast as possible.
            </remarks>
        </member>
        <member name="T:Au.toolbar">
            <summary>
            Floating toolbar.
            Can be attached to windows of other programs.
            </summary>
            <remarks>
            To create toolbar code can be used snippet toolbarSnippet. In code editor type "toolbar" and selext the snippet from the list.
            
            Not thread-safe. All functions must be called from the same thread that created the <b>toolbar</b> object, except where documented otherwise. Note: item actions by default run in other threads; see <see cref="P:Au.MTBase.ActionThread"/>.
            </remarks>
        </member>
        <member name="M:Au.toolbar.toolbarsDialog">
            <summary>
            Creates dialog with a list of toolbars of this thread. Just creates, does not show. Can be used to find lost toolbars.
            </summary>
            <example>
            <code><![CDATA[
            toolbar.toolbarsDialog().Show();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.toolbar._GetCachedOwnerRect">
            <summary>
            Gets the cached rectangle of the owner window, screen, control, etc.
            If is owned and anchor has flag Screen, the rectangle is of toolbar's screen.
            Also gets previous size.
            The values are cached by <b>UpdateRect</b> of <b>_OwnerWindow</b> etc.
            </summary>
        </member>
        <member name="P:Au.toolbar.Border">
            <summary>
            Border style.
            Default <see cref="F:Au.Types.TBBorder.Width2"/>.
            </summary>
            <remarks>
            This property is in the context menu and is saved.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Layout">
            <summary>
            Layout of buttons (horizontal, vertical).
            </summary>
            <remarks>
            This property is in the context menu and is saved.
            </remarks>
        </member>
        <member name="P:Au.toolbar.DisplayText">
            <summary>
            Display button text. Default true. If false, displays text in tooltips, and only displays first 2 characters for buttons without image.
            </summary>
        </member>
        <member name="P:Au.toolbar.Font">
            <summary>
            Font properties.
            </summary>
            <remarks>
            Cannot be changed after showing toolbar window.
            </remarks>
        </member>
        <member name="P:Au.toolbar.TextColor">
            <summary>
            Text color.
            If <c>default</c>, uses system color.
            </summary>
        </member>
        <member name="P:Au.toolbar.Background">
            <summary>
            Background color or brush.
            </summary>
            <value>Can be <see cref="T:System.Drawing.Color"/>, <see cref="T:Au.Types.ColorInt"/>, int (color 0xRRGGBB) or <see cref="T:System.Drawing.Brush"/>. If null (default), uses system color.</value>
        </member>
        <member name="P:Au.toolbar.BorderColor">
            <summary>
            Border color when <see cref="P:Au.toolbar.Border"/> is Width1 ... Width4.
            If <c>default</c>, uses system color.
            </summary>
        </member>
        <member name="M:Au.toolbar._Measure(System.Nullable{System.Int32})">
            <summary>
            Measures toolbar size and sets button rectangles.
            Returns size of client area.
            </summary>
        </member>
        <member name="P:Au.toolbar.Satellite">
            <summary>
            A toolbar attached to this toolbar. Can be null.
            </summary>
            <exception cref="T:System.InvalidOperationException">The 'set' function throws if the satellite toolbar was attached to another toolbar or was shown as non-satellite toolbar.</exception>
            <remarks>
            The satellite toolbar is shown when mouse enters its owner toolbar and hidden when mouse leaves it and its owner. Like an "auto hide" feature.
            A toolbar can have multiple satellite toolbars at different times. A satellite toolbar can be attached/detached multiple times to the same toolbar.
            </remarks>
        </member>
        <member name="P:Au.toolbar.SatelliteOwner">
            <summary>
            If this is a sattellite toolbar (<see cref="P:Au.toolbar.Satellite"/>), gets its owner toolbar. Else null.
            </summary>
        </member>
        <member name="M:Au.toolbar.AutoHide(Au.Types.TBCtor,System.String,System.Int32)">
            <summary>
            Creates new toolbar and sets its <see cref="P:Au.toolbar.Satellite"/> = this.
            Returns the new toolbar.
            </summary>
            <param name="ctorFlags">See <see cref="M:Au.toolbar.#ctor(System.String,Au.Types.TBCtor,System.String,System.Int32)"/>.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.InvalidOperationException">This toolbar was attached to another toolbar or was shown as non-satellite toolbar.</exception>
            <remarks>
            Sets toolbar name = <c>this.Name + "^"</c>.
            If this already is a satellite toolbar, just returns its owner.
            </remarks>
        </member>
        <member name="M:Au.toolbar.AutoHideScreenEdge(Au.Triggers.MouseTriggerArgs,Au.Types.Coord,Au.Types.Coord,System.Int32,Au.Types.TBCtor,System.String,System.Int32)">
            <summary>
            Creates new toolbar and sets its <see cref="P:Au.toolbar.Satellite"/> = this. Sets properties for showing at a screen edge.
            Returns the new toolbar.
            </summary>
            <param name="mta">Mouse edge trigger arguments.</param>
            <param name="rangeStart"><i>rangeStart</i> and <i>rangeEnd</i> can be used to specify a smaller range of the edge part. For example, you can create 2 toolbars there: one with 0, 0.5f, other with 0.5f, 1f.</param>
            <param name="rangeEnd"></param>
            <param name="thickness">The visible thickness. Pixels.</param>
            <param name="ctorFlags">See <see cref="M:Au.toolbar.#ctor(System.String,Au.Types.TBCtor,System.String,System.Int32)"/>.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
        </member>
        <member name="M:Au.toolbar.AutoHideScreenEdge(Au.Triggers.TMEdge,Au.Triggers.TMScreen,Au.Types.Coord,Au.Types.Coord,System.Int32,Au.Types.TBCtor,System.String,System.Int32)">
            <summary>
            Creates new toolbar and sets its <see cref="P:Au.toolbar.Satellite"/> = this. Sets properties for showing at a screen edge.
            Returns the new toolbar.
            </summary>
            <param name="edge">Screen edge/part.</param>
            <param name="scrn">Screen index. Default: primary.</param>
            <param name="rangeStart"><i>rangeStart</i> and <i>rangeEnd</i> can be used to specify a smaller range of the edge part. For example, you can create 2 toolbars there: one with 0, 0.5f, other with 0.5f, 1f.</param>
            <param name="rangeEnd"></param>
            <param name="thickness">The visible thickness. Pixels.</param>
            <param name="ctorFlags">See <see cref="M:Au.toolbar.#ctor(System.String,Au.Types.TBCtor,System.String,System.Int32)"/>.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
        </member>
        <member name="T:Au.toolbar.ToolbarItem">
            <summary>
            Represents a button or separator in <see cref="T:Au.toolbar"/>.
            </summary>
            <remarks>
            Most properties cannot be changed while the toolbar is open. Can be changed <b>Tag</b>, <b>Tooltip</b>.
            </remarks>
        </member>
        <member name="P:Au.toolbar.ToolbarItem.ItemType">
            
        </member>
        <member name="P:Au.toolbar.ToolbarItem.Clicked">
            <summary>Gets button action.</summary>
        </member>
        <member name="M:Au.toolbar._AutoSizeNow">
            <summary>
            Measures, resizes and invalidates the toolbar now if need.
            </summary>
        </member>
        <member name="M:Au.toolbar._BorderPadding(Au.Types.TBBorder,System.Int32)">
            <summary>
            Returns DPI-scaled border thickness in client area. Returns 0 if b is not TBBorder.Width1 ... TBBorder.Width4.
            </summary>
        </member>
        <member name="M:Au.toolbar._BorderPadding(System.Nullable{Au.Types.TBBorder})">
            <summary>
            Returns DPI-scaled border thickness in client area. Returns 0 if b is not TBBorder.Width1 ... TBBorder.Width4.
            </summary>
        </member>
        <member name="M:Au.toolbar.#ctor(System.String,Au.Types.TBCtor,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name">
            Toolbar name. Must be valid filename.
            Used for toolbar window name and for settings file name. Also used by <see cref="M:Au.toolbar.find(System.String)"/> and some other functions.
            </param>
            <param name="flags"></param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Empty or invalid name.</exception>
            <remarks>
            Each toolbar has a settings file, where are saved its position, size and context menu settings. This function reads the file if exists, ie if settings changed in the past. See <see cref="M:Au.toolbar.getSettingsFilePath(System.String)"/>. If fails, writes warning to the output and uses default settings.
            
            Sets properties:
            - <see cref="P:Au.MTBase.ActionThread"/> = true.
            - <see cref="P:Au.MTBase.ExtractIconPathFromCode"/> = true.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Hwnd">
            <summary>
            Gets the toolbar window.
            </summary>
        </member>
        <member name="P:Au.toolbar.IsOpen">
            <summary>
            Returns true if the toolbar is open. False if closed or <see cref="M:Au.toolbar.Show(Au.screen)"/> still not called.
            </summary>
        </member>
        <member name="P:Au.toolbar.Name">
            <summary>
            Gets the name of the toolbar.
            </summary>
        </member>
        <member name="M:Au.toolbar.ToString">
            
        </member>
        <member name="P:Au.toolbar.FirstTime">
            <summary>
            True if this toolbar started with default settings. False if loaded saved settings from file.
            </summary>
            <seealso cref="M:Au.toolbar.getSettingsFilePath(System.String)"/>
            <seealso cref="T:Au.Types.TBCtor"/>
        </member>
        <member name="M:Au.toolbar.getSettingsFilePath(System.String)">
            <summary>
            Gets full path of toolbar's settings file. The file may exist or not.
            </summary>
            <param name="toolbarName">Toolbar name.</param>
            <remarks>
            Path: <c>folders.Workspace + $@"\.toolbars\{toolbarName}.json"</c>. If <see cref="P:Au.folders.Workspace"/> is null, uses <see cref="P:Au.folders.ThisAppDocuments"/>.
            </remarks>
        </member>
        <member name="M:Au.toolbar.find(System.String)">
            <summary>
            Finds an open toolbar by <see cref="P:Au.toolbar.Name"/>.
            Returns null if not found or closed or never shown (<see cref="M:Au.toolbar.Show(Au.screen)"/> not called).
            </summary>
            <remarks>
            Finds only toolbars created in the same script and thread.
            
            Does not find satellite toolbars. Use this code: <c>toolbar.find("owner toolbar").Satellite</c>
            </remarks>
        </member>
        <member name="M:Au.toolbar.Add(System.String,System.Action{Au.toolbar.ToolbarItem},Au.Types.MTImage,System.Int32)">
            <summary>
            Adds button.
            Same as <see cref="P:Au.toolbar.Item(System.String,Au.Types.MTImage,System.Int32)"/>.
            </summary>
            <param name="text">Text. Or "Text\0 Tooltip".</param>
            <param name="click">Action called when the button clicked.</param>
            <param name="image"></param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            More properties can be specified later (set properties of the returned <see cref="T:Au.toolbar.ToolbarItem"/> or use <see cref="P:Au.toolbar.Items"/>) or before (<see cref="P:Au.MTBase.ActionThread"/>, <see cref="P:Au.MTBase.ActionException"/>, <see cref="P:Au.MTBase.ExtractIconPathFromCode"/>, <see cref="P:Au.MTBase.PathInTooltip"/>).
            </remarks>
        </member>
        <member name="P:Au.toolbar.Item(System.String,Au.Types.MTImage,System.Int32)">
            <summary>
            Adds button.
            Same as <see cref="M:Au.toolbar.Add(System.String,System.Action{Au.toolbar.ToolbarItem},Au.Types.MTImage,System.Int32)"/>.
            </summary>
            <param name="text">Text. Or "Text\0 Tooltip".</param>
            <param name="image"></param>
            <param name="l_">[](xref:caller_info)</param>
            <value>Action called when the button clicked.</value>
            <remarks>
            More properties can be specified later (set properties of <see cref="P:Au.toolbar.Last"/> <see cref="T:Au.toolbar.ToolbarItem"/> or use <see cref="P:Au.toolbar.Items"/>) or before (<see cref="P:Au.MTBase.ActionThread"/>, <see cref="P:Au.MTBase.ActionException"/>, <see cref="P:Au.MTBase.ExtractIconPathFromCode"/>, <see cref="P:Au.MTBase.PathInTooltip"/>).
            </remarks>
            <example>
            These two are the same.
            <code><![CDATA[
            tb.Add("Example", o => print.it(o));
            tb["Example"] = o => print.it(o);
            ]]></code>
            These four are the same.
            <code><![CDATA[
            var b = tb.Add("Example", o => print.it(o)); b.Tooltip="tt";
            tb.Add("Example", o => print.it(o)).Tooltip="tt";
            tb["Example"] = o => print.it(o); var b=tb.Last; b.Tooltip="tt";
            tb["Example"] = o => print.it(o); tb.Last.Tooltip="tt";
            ]]></code>
            </example>
        </member>
        <member name="M:Au.toolbar.Menu(System.String,System.Action{Au.popupMenu},Au.Types.MTImage,System.Int32)">
            <summary>
            Adds button with drop-down menu.
            </summary>
            <param name="text">Text. Or "Text\0 Tooltip".</param>
            <param name="menu">Action that adds menu items. Called whenever the button clicked.</param>
            <param name="image"></param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            The submenu is an <see cref="T:Au.popupMenu"/> object. It inherits these properties of this toolbar: <see cref="P:Au.MTBase.ExtractIconPathFromCode"/>, <see cref="P:Au.MTBase.ActionException"/>, <see cref="P:Au.MTBase.ActionThread"/>, <see cref="P:Au.MTBase.PathInTooltip"/>.
            </remarks>
            <example>
            <code><![CDATA[
            tb.Menu("Menu", m => {
            	m["M1"]=o=>print.it(o);
            	m["M2"]=o=>print.it(o);
            });
            ]]></code>
            </example>
        </member>
        <member name="M:Au.toolbar.Menu(System.String,System.Func{Au.popupMenu},Au.Types.MTImage,System.Int32)">
            <summary>
            Adds button with drop-down menu.
            </summary>
            <param name="text">Text. Or "Text\0 Tooltip".</param>
            <param name="menu">Func that returns the menu. Called whenever the button clicked.</param>
            <param name="image"></param>
            <param name="l_">[](xref:caller_info)</param>
            <remarks>
            The caller creates the menu (creates the <see cref="T:Au.popupMenu"/> object and adds items) and can reuse it many times. Other overload does not allow to create <b>popupMenu</b> and reuse same object.
            The submenu does not inherit properties of this toolbar.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new popupMenu(); m.AddCheck("C1"); m.AddCheck("C2");
            t.Menu("Menu", () => m);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.toolbar.Separator">
            <summary>
            Adds new vertical separator. Horizontal if vertical toolbar.
            </summary>
        </member>
        <member name="M:Au.toolbar.Group(System.String)">
            <summary>
            Adds new horizontal separator, optionally with text.
            </summary>
            <param name="text">Text. Or "Text\0 Tooltip".</param>
        </member>
        <member name="P:Au.toolbar.Last">
            <summary>
            Gets the last added item.
            </summary>
        </member>
        <member name="P:Au.toolbar.Items">
            <summary>
            Gets added buttons.
            </summary>
            <remarks>
            Allows to set properties of multiple buttons in single place instead of after each 'add button' code line.
            Skips separators and groups.
            </remarks>
        </member>
        <member name="M:Au.toolbar.Show(Au.screen)">
            <summary>
            Shows the toolbar.
            </summary>
            <param name="screen">
            Attach to this screen. For example a screen index (0 the primary, 1 the first non-primary, and so on). Example: <c>screen.index(1)</c>.
            If not specified, the toolbar will be attached to the screen where it is now or where will be moved later.
            Don't use this parameter if this toolbar was created by <see cref="M:Au.toolbar.AutoHideScreenEdge(Au.Triggers.MouseTriggerArgs,Au.Types.Coord,Au.Types.Coord,System.Int32,Au.Types.TBCtor,System.String,System.Int32)"/>, because then screen is already known.
            </param>
            <exception cref="T:System.ArgumentException">The toolbar was created by <b>AutoHideScreenEdge</b>, and now screen specified again.</exception>
            <exception cref="T:System.InvalidOperationException"><b>Show</b> already called.</exception>
            <remarks>
            The toolbar will be moved when the screen moved or resized.
            </remarks>
        </member>
        <member name="M:Au.toolbar.Show(Au.wnd,System.Boolean)">
            <summary>
            Shows the toolbar and attaches to a window.
            </summary>
            <param name="ownerWindow">Window or control. Can belong to any process.</param>
            <param name="clientArea">Let the toolbar position be relative to the client area of the window.</param>
            <exception cref="T:System.InvalidOperationException"><b>Show</b> already called.</exception>
            <exception cref="T:System.ArgumentException"><b>ownerWindow</b> is 0.</exception>
            <remarks>
            The toolbar will be above the window in the Z order; moved when the window moved or resized; hidden when the window hidden, cloaked or minimized; destroyed when the window destroyed.
            </remarks>
        </member>
        <member name="M:Au.toolbar.Show(Au.wnd,Au.Types.ITBOwnerObject)">
            <summary>
            Shows the toolbar and attaches to an object in a window.
            </summary>
            <param name="ownerWindow">Window that contains the object. Can be control. Can belong to any process.</param>
            <param name="oo">A variable of a user-defined class that implements <see cref="T:Au.Types.ITBOwnerObject"/> interface. It provides object location, visibility, etc.</param>
            <exception cref="T:System.InvalidOperationException"><b>Show</b> already called.</exception>
            <exception cref="T:System.ArgumentException"><b>ownerWindow</b> is 0.</exception>
            <remarks>
            The toolbar will be above the window in the Z order; moved when the object or window moved or resized; hidden when the object or window hidden, cloaked or minimized; destroyed when the object or window destroyed.
            </remarks>
        </member>
        <member name="M:Au.toolbar.Show(Au.Triggers.TriggerArgs)">
            <summary>
            Shows the toolbar.
            If ta is <b>WindowTriggerArgs</b>, attaches the toolbar to the trigger window.
            Else if ta != null, calls <see cref="M:Au.Triggers.TriggerArgs.DisableTriggerUntilClosed(Au.toolbar)"/>.
            </summary>
        </member>
        <member name="M:Au.toolbar.Close">
            <summary>
            Destroys the toolbar window.
            </summary>
            <remarks>
            Can be called from any thread.
            Does nothing if not open.
            </remarks>
        </member>
        <member name="E:Au.toolbar.Closed">
            <summary>
            When the toolbar window destroyed.
            </summary>
        </member>
        <member name="M:Au.toolbar.Hide(System.Boolean,Au.Types.TBHide)">
            <summary>
            Adds or removes a reason to temporarily hide the toolbar. The toolbar is hidden if at least one reason exists. See also <seealso cref="M:Au.toolbar.Close"/>.
            </summary>
            <param name="hide">true to hide (add <i>reason</i>), false to show (remove <i>reason</i>).</param>
            <param name="reason">A user-defined reason to hide/unhide. Can be <see cref="F:Au.Types.TBHide.User"/> or a bigger value, eg (TBHide)0x20000, (TBHide)0x40000.</param>
            <exception cref="T:System.InvalidOperationException">
            - The toolbar was never shown (<see cref="M:Au.toolbar.Show(Au.screen)"/> not called).
            - It is a satellite toolbar.
            - Wrong thread. Must be called from the same thread that created the toolbar. See <see cref="P:Au.MTBase.ActionThread"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>reason</i> is less than <see cref="F:Au.Types.TBHide.User"/>.</exception>
            <remarks>
            Toolbars are automatically hidden when the owner window is hidden, minimized, etc. This function can be used to hide toolbars for other reasons.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Hidden">
            <summary>
            Gets current reasons why the toolbar is hidden. Returns 0 if not hidden.
            </summary>
            <remarks>
            Not used with satellite toolbars.
            </remarks>
        </member>
        <member name="P:Au.toolbar.IsOwned">
            <summary>
            Returns true if the toolbar is attached to a window or an object in a window.
            </summary>
        </member>
        <member name="P:Au.toolbar.OwnerWindow">
            <summary>
            Returns the owner top-level window.
            Returns default(wnd) if the toolbar is not owned. See <see cref="P:Au.toolbar.IsOwned"/>.
            </summary>
        </member>
        <member name="P:Au.toolbar.DpiScaling">
            <summary>
            Whether to DPI-scale toolbar size and offsets.
            Default: scale size; scale offsets if anchor is not screen.
            </summary>
            <remarks>
            The unit of measurement of <see cref="P:Au.toolbar.Size"/>, <see cref="P:Au.toolbar.Offsets"/> and some other properties depends on whether scaling is used for that property. If scaling is used, the unit is logical pixels; it is 1/96 inch regardless of screen DPI. If scaling not used, the unit is physical pixels. Screen DPI can be changed in Windows Settings; when it is 100%, logical and physical pixels are equal.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Size">
            <summary>
            Toolbar width and height without non-client area when <see cref="P:Au.toolbar.AutoSize"/> false.
            </summary>
            <remarks>
            Non-client area is border and caption when <see cref="P:Au.toolbar.Border"/> is <b>ThreeD</b>, <b>Thick</b>, <b>Caption</b> or <b>CaptionX</b>.
            
            The unit of measurement depends on <see cref="P:Au.toolbar.DpiScaling"/>.
            
            This property is updated when resizing the toolbar. It is saved.
            </remarks>
            <example>
            <code><![CDATA[
            t.Size = new(300, 40);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.toolbar.Sizable">
            <summary>
            Whether the border can be used to resize the toolbar.
            Default true.
            </summary>
            <remarks>
            This property is in the context menu and is saved.
            </remarks>
        </member>
        <member name="P:Au.toolbar.AutoSize">
            <summary>
            Automatically resize the toolbar to make all buttons visible.
            Default true.
            </summary>
            <remarks>
            This property is in the context menu and is saved.
            </remarks>
        </member>
        <member name="P:Au.toolbar.AutoSizeWrapWidth">
            <summary>
            When <see cref="P:Au.toolbar.AutoSize"/> is true, this is the preferred width at which buttons are moved to the next row. Unlimited if 0.
            </summary>
            <remarks>
            The unit of measurement depends on <see cref="P:Au.toolbar.DpiScaling"/>.
            
            This property is updated when the user resizes the toolbar while <see cref="P:Au.toolbar.AutoSize"/> is true. It is saved.
            
            If layout of this toolbar is vertical, just sets max width.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Anchor">
            <summary>
            Specifies to which owner's edges the toolbar keeps constant distance when moving or resizing the owner.
            </summary>
            <remarks>
            The owner can be a window, screen, control or other object. It is specified when calling <see cref="M:Au.toolbar.Show(Au.screen)"/>.
            This property is in the context menu and is saved.
            </remarks>
            <seealso cref="P:Au.toolbar.Offsets"/>
        </member>
        <member name="P:Au.toolbar.Offsets">
            <summary>
            Specifies distances between edges of the toolbar and edges of its owner, depending on <see cref="P:Au.toolbar.Anchor"/>.
            </summary>
            <remarks>
            Owner is specified when calling <see cref="M:Au.toolbar.Show(Au.screen)"/>. It can be a window, screen, control or other object.
            
            The <see cref="T:Au.Types.TBOffsets"/> type has 4 properties - <b>Top</b>, <b>Bottom</b>, <b>Left</b> and <b>Right</b>, but used are only those included in <see cref="P:Au.toolbar.Anchor"/>. For example, if <b>Anchor</b> is <b>TopLeft</b>, used are only <b>Top</b> and <b>Left</b>.
            
            The unit of measurement depends on <see cref="P:Au.toolbar.DpiScaling"/> and whether anchor is screen.
            
            This property is updated when moving or resizing the toolbar. It is saved.
            </remarks>
            <example>
            <code><![CDATA[
            t.Offsets = new(150, 5, 0, 0);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.toolbar.MiscFlags">
            <summary>
            Miscellaneous options.
            </summary>
            <remarks>
            This property is in the context menu (submenu "More") and is saved.
            </remarks>
        </member>
        <member name="P:Au.toolbar.Transparency">
            <summary>
            Opacity and transparent color.
            </summary>
            <seealso cref="M:Au.wnd.SetTransparency(System.Boolean,System.Nullable{System.Int32},System.Nullable{Au.Types.ColorInt})"/>
            <example>
            <code><![CDATA[
            t.Transparency = (64, null);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.toolbar.NoContextMenu">
            <summary>
            Gets or sets flags to hide some context menu items or menu itself.
            </summary>
        </member>
        <member name="T:Au.trayIcon">
            <summary>
            Shows tray icon.
            </summary>
            <remarks>
            Wraps API <msdn>Shell_NotifyIconW</msdn>, <msdn>NOTIFYICONDATAW</msdn>. More info there.
            
            This thread must dispatch messages.
            
            Can be used by multiple threads (eg one thread adds tray icon and other thread later changes its tooltip).
            
            Creates a hidden window that receives tray icon events (click etc). Also, message WM_CLOSE with non-0 <i>wParam</i> removes the tray icon and calls <see cref="M:System.Environment.Exit(System.Int32)"/> with <i>exitCode</i> = <i>wParam</i>. Example:
            <c>var w = wnd.findFast("task name", "trayIcon"); if(!w.Is0) w.Post(0x10, 1); //WM_CLOSE</c>
            </remarks>
        </member>
        <member name="F:Au.trayIcon.MsgNotify">
            <summary>
            Tray icon notification message.
            </summary>
        </member>
        <member name="M:Au.trayIcon.#ctor(System.Int32,System.Boolean)">
            <param name="id">An id that helps Windows to distinguish multiple tray icons added by same program. Use 0, 1, 2, ... or all 0.</param>
            <param name="disposeOnExit">
            Remove tray icon when process exits (<see cref="E:Au.process.thisProcessExit"/>).
            Note: can't remove if process killed from outside or with <see cref="M:System.Environment.FailFast(System.String)"/> or API <msdn>ExitProcess</msdn> etc. Removes only if process exits naturally or with <see cref="M:System.Environment.Exit(System.Int32)"/> or because of an unhandled exception.
            </param>
        </member>
        <member name="M:Au.trayIcon.Dispose">
            <summary>
            Removes tray icon and disposes other resources.
            </summary>
        </member>
        <member name="P:Au.trayIcon.Visible">
            <summary>
            Gets or sets whether the tray icon is visible.
            </summary>
            <exception cref="T:System.InvalidOperationException">Icon not set.</exception>
        </member>
        <member name="P:Au.trayIcon.Icon">
            <summary>
            Gets or sets icon.
            </summary>
            <remarks>
            To display nice icon at any DPI, the icon should be loaded with <see cref="M:Au.icon.trayIcon(System.Int32)"/> or API <msdn>LoadIconMetric</msdn>, either from a native resource in your app or from an .ico file, which should contain icons of sizes 16, 32 and also recommended 20, 24.
            </remarks>
        </member>
        <member name="P:Au.trayIcon.Tooltip">
            <summary>
            Gets or sets tooltip text.
            </summary>
            <remarks>
            Max length of displayed tooltip text is 127.
            </remarks>
        </member>
        <member name="M:Au.trayIcon.ShowNotification(System.String,System.String,Au.Types.TINFlags,Au.icon)">
            <summary>
            Shows temporary notification window by the tray icon.
            </summary>
            <param name="title">Title, max 63 characters.</param>
            <param name="text">Text, max 255 characters.</param>
            <param name="flags">Standard icon and other flags.</param>
            <param name="icon">Custom icon. Important: use icon of size returned by <see cref="P:Au.trayIcon.notificationIconSize"/>.</param>
            <remarks>
            If the tray icon isn't visible, makes it visible.
            
            No more than one notification at a time can be displayed. If an application attempts to display a notification when one is already being displayed, the new notification is queued and displayed when the older notification goes away.
            
            Users may choose to not show notifications, depending on various conditions. Look in Windows Settings app, Notifications &amp; actions.
            </remarks>
        </member>
        <member name="M:Au.trayIcon.HideNotification">
            <summary>
            Hides notification.
            </summary>
        </member>
        <member name="P:Au.trayIcon.notificationIconSize">
            <summary>
            Gets icon size for <see cref="M:Au.trayIcon.ShowNotification(System.String,System.String,Au.Types.TINFlags,Au.icon)"/>.
            </summary>
        </member>
        <member name="M:Au.trayIcon.Focus">
            <summary>
            Activates taskbar and makes the tray icon focused for keyboard.
            </summary>
            <remarks>
            If the tray icon is in hidden overflow area, makes the area button focused.
            </remarks>
        </member>
        <member name="P:Au.trayIcon.Id">
            <summary>
            Together with <see cref="P:Au.trayIcon.Hwnd"/> identifies this tray icon.
            </summary>
        </member>
        <member name="P:Au.trayIcon.Hwnd">
            <summary>
            A hidden window automatically created for this tray icon to receive its notifications.
            </summary>
        </member>
        <member name="M:Au.trayIcon.WndProc(Au.wnd,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Window procedure of the hidden window that receives tray icon notifications (<see cref="F:Au.trayIcon.MsgNotify"/>) in version 4 format.
            If you override it, call the base function.
            </summary>
        </member>
        <member name="E:Au.trayIcon.Message">
            <summary>
            When received any message from the tray icon.
            </summary>
            <remarks>
            Receives mouse messages, NIN_ messages and some other. See <msdn>Shell_NotifyIconW</msdn>.
            </remarks>
        </member>
        <member name="E:Au.trayIcon.Click">
            <summary>
            When default action should be invoked (on click, Space/Enter, automation/accessibility API).
            </summary>
            <remarks>
            If clicked, the parameter contains message NIN_SELECT (1024) and mouse coordinates. Else NIN_KEYSELECT (1025) and top-left of the tray icon.
            On double click there are two <b>Click</b> events. To distinguish click and double click events, use <see cref="E:Au.trayIcon.Message"/> instead.
            </remarks>
        </member>
        <member name="E:Au.trayIcon.RightClick">
            <summary>
            When context menu should be shown (on right click or Apps key).
            </summary>
        </member>
        <member name="E:Au.trayIcon.MiddleClick">
            <summary>
            When the tray icon clicked with middle button.
            </summary>
        </member>
        <member name="E:Au.trayIcon.NotificationClick">
            <summary>
            When clicked the notification window.
            </summary>
        </member>
        <member name="E:Au.trayIcon.PopupClose">
            <summary>
            When it's time to close custom tooltip etc shown on <see cref="E:Au.trayIcon.PopupOpen"/>.
            </summary>
        </member>
        <member name="E:Au.trayIcon.PopupOpen">
            <summary>
            When it's time to open custom tooltip or some temporary popup window.
            If this event is used, does not show standard tooltip.
            </summary>
        </member>
        <member name="M:Au.trayIcon.GetRect(Au.Types.RECT@)">
            <summary>
            Gets tray icon rectangle in screen.
            Returns false if fails, for example if the icon is in hidden overflow area. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="T:Au.wpfBuilder">
            <summary>
            With this class you can create windows with controls, for example for data input.
            </summary>
            <remarks>
            This class uses WPF (Windows Presentation Foundation). It is in .NET. Creates window at run time. No designer. No WPF and XAML knowledge required, unless you want something advanced.
            
            To start, use snippet wpfSnippet.
            
            Most functions return <c>this</c>, to enable method chaining, aka fluent interface, like with <b>StringBuilder</b>. See example.
            
            A <b>wpfBuilder</b> object can be used to create whole window or some window part, for example a tab page.
            
            The size/position unit in WPF is about 1/96 inch, regardless of screen DPI. For example, if DPI is 96 (100%), 1 unit = 1 physical pixel; if 150% - 1.5 pixel; if 200% - 2 pixels. WPF windows are DPI-scaled automatically when need. Your program's manifest should contain dpiAware=true/PM and dpiAwareness=PerMonitorV2; it is default for scripts/programs created with the script editor of this library.
            
            Note: WPF starts slowly and uses much memory. It is normal if to show the first window in process takes 500-1000 ms and the process uses 30 MB of memory, whereas WinForms takes 250 ms / 10 MB and native takes 50 ms / 2 MB. However WinForms becomes slower than WPF if there are more than 100 controls in window. This library uses WPF because it is the most powerful and works well with high DPI screens.
            
            WPF has many control types, for example <see cref="T:System.Windows.Controls.Button"/>, <see cref="T:System.Windows.Controls.CheckBox"/>, <see cref="T:System.Windows.Controls.TextBox"/>, <see cref="T:System.Windows.Controls.ComboBox"/>, <see cref="T:System.Windows.Controls.Label"/>. Most are in namespaces <b>System.Windows.Controls</b> and <b>System.Windows.Controls.Primitives</b>. Also on the internet you can find many libraries containing WPF controls and themes. For example, search for <i>github awesome dotnet C#</i>. Many libraries are open-source, and most can be found in GitHub (source, info and sometimes compiled files). Compiled files usually can be downloaded from <see href="https://www.nuget.org/"/> as packages. A nupkg file is a zip file. Extract it and use the dll file. Also take the xml and pdb files if available. Note: use .NET 5+ libraries, not old .NET Framework 4.x libraries. Many libraries have both versions. If original library is only Framework 4, look in NuGet for its Core version.
            
            By default don't need XAML. When need, you can load XAML strings and files with <see cref="T:System.Windows.Markup.XamlReader"/>. For example when you want to apply a theme from a library or add something to resources. See examples.
            </remarks>
            <example>
            Dialog window with several controls for data input (code from wpfSnippet).
            <code><![CDATA[
            var b = new wpfBuilder("Example").WinSize(400) //create Window object with Grid control; set window width 400
            	.R.Add("Text", out TextBox text1).Focus() //add label and text box control in first row
            	.R.Add("Combo", out ComboBox combo1).Items("One|Two|Three") //in second row add label and combo box control with items
            	.R.Add(out CheckBox c1, "Check") //in third row add check box control
            	.R.AddOkCancel() //finally add standard OK and Cancel buttons
            	.End();
            if (!b.ShowDialog()) return; //show the dialog and wait until closed; return if closed not with OK button
            print.it(text1.Text, combo1.SelectedIndex, c1.True()); //get user input from control variables
            ]]></code>
            Dialog window with TabControl (code from wpfSnippet).
            <code><![CDATA[
            var b = new wpfBuilder("Window").WinSize(400)
            	.Row(-1).Add(out TabControl tc).Height(300..)
            	.R.StartOkCancel().AddOkCancel().AddButton("Apply", null).Width(70).Disabled().End();
            
            wpfBuilder _Page(string name, WBPanelType panelType = WBPanelType.Grid) {
            	var tp = new TabItem { Header = name };
            	tc.Items.Add(tp);
            	return new wpfBuilder(tp, panelType);
            }
            
            _Page("Page1")
            	.R.Add("Text", out TextBox _)
            	.End();
            
            _Page("Page2")
            	.R.Add("Combo", out ComboBox _).Editable().Items("One|Two|Three")
            	.R.Add(out CheckBox _, "Check")
            	.End();
            
            //tc.SelectedIndex = 1;
            
            b.End();
            if (!b.ShowDialog()) return;
            ]]></code>
            Apply theme from downloaded library HandyControl.
            Also add HandyControl.dll reference.
            <code><![CDATA[
            var xaml = @"<Application xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation' xmlns:hc='https://handyorg.github.io/handycontrol'>
              <Application.Resources>
              <ResourceDictionary>
                <ResourceDictionary.MergedDictionaries>
                  <ResourceDictionary Source='pack://application:,,,/HandyControl;component/Themes/SkinDefault.xaml'/>
                  <ResourceDictionary Source='pack://application:,,,/HandyControl;component/Themes/Theme.xaml'/>
                </ResourceDictionary.MergedDictionaries>
              </ResourceDictionary>
              </Application.Resources>
            </Application>";
            
            System.Windows.Markup.XamlReader.Parse(xaml); //creates and sets Application object for this process. Its resources will be used by WPF windows.
            
            new wpfBuilder("Example").AddOkCancel().ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.End">
            <summary>
            Ends adding controls etc to the window or nested panel (<see cref="M:Au.wpfBuilder.StartGrid(System.Boolean)"/> etc).
            </summary>
            <remarks>
            Always call this method to end a nested panel. For root panel it is optional if using <see cref="M:Au.wpfBuilder.ShowDialog(System.Windows.Window)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Columns(Au.Types.WBGridLength[])">
            <summary>
            Sets column count and widths of current grid.
            </summary>
            <param name="widths">
            Column widths.
            An argument can be:
            - an integer or double value specifies <see cref="P:System.Windows.Controls.ColumnDefinition.Width"/>. Value 0 means auto-size. Negative value is star-width (*), ie fraction of total width of star-sized columns. Examples: <c>50</c>, <c>-0.5</c>.
            - a range specifies <see cref="P:System.Windows.Controls.ColumnDefinition.MinWidth"/> and/or <see cref="P:System.Windows.Controls.ColumnDefinition.MaxWidth"/> and sets width value = -1 (star-sized). Examples: <c>50..150</c>, <c>50..</c> or <c>..150</c>.
            - tuple (double value, Range minMax) specifies width and min/max widths. Example: <c>(-2, 50..)</c>.
            - <see cref="T:System.Windows.Controls.ColumnDefinition"/> can specify these and more properties.
            </param>
            <exception cref="T:System.InvalidOperationException">Columns() in non-grid panel or after an <b>Add</b> function.</exception>
            <remarks>
            If this function not called, the table has 2 columns like <c>.Columns(0, -1)</c>.
            
            If there are star-sized columns, grid width should be defined. Call <see cref="M:Au.wpfBuilder.Width(Au.Types.WBLength,System.String)"/> or <see cref="M:Au.wpfBuilder.Size(Au.Types.WBLength,Au.Types.WBLength,System.String,System.String)"/>. But it the grid is in a cell of another grid, usually it's better to set column width of that grid to a non-zero value, ie let it be not auto-sized.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Row(Au.Types.WBGridLength)">
            <summary>
            Starts new row in current grid.
            </summary>
            <param name="height">
            Row height. Can be:
            - integer or double value specifies <see cref="P:System.Windows.Controls.RowDefinition.Height"/>. Value 0 means auto-size. Negative value is star-width (*), ie fraction of total height of star-sized rows. Examples: <c>50</c>, <c>-0.5</c>.
            - range specifies <see cref="P:System.Windows.Controls.RowDefinition.MinHeight"/> and/or <see cref="P:System.Windows.Controls.RowDefinition.MaxHeight"/> and sets height value = -1 (star-sized). Examples: <c>50..150</c>, <c>50..</c> or <c>..150</c>.
            - tuple (double value, Range minMax) specifies height and min/max heights. Example: <c>(-2, 50..200)</c>.
            - <see cref="T:System.Windows.Controls.RowDefinition"/> can specify these and more properties.
            </param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
            <remarks>
            Calling this function is optional, except when not all cells of previous row are explicitly filled.
            
            If there are star-sized rows, grid height should be defined. Call <see cref="M:Au.wpfBuilder.Height(Au.Types.WBLength,System.String)"/> or <see cref="M:Au.wpfBuilder.Size(Au.Types.WBLength,Au.Types.WBLength,System.String,System.String)"/>. But it the grid is in a cell of another grid, usually it's better to set row height of that grid to a non-zero value, ie let it be not auto-sized.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.R">
            <summary>
            Starts new auto-sized row in current grid. The same as <c>Row(0)</c>. See <see cref="M:Au.wpfBuilder.Row(Au.Types.WBGridLength)"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
        </member>
        <member name="M:Au.wpfBuilder.#ctor(System.String,Au.Types.WBPanelType)">
            <summary>
            This constructor creates <see cref="P:Au.wpfBuilder.Window"/> object with panel of specified type (default is <see cref="T:System.Windows.Controls.Grid"/>).
            </summary>
            <param name="windowTitle">Window title bar text.</param>
            <param name="panelType">Panel type. Default is <see cref="T:System.Windows.Controls.Grid"/>. Later you also can add nested panels of various types with <b>StartX</b> functions.</param>
        </member>
        <member name="M:Au.wpfBuilder.#ctor(System.Windows.FrameworkElement,Au.Types.WBPanelType,System.Boolean)">
            <summary>
            This constructor creates panel of specified type (default is <see cref="T:System.Windows.Controls.Grid"/>) and optionally adds to a container.
            </summary>
            <param name="container">
            Window or some other element that will contain the panel. Should be empty, unless the type supports multiple direct child elements. Can be null.
            If the type (or base type) is <see cref="T:System.Windows.Controls.ContentControl"/> (<see cref="P:Au.wpfBuilder.Window"/>, <see cref="T:System.Windows.Controls.TabItem"/>, ToolTip, etc), <see cref="T:System.Windows.Controls.Primitives.Popup"/> or <see cref="T:System.Windows.Controls.Decorator"/> (eg <b>Border</b>), this function adds the panel to it. If <i>container</i> is null or an element of some other type, need to explicitly add the panel to it, like <c>.Also(b => container.Child = b.Panel)</c> or <c>.Also(b => container.Children.Add(b.Panel))</c> or <c>.Tooltip(btt.Panel)</c> or <c>hwndSource.RootVisual = btt.Panel</c> (the code depends on container type).
            </param>
            <param name="panelType">Panel type. Default is <see cref="T:System.Windows.Controls.Grid"/>. Later you also can add nested panels of various types with <b>StartX</b> functions.</param>
            <param name="setProperties">
            Set some container's properties like other overload does. Default true. Currently sets these properties, and only if container is <b>Window</b>:
            - <see cref="P:System.Windows.Window.SizeToContent"/>, except when container is <b>Canvas</b> or has properties <b>Width</b> and/or <b>Height</b> set.
            - <b>SnapsToDevicePixels</b> = true.
            - <b>WindowStartupLocation</b> = Center.
            - <b>Topmost</b> and <b>Background</b> depending on static properties <see cref="P:Au.wpfBuilder.winTopmost"/> and <see cref="P:Au.wpfBuilder.winWhite"/>.
            </param>
        </member>
        <member name="M:Au.wpfBuilder.ShowDialog(System.Windows.Window)">
            <summary>
            Shows the window and waits until closed.
            </summary>
            <param name="owner"><see cref="P:System.Windows.Window.Owner"/>.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - Missing End() for a StartX() panel.
            </exception>
            <remarks>
            Calls <see cref="M:Au.wpfBuilder.End"/>, sets <see cref="P:System.Windows.Window.Owner"/> and calls <see cref="M:System.Windows.Window.ShowDialog"/>.
            You can instead call these functions directly. Or call <see cref="M:System.Windows.Window.Show"/> to show as non-modal window, ie don't wait. Or add <see cref="P:Au.wpfBuilder.Panel"/> to some container window or other element, etc.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.WinSize(System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})">
            <summary>
            Sets window width and/or height or/and min/max width/height.
            </summary>
            <param name="width">Width or/and min/max width.</param>
            <param name="height">Height or/and min/max height.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - Cannot be after last End().
            - Cannot be after WinRect or WinSaved.
            </exception>
            <remarks>
            Use WPF logical device-independent units, not physical pixels.
            </remarks>
            <seealso cref="M:Au.wpfBuilder.WinRect(Au.Types.RECT)"/>
            <seealso cref="M:Au.wpfBuilder.WinSaved(System.String,System.Action{System.String})"/>
        </member>
        <member name="M:Au.wpfBuilder.WinXY(System.Int32,System.Int32)">
            <summary>
            Sets window location.
            </summary>
            <param name="x">X coordinate in screen. Physical pixels.</param>
            <param name="y">Y coordinate in screen. Physical pixels.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - Cannot be after WinXY, WinRect or WinSaved.
            </exception>
            <remarks>
            With this function use physical pixels, not WPF logical device-independent units.
            Call this function before showing the window. Don't change location/size-related window properties after that.
            Calls <see cref="M:Au.Types.ExtWpf.SetXY(System.Windows.Window,System.Int32,System.Int32)"/>.
            </remarks>
            <seealso cref="M:Au.wpfBuilder.WinSaved(System.String,System.Action{System.String})"/>
        </member>
        <member name="M:Au.wpfBuilder.WinRect(Au.Types.RECT)">
            <summary>
            Sets window rectangle (location and size).
            </summary>
            <param name="r">Rectangle in screen. Physical pixels.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - Cannot be after WinXY, WinRect or WinSaved.
            </exception>
            <remarks>
            With this function use physical pixels, not WPF logical device-independent units.
            Call this function before showing the window. Don't change location/size-related window properties after that.
            Calls <see cref="M:Au.Types.ExtWpf.SetRect(System.Windows.Window,Au.Types.RECT)"/>.
            </remarks>
            <seealso cref="M:Au.wpfBuilder.WinSaved(System.String,System.Action{System.String})"/>
        </member>
        <member name="M:Au.wpfBuilder.WinSaved(System.String,System.Action{System.String})">
            <summary>
            Saves window xy/size/state when closing and restores when opening.
            </summary>
            <param name="saved">String that the <i>save</i> action received previously. Can be null or "", usually first time (still not saved).</param>
            <param name="save">Called when closing the window. Receives string containing window xy/size/state. Can save it in registry, file, anywhere.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - Cannot be after WinXY, WinRect or WinSaved.
            - Window is loaded.
            </exception>
            <remarks>
            Calls <see cref="M:Au.wnd.more.SavedRect.Restore(System.Windows.Forms.Form,System.String,System.Action{System.String})"/>.
            Call this function before showing the window. Don't change location/size-related window properties after that.
            If you use <see cref="M:Au.wpfBuilder.WinSize(System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})"/>, call it before. It is used if size is still not saved. The same if you set window position or state.
            </remarks>
            <example>
            <code><![CDATA[
            string rk = @"HKEY_CURRENT_USER\Software\Au\Test", rv = "winSR";
            var b = new wpfBuilder("Window").WinSize(300)
            	.Row(0).Add("Text", out TextBox _)
            	.R.AddOkCancel()
            	.WinSaved(Microsoft.Win32.Registry.GetValue(rk, rv, null) as string, o => Microsoft.Win32.Registry.SetValue(rk, rv, o))
            	.End();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.WinProperties(System.Nullable{System.Windows.WindowStartupLocation},System.Nullable{System.Windows.ResizeMode},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Windows.WindowState},System.Nullable{System.Windows.WindowStyle},System.Windows.Media.ImageSource,System.Nullable{System.Boolean})">
            <summary>
            Changes various window properties.
            </summary>
            <param name="startLocation"><see cref="T:System.Windows.WindowStartupLocation"/></param>
            <param name="resizeMode"><see cref="P:System.Windows.Window.ResizeMode"/></param>
            <param name="showActivated"><see cref="P:System.Windows.Window.ShowActivated"/></param>
            <param name="showInTaskbar"><see cref="P:System.Windows.Window.ShowInTaskbar"/></param>
            <param name="topmost"><see cref="P:System.Windows.Window.Topmost"/></param>
            <param name="state"><see cref="P:System.Windows.Window.WindowState"/></param>
            <param name="style"><see cref="P:System.Windows.Window.WindowStyle"/></param>
            <param name="icon"><see cref="P:System.Windows.Window.Icon"/>. Example: <c>.WinProperties(icon: BitmapFrame.Create(new Uri(@"d:\icons\file.ico")))</c>.</param>
            <param name="whiteBackground">Set background color = <b>SystemColors.WindowBrush</b> (normally white) if true or <b>SystemColors.ControlBrush</b> (dialog color) if false. See also <see cref="P:Au.wpfBuilder.winWhite"/>, <see cref="M:Au.wpfBuilder.Brush(System.Windows.Media.Brush,System.Windows.Media.Brush)"/>.</param>
            <exception cref="T:System.InvalidOperationException">
            - Container is not Window.
            - <i>startLocation</i> or <i>state</i> used after WinXY, WinRect or WinSaved.
            </exception>
            <remarks>
            The function uses only non-null parameters.
            Or you can change <see cref="P:Au.wpfBuilder.Window"/> properties directly, for example <c>.Also(b => { b.Window.Topmost = true; })</c>.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.Window">
            <summary>
            Gets the top-level window.
            Returns null if container is not <b>Window</b>.
            </summary>
        </member>
        <member name="P:Au.wpfBuilder.Panel">
            <summary>
            Gets current <see cref="T:System.Windows.Controls.Grid"/> or <see cref="T:System.Windows.Controls.StackPanel"/> or etc.
            </summary>
        </member>
        <member name="P:Au.wpfBuilder.Last">
            <summary>
            Gets the last child or descendant element added in current panel. Before that returns current panel.
            </summary>
            <remarks>
            The "set properties of last element" functions set properties of this element.
            </remarks>
        </member>
        <member name="E:Au.wpfBuilder.Loaded">
            <summary>
            When root panel loaded and visible. Once.
            </summary>
            <remarks>
            If the panel is in a <b>TabControl</b>, this event is fired when the tab page is selected/loaded first time.
            When this event is fired, handles of visible <b>HwndHost</b>-based controls are already created.
            </remarks>
        </member>
        <member name="E:Au.wpfBuilder.OkApply">
            <summary>
            When clicked OK or Apply button.
            </summary>
            <remarks>
            <see cref="P:System.Windows.Controls.Button.IsDefault"/> is true if it is OK button.
            The parameter's property <b>Cancel</b> can be used to prevent closing the window.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.gridLines">
            <summary>
            <see cref="P:System.Windows.Controls.Grid.ShowGridLines"/> of grid panels created afterwards.
            To be used at design time only.
            </summary>
        </member>
        <member name="P:Au.wpfBuilder.winTopmost">
            <summary>
            <see cref="P:System.Windows.Window.Topmost"/> of windows created afterwards.
            Usually used at design time only, to make always on top of editor window.
            </summary>
        </member>
        <member name="P:Au.wpfBuilder.winWhite">
            <summary>
            If true, constructor does not change color of windows created afterwards; then color normally is white.
            If false constructor sets standard color of dialogs, usually light gray.
            Default value depends on application's theme and usually is true if using custom theme.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.Options(System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Windows.Thickness})">
            <summary>
            Changes some options for elements added afterwards.
            </summary>
            <param name="modifyPadding">Let <b>Add</b> adjust the <b>Padding</b> property of some controls to align content better when using default theme. Default value of this option depends on application's theme.</param>
            <param name="rightAlignLabels">Right-align <b>Label</b> controls in grid cells.</param>
            <param name="margin">Default margin of elements. If not set, default marging is 3 in all sides. Default margin of nested panels is 0; this option is not used.</param>
        </member>
        <member name="M:Au.wpfBuilder.Add``1(``0@,System.Object,Au.Types.WBAdd)">
            <summary>
            Creates and adds element of type <i>T</i> (control etc of any type).
            </summary>
            <param name="variable">
            Receives element's variable. The function creates element of variable's type. You can use the variable to set element's properties before showing window or/and to get value after.
            Examples: <c>.Add(out CheckBox c1, "Text")</c>, <c>.Add(out _textBox1)</c>. If don't need a variable: <c>.Add(out Label _, "Text")</c> or <c>.Add&lt;Label>("Text")</c>.
            </param>
            <param name="text">
            Text, header or other content. Supported element types (or base types):
            <see cref="T:System.Windows.Controls.TextBox"/> - sets <b>Text</b> property.
            <see cref="T:System.Windows.Controls.ComboBox"/> - sets <b>Text</b> property (see also <see cref="M:Au.wpfBuilder.Items(System.String)"/>).
            <see cref="T:System.Windows.Controls.TextBlock"/> - sets <b>Text</b> property (see also <see cref="M:Au.wpfBuilder.Text(System.Object[])"/>).
            <see cref="T:System.Windows.Controls.PasswordBox"/> - sets <b>Password</b> property.
            <see cref="T:System.Windows.Controls.HeaderedContentControl"/>, <see cref="T:System.Windows.Controls.HeaderedItemsControl"/> - sets <b>Header</b> property.
            <see cref="T:System.Windows.Controls.ContentControl"/> except above two - sets <b>Content</b> property (can be string, other element, etc).
            <see cref="T:System.Windows.Controls.RichTextBox"/> - calls <b>AppendText</b> (see also <see cref="M:Au.wpfBuilder.LoadFile(System.String)"/>).
            </param>
            <param name="flags"></param>
            <exception cref="T:System.NotSupportedException">The function does not support non-null <i>text</i> or flag <i>childOfLast</i> for this element type.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Add``1(System.Object,Au.Types.WBAdd)">
            <summary>
            Creates and adds element of type <i>T</i> (any type). This overload can be used when don't need element's variable.
            </summary>
            <param name="text">Text, header or other content. More info - see other overload.</param>
            <param name="flags"></param>
            <exception cref="T:System.NotSupportedException">The function does not support non-null <i>text</i> or flag <i>childOfLast</i> for this element type.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Add``2(``0@,System.Object,``1@,System.Object,System.Nullable{Au.Types.WBGridLength})">
            <summary>
            Adds 2 elements. One of type <i>T1</i>, other of type <i>T2</i>.
            </summary>
            <param name="var1">Variable of first element. More info - see other overload.</param>
            <param name="text1">Text, header or other content of first element. More info - see other overload.</param>
            <param name="var2">Variable of second element. More info - see other overload.</param>
            <param name="text2">Text, header or other content of second element. More info - see other overload.</param>
            <param name="row2">If not null, after adding first element calls <see cref="M:Au.wpfBuilder.Row(Au.Types.WBGridLength)"/> with this argument.</param>
            <exception cref="T:System.NotSupportedException">If the function does not support non-null <i>text</i> for element type <i>T1</i> or <i>T2</i>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Add``1(System.String,``0@,System.Object,System.Nullable{Au.Types.WBGridLength})">
            <summary>
            Adds 2 elements: <see cref="T:System.Windows.Controls.Label"/> and element of type <i>T</i> (control etc of any type).
            </summary>
            <param name="label">Label text.</param>
            <param name="variable">Variable of second element. More info - see other overload.</param>
            <param name="text">Text, header or other content of second element. More info - see other overload.</param>
            <param name="row2">If not null, after adding first element calls <see cref="M:Au.wpfBuilder.Row(Au.Types.WBGridLength)"/> with this argument.</param>
            <exception cref="T:System.NotSupportedException">If the function does not support non-null <i>text</i> for this element type.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)">
            <summary>
            Adds an existing element (control etc of any type).
            </summary>
            <param name="element"></param>
            <param name="flags"></param>
            <exception cref="T:System.NotSupportedException">The function does not support flag <i>childOfLast</i> for this element type.</exception>
        </member>
        <member name="M:Au.wpfBuilder.AddButton(System.Windows.Controls.Button@,System.Object,System.Action{Au.Types.WBButtonClickArgs},Au.Types.WBBFlags)">
            <summary>
            Adds button with <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click"/> event handler.
            </summary>
            <param name="variable">Receives button's variable.</param>
            <param name="text">Text/content (<see cref="P:System.Windows.Controls.ContentControl.Content"/>).</param>
            <param name="click">Action to call when the button clicked. Its parameter's property <b>Cancel</b> can be used to prevent closing the window when clicked this OK button. Not called if validation fails.</param>
            <param name="flags"></param>
            <remarks>
            If <i>flags</i> contains <b>OK</b> or <b>Apply</b> or <b>Validate</b> and this window contains elements for which was called <see cref="M:Au.wpfBuilder.Validation(System.Func{System.Windows.FrameworkElement,System.String})"/>, on click performs validation; if fails, does not call the <i>click</i> action and does not close the window.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.AddButton(System.Object,System.Action{Au.Types.WBButtonClickArgs},Au.Types.WBBFlags)">
            <summary>
            Adds button with <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click"/> event handler.
            </summary>
            <param name="text">Text/content (<see cref="P:System.Windows.Controls.ContentControl.Content"/>).</param>
            <param name="click">Action to call when the button clicked. Its parameter's property <b>Cancel</b> can be used to prevent closing the window when clicked this OK button. Not called if validation fails.</param>
            <param name="flags"></param>
            <remarks>
            If <i>flags</i> contains <b>OK</b> or <b>Apply</b> or <b>Validate</b> and this window contains elements for which was called <see cref="M:Au.wpfBuilder.Validation(System.Func{System.Windows.FrameworkElement,System.String})"/>, on click performs validation; if fails, does not call the <i>click</i> action and does not close the window.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.AddButton(System.Object,System.Int32)">
            <summary>
            Adds button that closes the window and sets <see cref="P:Au.wpfBuilder.ResultButton"/>.
            </summary>
            <param name="text">Text/content (<see cref="P:System.Windows.Controls.ContentControl.Content"/>).</param>
            <param name="result"><see cref="P:Au.wpfBuilder.ResultButton"/> value when clicked this button.</param>
            <remarks>
            When clicked, sets <see cref="P:Au.wpfBuilder.ResultButton"/> = <i>result</i>, closes the window, and <see cref="M:Au.wpfBuilder.ShowDialog(System.Windows.Window)"/> returns true.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.ResultButton">
            <summary>
            If the window closed with an <see cref="M:Au.wpfBuilder.AddButton(System.Object,System.Int32)"/> button, returns its <i>result</i>. Else returns 0.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.AddOkCancel(System.Windows.Controls.Button@,System.Windows.Controls.Button@,System.Windows.Controls.Button@,System.String,System.String,System.String)">
            <summary>
            Adds OK and/or Cancel and/or Apply buttons.
            </summary>
            <param name="bOK">Variable of OK button.</param>
            <param name="bCancel">Variable of Cancel button.</param>
            <param name="bApply">Variable of Apply button.</param>
            <param name="ok">Text of OK button. If null, does not add the button.</param>
            <param name="cancel">Text of Cancel button. If null, does not add the button.</param>
            <param name="apply">Text of Apply button. If null, does not add the button.</param>
            <remarks>
            Sets properties of OK/Cancel buttons so that click and Enter/Esc close the window; then <see cref="M:Au.wpfBuilder.ShowDialog(System.Windows.Window)"/> returns true on OK, false on Cancel.
            See also event <see cref="E:Au.wpfBuilder.OkApply"/>.
            
            By default adds a right-bottom aligned <see cref="T:System.Windows.Controls.StackPanel"/> and adds buttons in it. If 1 button, adds single button without panel.
            Also does not add panel if already in a stack panel; it can be used to add more buttons. See <see cref="M:Au.wpfBuilder.StartOkCancel"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.AddOkCancel(System.String,System.String,System.String)">
            <summary>
            Adds OK and/or Cancel and/or Apply buttons.
            </summary>
            <param name="ok">Text of OK button. If null, does not add the button.</param>
            <param name="cancel">Text of Cancel button. If null, does not add the button.</param>
            <param name="apply">Text of Apply button. If null, does not add the button.</param>
            <remarks>
            Sets properties of OK/Cancel buttons so that click and Enter/Esc close the window; then <see cref="M:Au.wpfBuilder.ShowDialog(System.Windows.Window)"/> returns true on OK, false on Cancel.
            See also event <see cref="E:Au.wpfBuilder.OkApply"/>.
            
            By default adds a right-bottom aligned <see cref="T:System.Windows.Controls.StackPanel"/> and adds buttons in it. If 1 button, adds single button without panel.
            Also does not add panel if already in a stack panel; it can be used to add more buttons. See <see cref="M:Au.wpfBuilder.StartOkCancel"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.AddSeparator(System.Nullable{System.Boolean})">
            <summary>
            Adds <see cref="T:System.Windows.Controls.Separator"/> control.
            </summary>
            <param name="vertical">If true, adds vertical separator. If false, horizontal. If null (default), adds vertical if in horizontal stack panel, else adds horizontal.</param>
            <remarks>
            In <b>Canvas</b> panel separator's default size is 1x1. Need to set size, like <c>.AddSeparator()[0, 50, 100, 1]</c>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Skip(System.Int32)">
            <summary>
            Adds one or more empty cells in current row of current grid.
            </summary>
            <param name="span">Column count.</param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
            <remarks>
            Actually just changes column index where next element will be added.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.And(System.Double)">
            <summary>
            Sets to add next element in the same grid cell as previous element.
            </summary>
            <param name="width">Width of next element. If negative - width of previous element. Also it adds to the corresponding margin of other element. If 0, simply adds in the same place as previous element.</param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel or in a wrong place.</exception>
            <remarks>
            Can be used to add 2 elements in 1 cell as a cheaper and more concise way than with a <b>StartX</b> function.
            Next element will inherit column index and span of previous element but won't inherit row span.
            </remarks>
            <example>
            <code><![CDATA[
            .Add("File", out TextBox _).And(70).AddButton("Browse...", null)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Span(System.Int32)">
            <summary>
            Sets column span of the last added element.
            </summary>
            <param name="columns">Column count. If -1 or too many, will span all remaining columns in current row. If 0, will share 1 column with next element added in current row; to set element positions use <see cref="M:Au.wpfBuilder.Margin(System.Windows.Thickness)"/>, <see cref="M:Au.wpfBuilder.Width(Au.Types.WBLength,System.String)"/> and <see cref="M:Au.wpfBuilder.Align(System.Nullable{System.Windows.HorizontalAlignment},System.Nullable{System.Windows.VerticalAlignment})"/>; see also <see cref="M:Au.wpfBuilder.And(System.Double)"/>.</param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
            <remarks>
            Also there is an indexer for it. For example, instead of code <c>.Span(2)</c> use code <c>[2]</c>.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.Item(System.Int32)">
            <summary>
            Sets column span of the last added element. Same as <see cref="M:Au.wpfBuilder.Span(System.Int32)"/>.
            </summary>
            <param name="spanColumns">Column count. If -1, all remaining columns.</param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
        </member>
        <member name="M:Au.wpfBuilder.SpanRows(System.Int32)">
            <summary>
            Sets row span of the last added element.
            </summary>
            <param name="rows">Row count.</param>
            <exception cref="T:System.InvalidOperationException">In non-grid panel.</exception>
            <remarks>
            In next row(s) use <see cref="M:Au.wpfBuilder.Skip(System.Int32)"/> to skip cells occupied by this element.
            Often it's better to add a nested panel instead. See <see cref="M:Au.wpfBuilder.StartGrid(System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Also(System.Action{Au.wpfBuilder})">
            <summary>
            Calls your callback function.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Au.wpfBuilder.AlsoAll(System.Action{Au.wpfBuilder,Au.Types.WBAlsoAllArgs})">
            <summary>
            Sets callback function to be called by <b>AddX</b> functions for each element added afterwards. Not called by <b>StartX</b> functions for panels.
            </summary>
            <param name="action">Callback function or null.</param>
            <example>
            <code><![CDATA[
            .AlsoAll((b, e) => {
            	if(b.Last is CheckBox c) { c.IsChecked = true; b.Margin("t1 b1"); }
            })
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Size(Au.Types.WBLength,Au.Types.WBLength,System.String,System.String)">
            <summary>
            Sets width and height of the last added element. Optionally sets alignment.
            </summary>
            <param name="width">Width or/and min/max width.</param>
            <param name="height">Height or/and min/max height.</param>
            <param name="alignX">Horizontal alignment. If not null, calls <see cref="M:Au.wpfBuilder.Align(System.String,System.String)"/>.</param>
            <param name="alignY">Vertical alignment.</param>
            <exception cref="T:System.ArgumentException">Invalid alignment string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Width(Au.Types.WBLength,System.String)">
            <summary>
            Sets width of the last added element. Optionally sets alignment.
            </summary>
            <param name="width">Width or/and min/max width.</param>
            <param name="alignX">Horizontal alignment. If not null, calls <see cref="M:Au.wpfBuilder.Align(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentException">Invalid alignment string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Height(Au.Types.WBLength,System.String)">
            <summary>
            Sets height of the last added element. Optionally sets alignment.
            </summary>
            <param name="height">Height or/and min/max height.</param>
            <param name="alignY">Vertical alignment. If not null, calls <see cref="M:Au.wpfBuilder.Align(System.String,System.String)"/>.</param>
            <exception cref="T:System.ArgumentException">Invalid alignment string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.XY(System.Double,System.Double,System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})">
            <summary>
            Sets position of the last added element in <b>Canvas</b> panel. Optionally sets size.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width">Width or/and min/max width.</param>
            <param name="height">Height or/and min/max height.</param>
            <exception cref="T:System.InvalidOperationException">Current panel is not <b>Canvas</b>.</exception>
            <remarks>
            Only in <see cref="T:System.Windows.Controls.Canvas"/> panel you can set position explicitly. In other panel types it is set automatically and can be adjusted with <see cref="M:Au.wpfBuilder.Margin(System.Windows.Thickness)"/>, <see cref="M:Au.wpfBuilder.Align(System.Nullable{System.Windows.HorizontalAlignment},System.Nullable{System.Windows.VerticalAlignment})"/>, container's <see cref="M:Au.wpfBuilder.AlignContent(System.Nullable{System.Windows.HorizontalAlignment},System.Nullable{System.Windows.VerticalAlignment})"/>, etc.
            </remarks>
        </member>
        <member name="P:Au.wpfBuilder.Item(System.Double,System.Double,System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})">
            <summary>
            Calls <see cref="M:Au.wpfBuilder.XY(System.Double,System.Double,System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})"/>.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.Dock(System.Windows.Controls.Dock)">
            <summary>
            Docks the last added element in <see cref="T:System.Windows.Controls.DockPanel"/>.
            </summary>
            <param name="dock"></param>
            <exception cref="T:System.InvalidOperationException">Current panel is not <b>DockPanel</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Align(System.Nullable{System.Windows.HorizontalAlignment},System.Nullable{System.Windows.VerticalAlignment})">
            <summary>
            Sets horizontal and/or vertical alignment of the last added element.
            </summary>
            <param name="x">Horizontal alignment.</param>
            <param name="y">Vertical alignment.</param>
            <exception cref="T:System.InvalidOperationException">Current panel is <b>Canvas</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Align(System.String,System.String)">
            <summary>
            Sets horizontal and/or vertical alignment of the last added element.
            </summary>
            <param name="x">Horizontal alignment. String that starts with one of these letters, uppercase or lowercase: L (left), R (right), C (center), S (stretch).</param>
            <param name="y">Vertical alignment. String that starts with one of these letters, uppercase or lowercase: T (top), B (bottom), C (center), S (stretch).</param>
            <exception cref="T:System.InvalidOperationException">Current panel is <b>Canvas</b>.</exception>
            <exception cref="T:System.ArgumentException">Invalid alignment string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.AlignContent(System.Nullable{System.Windows.HorizontalAlignment},System.Nullable{System.Windows.VerticalAlignment})">
            <summary>
            Sets content alignment of the last added element.
            </summary>
            <param name="x">Horizontal alignment.</param>
            <param name="y">Vertical alignment.</param>
            <exception cref="T:System.InvalidOperationException">The last added element is not <b>Control</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.AlignContent(System.String,System.String)">
            <summary>
            Sets content alignment of the last added element.
            </summary>
            <param name="x">Horizontal alignment. String like with <see cref="M:Au.wpfBuilder.Align(System.String,System.String)"/>.</param>
            <param name="y">Vertical alignment.</param>
            <exception cref="T:System.InvalidOperationException">The last added element is not <b>Control</b>.</exception>
            <exception cref="T:System.ArgumentException">Invalid alignment string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Margin(System.Windows.Thickness)">
            <summary>
            Sets margin of the last added element.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.Margin(System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Sets margin of the last added element.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.Margin(System.String)">
            <summary>
            Sets margin of the last added element.
            </summary>
            <param name="margin">
            String containing uppercase or lowercase letters for margin sides (L, T, R, B) optionally followed by a number (default 0) and optionally separated by spaces. Or just single number, to set all sides equal.
            Examples: "tb" (top 0, bottom 0), "L5 R15" (left 5, right 15), "2" (all sides 2).
            </param>
            <exception cref="T:System.ArgumentException">Invalid string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Padding(System.Windows.Thickness)">
            <summary>
            Sets padding of the last added control.
            </summary>
            <exception cref="T:System.InvalidOperationException">The last added element is not <b>Control</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Padding(System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Sets padding of the last added control.
            </summary>
            <exception cref="T:System.InvalidOperationException">The last added element is not <b>Control</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Padding(System.String)">
            <summary>
            Sets padding of the last added control.
            </summary>
            <param name="padding">
            String containing uppercase or lowercase letters for padding sides (L, T, R, B) optionally followed by a number (default 0) and optionally separated by spaces. Or just single number, to set all sides equal.
            Examples: "tb" (top 0, bottom 0), "L5 R15" (left 5, right 15), "2" (all sides 2).
            </param>
            <exception cref="T:System.InvalidOperationException">The last added element is not <b>Control</b>.</exception>
            <exception cref="T:System.ArgumentException">Invalid string.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Disabled(System.Boolean)">
            <summary>
            Sets <see cref="P:System.Windows.UIElement.IsEnabled"/> of the last added element.
            </summary>
            <param name="disabled">If true (default), sets IsEnabled=false, else sets IsEnabled=true.</param>
        </member>
        <member name="M:Au.wpfBuilder.Hidden(System.Nullable{System.Boolean})">
            <summary>
            Sets <see cref="P:System.Windows.UIElement.Visibility"/> of the last added element.
            </summary>
            <param name="hidden">If true (default), sets <see cref="T:System.Windows.Visibility"/> <b>Hiden</b>; if false - <b>Visible</b>; if null - <b>Collapsed</b>.</param>
        </member>
        <member name="M:Au.wpfBuilder.Tooltip(System.Object)">
            <summary>
            Sets tooltip text/content/object of the last added element. See <see cref="P:System.Windows.FrameworkElement.ToolTip"/>.
            </summary>
            Text box with simple tooltip.
            <code><![CDATA[
            .R.Add("Example", out TextBox _).Tooltip("Tooltip text")
            ]]></code>
            <example>
            Tooltip with content created by another wpfBuilder.
            <code><![CDATA[
            var btt = new wpfBuilder() //creates tooltip content
            	.R.Add<Image>().Image(icon.stock(StockIcon.INFO))
            	.R.Add<TextBlock>().Text("Some ", "<b>text", ".")
            	.End();
            
            var b = new wpfBuilder("Window").WinSize(300) //creates dialog
            	.R.AddButton("Example", null).Tooltip(btt.Panel)
            	.R.AddOkCancel()
            	.End();
            if (!b.ShowDialog()) return;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Brush(System.Windows.Media.Brush,System.Windows.Media.Brush)">
            <summary>
            Sets background and/or foreground brush (color, gradient, etc) of the last added element.
            </summary>
            <param name="background">Background brush. See <see cref="T:System.Windows.Media.Brushes"/>, <see cref="T:System.Windows.SystemColors"/>. Descendants usually inherit this property.</param>
            <param name="foreground">Foreground brush. Usually sets text color. Descendants usually override this property.</param>
            <exception cref="T:System.NotSupportedException">Last added element must be <b>Control</b>, <b>Panel</b>, <b>Border</b> or <b>TextBlock</b>. With <i>foreground</i> only <b>Control</b> or <b>TextBlock</b>.</exception>
            <example>
            <code><![CDATA[
            .R.Add<Label>("Example1").Brush(Brushes.Cornsilk, Brushes.Green).Border(Brushes.BlueViolet, 1)
            .R.Add<Label>("Example2").Brush(new LinearGradientBrush(Colors.Chocolate, Colors.White, 0))
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Border(System.Windows.Media.Brush,System.Double,System.Nullable{System.Windows.Thickness},System.Nullable{System.Double})">
            <summary>
            Sets border properties of the last added element.
            </summary>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="padding"></param>
            <param name="cornerRadius"></param>
            <exception cref="T:System.NotSupportedException">Last added element must be <b>Control</b> or <b>Border</b>. With <i>cornerRadius</i> only <b>Border</b>.</exception>
            <example>
            <code><![CDATA[
            .R.Add<Label>("Example1").Border(Brushes.BlueViolet, 1, new Thickness(5)).Brush(Brushes.Cornsilk, Brushes.Green)
            .R.Add<Border>().Border(Brushes.Blue, 2, cornerRadius: 3).Add<Label>("Example2", WBAdd.ChildOfLast)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Border">
            <summary>
            Sets standard border properties of the last added element.
            Thickness 1, color SystemColors.ActiveBorderBrush.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.Font(System.String,System.Nullable{System.Double},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>
            Sets font properties of the last added element and its descendants.
            </summary>
            <param name="name"></param>
            <param name="size"></param>
            <param name="bold"></param>
            <param name="italic"></param>
        </member>
        <member name="M:Au.wpfBuilder.Focus">
            <summary>
            Attempts to set focus to the last added element when it'll become visible.
            </summary>
        </member>
        <member name="M:Au.wpfBuilder.BindingContext(System.Object)">
            <summary>
            Sets <see cref="P:System.Windows.FrameworkElement.DataContext"/> property of the last added element.
            Then with <see cref="M:Au.wpfBuilder.Bind(System.Windows.DependencyProperty,System.String)"/> of this and descendant elements don't need to specify data source object because it is set by this function.
            </summary>
            <param name="source">Data source object.</param>
        </member>
        <member name="M:Au.wpfBuilder.Bind(System.Windows.DependencyProperty,System.String)">
            <summary>
            Calls <see cref="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)"/> of the last added element.
            </summary>
            <param name="property">Element's dependency property, for example <c>TextBox.TextProperty</c>.</param>
            <param name="path">Source property name or path, for example <c>nameof(MyData.Property)</c>. Source object should be set with <see cref="M:Au.wpfBuilder.BindingContext(System.Object)"/>.</param>
        </member>
        <member name="M:Au.wpfBuilder.Bind(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
            <summary>
            Calls <see cref="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)"/> of the last added element.
            </summary>
            <param name="property">Element's dependency property, for example <c>TextBox.TextProperty</c>.</param>
            <param name="binding">A binding object, for example <c>new Binding(nameof(MyData.Property))</c> or <c>new Binding(nameof(MyData.Property)) { Source = dataObject }</c>. In the first case, source object should be set with <see cref="M:Au.wpfBuilder.BindingContext(System.Object)"/>.</param>
        </member>
        <member name="M:Au.wpfBuilder.Bind(System.Windows.DependencyProperty,System.Windows.Data.BindingBase,System.Windows.Data.BindingExpressionBase@)">
            <summary>
            Calls <see cref="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)"/> of the last added element and gets its return value.
            </summary>
            <param name="property">Element's dependency property, for example <c>TextBox.TextProperty</c>.</param>
            <param name="binding">A binding object.</param>
            <param name="r">The return value of <b>SetBinding</b>.</param>
        </member>
        <member name="M:Au.wpfBuilder.Bind(System.Windows.DependencyProperty,System.Object,System.String)">
            <summary>
            Calls <see cref="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)"/> of the last added element. Creates <see cref="T:System.Windows.Data.Binding"/> that uses <i>source</i> and <i>path</i>.
            </summary>
            <param name="property">Element's dependency property, for example <c>TextBox.TextProperty</c>.</param>
            <param name="source">Data source object.</param>
            <param name="path">Source property name or path, for example <c>nameof(MyData.Property)</c>.</param>
        </member>
        <member name="M:Au.wpfBuilder.Validation(System.Func{System.Windows.FrameworkElement,System.String})">
            <summary>
            Sets a validation callback function for the last added element.
            </summary>
            <param name="func">Function that returns an error string if element's value is invalid, else returns null.</param>
            <remarks>
            The callback function will be called when clicked button OK or Apply or a button added with flag <see cref="F:Au.Types.WBBFlags.Validate"/>.
            If it returns a non-null string, the window stays open and button's <i>click</i> callback not called. The string is displayed in a tooltip.
            </remarks>
            <example>
            <code><![CDATA[
            var b = new wpfBuilder("Window").WinSize(300)
            	.R.Add("Name", out TextBox tName).Validation(o => string.IsNullOrWhiteSpace(tName.Text) ? "Name cannot be empty" : null)
            	.R.Add("Count", out TextBox tCount).Validation(o => int.TryParse(tCount.Text, out int i1) && i1 >= 0 && i1 <= 100 ? null : "Count must be 0-100")
            	.R.AddOkCancel()
            	.End();
            if (!b.ShowDialog()) return;
            print.it(tName.Text, tCount.Text.ToInt());
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.Checked(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Sets <see cref="P:System.Windows.Controls.Primitives.ToggleButton.IsChecked"/> and <see cref="P:System.Windows.Controls.Primitives.ToggleButton.IsThreeState"/> of the last added check box or radio button.
            </summary>
            <param name="check"></param>
            <param name="threeState"></param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>ToggleButton</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Checked(System.Boolean,System.Windows.Controls.RadioButton)">
            <summary>
            Sets <see cref="P:System.Windows.Controls.Primitives.ToggleButton.IsChecked"/> of the specified <see cref="T:System.Windows.Controls.RadioButton"/>.
            </summary>
            <param name="check"></param>
            <param name="control"></param>
            <remarks>
            Unlike other similar functions, does not use <see cref="P:Au.wpfBuilder.Last"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Readonly(System.Boolean)">
            <summary>
            Sets <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly"/> or <see cref="P:System.Windows.Controls.ComboBox.IsReadOnly"/> of the last added text box or editable combo box.
            </summary>
            <param name="readOnly"></param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>TextBoxBase</b> or <b>ComboBox</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Multiline(System.Nullable{Au.Types.WBLength},System.Windows.TextWrapping)">
            <summary>
            Makes the last added <see cref="T:System.Windows.Controls.TextBox"/> multiline.
            </summary>
            <param name="height">If not null, sets height or/and min/max height.</param>
            <param name="wrap"><see cref="P:System.Windows.Controls.TextBox.TextWrapping"/>.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>TextBox</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Editable">
            <summary>
            Makes the last added <see cref="T:System.Windows.Controls.ComboBox"/> editable.
            </summary>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>ComboBox</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Items(System.String)">
            <summary>
            Splits string and ads substrings as items to the last added <see cref="T:System.Windows.Controls.ItemsControl"/> (<see cref="T:System.Windows.Controls.ComboBox"/>, etc).
            </summary>
            <param name="items">String like <c>"One|Two|Three"</c>.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>ItemsControl</b>.</exception>
            <remarks>
            If it is a non-editable <b>ComboBox</b>, selects the first item. See also <see cref="M:Au.wpfBuilder.Select(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Items(System.Object[])">
            <summary>
            Adds items of any type to the last added <see cref="T:System.Windows.Controls.ItemsControl"/> (<see cref="T:System.Windows.Controls.ComboBox"/>, etc).
            </summary>
            <param name="items">Items of any type (string, WPF element).</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>ItemsControl</b>.</exception>
            <remarks>
            If it is a non-editable <b>ComboBox</b>, selects the first item. See also <see cref="M:Au.wpfBuilder.Select(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Items(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Adds items as <b>IEnumerable</b> to the last added <see cref="T:System.Windows.Controls.ItemsControl"/> (<see cref="T:System.Windows.Controls.ComboBox"/>, etc), with "lazy" option.
            </summary>
            <param name="items">An <b>IEnumerable</b> that contains items (eg array, List) or generates items (eg returned from a yield-return function).</param>
            <param name="lazy">Retrieve items when (if) showing the dropdown part of the <b>ComboBox</b> first time.</param>
            <exception cref="T:System.NotSupportedException">
            - The last added element is not <b>ItemsControl</b>.
            - <i>lazy</i> is true and the last added element is not <b>ComboBox</b>.
            </exception>
        </member>
        <member name="M:Au.wpfBuilder.Items(System.Boolean,System.Action{System.Windows.Controls.ComboBox})">
            <summary>
            Sets callback function that should add items to the last added <see cref="T:System.Windows.Controls.ComboBox"/> later.
            </summary>
            <param name="once">Call the function once. If false, calls on each drop down.</param>
            <param name="onDropDown">Callback function that should add items. Called when (if) showing the dropdown part of the <b>ComboBox</b> first time. Don't need to clear old items.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>ComboBox</b>.</exception>
        </member>
        <member name="M:Au.wpfBuilder.Select(System.Int32)">
            <summary>
            Selects an item of the last added <see cref="T:System.Windows.Controls.Primitives.Selector"/> (<see cref="T:System.Windows.Controls.ComboBox"/>, etc).
            </summary>
            <param name="index">0-based item index</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>Selector</b>.</exception>
            <seealso cref="M:Au.wpfBuilder.Items(System.String)"/>.
        </member>
        <member name="M:Au.wpfBuilder.Select(System.Object)">
            <summary>
            Selects an item of the last added <see cref="T:System.Windows.Controls.Primitives.Selector"/> (<see cref="T:System.Windows.Controls.ComboBox"/>, etc).
            </summary>
            <param name="item">An added item.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>Selector</b>.</exception>
            <seealso cref="M:Au.wpfBuilder.Items(System.String)"/>.
        </member>
        <member name="M:Au.wpfBuilder.Text(System.Object[])">
            <summary>
            Adds inlines to the last added <see cref="T:System.Windows.Controls.TextBlock"/>.
            </summary>
            <param name="inlines">
            Arguments of type:
            - <see cref="T:System.Windows.Documents.Inline"/> of any type, eg <b>Run</b>, <b>Bold</b>, <b>Hyperlink</b>.
            - <b>Action</b> - action to run when the last added <b>Hyperlink</b> clicked (see example).
            - string that starts with "&lt;a>", "&lt;b>", "&lt;i>", "&lt;u>", like <c>"&lt;a>link"</c> - adds inline of type <see cref="T:System.Windows.Documents.Hyperlink"/>, <b>Bold</b>, <b>Italic</b>, <b>Underline</b>.
            - other string - plain text.
            - <see cref="T:System.Windows.UIElement"/>.
            </param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>TextBlock</b>.</exception>
            <exception cref="T:System.ArgumentException">Unsupported argument type.</exception>
            <remarks>
            Adds inlines to <see cref="P:System.Windows.Controls.TextBlock.Inlines"/>.
            </remarks>
            <example>
            <code><![CDATA[
            .R.Add<TextBlock>().Text("Text ", "<b>bold ", "<a>link", new Action(() => print.it("click")), " ", new Run("color") { Foreground=Brushes.Blue, Background=Brushes.Cornsilk, FontSize=20 }, ".")
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.LoadFile(System.String)">
            <summary>
            Loads a web page or RTF text from a file or URL into the last added element.
            </summary>
            <param name="source">File or URL to load. Supported element types and sources:
            <see cref="T:System.Windows.Controls.WebBrowser"/>, <see cref="T:System.Windows.Controls.Frame"/> - URL or file path.
            <see cref="T:System.Windows.Controls.RichTextBox"/> - path of a local .rtf file.
            </param>
            <exception cref="T:System.NotSupportedException">
            - Unsupported element type.
            - <b>RichTextBox</b> source does not end with ".rtf".
            </exception>
            <remarks>
            If fails to load, prints warning. See <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Image(System.Windows.Media.ImageSource,System.Windows.Media.Stretch,System.Windows.Controls.StretchDirection)">
            <summary>
            Loads image into the last added <see cref="T:System.Windows.Controls.Image"/>.
            </summary>
            <param name="source"><see cref="P:System.Windows.Controls.Image.Source"/>.</param>
            <param name="stretch"><see cref="P:System.Windows.Controls.Image.Stretch"/>.</param>
            <param name="stretchDirection"><see cref="P:System.Windows.Controls.Image.StretchDirection"/>.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>Image</b>.</exception>
            <seealso cref="M:Au.icon.ToWpfImage(System.Boolean)"/>
        </member>
        <member name="M:Au.wpfBuilder.Image(System.String,System.Windows.Media.Stretch,System.Windows.Controls.StretchDirection)">
            <summary>
            Loads image from a file or URL into the last added <see cref="T:System.Windows.Controls.Image"/>.
            </summary>
            <param name="source">File path or URL. Sets <see cref="P:System.Windows.Controls.Image.Source"/>.</param>
            <param name="stretch"><see cref="P:System.Windows.Controls.Image.Stretch"/>.</param>
            <param name="stretchDirection"><see cref="P:System.Windows.Controls.Image.StretchDirection"/>.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>Image</b>.</exception>
            <remarks>
            If fails to load, prints warning. See <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.Splitter(System.Boolean,System.Int32,System.Double)">
            <summary>
            Sets vertical or horizontal splitter properties of the last added <see cref="T:System.Windows.Controls.GridSplitter"/>.
            </summary>
            <param name="vertical">If true, resizes columns, else rows.</param>
            <param name="span">How many rows spans vertical splitter, or how many columns spans horizontall splitter. Can be more than row/column count.</param>
            <param name="thickness">Width of vertical splitter or height of horizontal.</param>
            <exception cref="T:System.NotSupportedException">The last added element is not <b>GridSplitter</b>.</exception>
            <example>
            Vertical splitter.
            <code><![CDATA[
            var b = new wpfBuilder("Window").WinSize(400)
            	.Columns(30.., 0, -1) //the middle column is for splitter; the 30 is minimal width
            	.R.Add(out TextBox _)
            	.Add<GridSplitter>().Splitter(true, 2).Brush(Brushes.Orange) //add splitter in the middle column
            	.Add(out TextBox _)
            	.R.Add(out TextBox _).Skip().Add(out TextBox _) //skip the splitter's column
            	.R.AddOkCancel()
            	.End();
            if (!b.ShowDialog()) return;
            ]]></code>
            Horizontal splitter.
            <code><![CDATA[
            var b = new wpfBuilder("Window").WinSize(300, 300)
            	.Row(27..).Add("Row", out TextBox _)
            	.Add<GridSplitter>().Splitter(false, 2).Brush(Brushes.Orange)
            	.Row(-1).Add("Row", out TextBox _)
            	.R.AddOkCancel()
            	.End();
            if (!b.ShowDialog()) return;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.StartGrid(System.Boolean)">
            <summary>
            Adds <see cref="T:System.Windows.Controls.Grid"/> panel (table) that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="childOfLast">See <see cref="F:Au.Types.WBAdd.ChildOfLast"/>.</param>
            <remarks>
            How <see cref="P:Au.wpfBuilder.Last"/> changes: after calling this function it is the grid (<see cref="P:Au.wpfBuilder.Panel"/>); after adding an element it is the element; finally, after calling <b>End</b> it is the grid if <i>childOfLast</i> false, else its parent. The same with all <b>StartX</b> functions.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.StartGrid``1(System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.Grid"/> panel (table) that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="header">Header text/content.</param>
            <remarks>
            How <see cref="P:Au.wpfBuilder.Last"/> changes: after calling this function it is the grid (<see cref="P:Au.wpfBuilder.Panel"/>); after adding an element it is the element; finally, after calling <b>End</b> it is the content control (grid's parent). The same with all <b>StartX</b> functions.
            </remarks>
            <example>
            <code><![CDATA[
            .StartGrid<GroupBox>("Group")
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.StartGrid``1(``0@,System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.Grid"/> panel (table) that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="container">Receives content control's variable. The function creates new control of the type.</param>
            <param name="header">Header text/content.</param>
            <example>
            <code><![CDATA[
            .StartGrid(out Expander g, "Expander").Also(_=> { g.IsExpanded=true; })
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wpfBuilder.StartCanvas(System.Boolean)">
            <summary>
            Adds <see cref="T:System.Windows.Controls.Canvas"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="childOfLast">See <see cref="F:Au.Types.WBAdd.ChildOfLast"/>.</param>
            <remarks>
            For each added control call <see cref="M:Au.wpfBuilder.XY(System.Double,System.Double,System.Nullable{Au.Types.WBLength},System.Nullable{Au.Types.WBLength})"/> or use indexer like <c>[x, y]</c> or <c>[x, y, width, height]</c>.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.StartCanvas``1(System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.Canvas"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="header">Header text/content.</param>
        </member>
        <member name="M:Au.wpfBuilder.StartCanvas``1(``0@,System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.Canvas"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="container">Receives content control's variable. The function creates new control of the type.</param>
            <param name="header">Header text/content.</param>
        </member>
        <member name="M:Au.wpfBuilder.StartDock(System.Boolean)">
            <summary>
            Adds <see cref="T:System.Windows.Controls.DockPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="childOfLast">See <see cref="F:Au.Types.WBAdd.ChildOfLast"/>.</param>
            <remarks>
            For added elements call <see cref="M:Au.wpfBuilder.Dock(System.Windows.Controls.Dock)"/>, maybe except for the last element that fills remaining space.
            </remarks>
        </member>
        <member name="M:Au.wpfBuilder.StartDock``1(System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.DockPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="header">Header text/content.</param>
        </member>
        <member name="M:Au.wpfBuilder.StartDock``1(``0@,System.Object)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.DockPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="container">Receives content control's variable. The function creates new control of the type.</param>
            <param name="header">Header text/content.</param>
        </member>
        <member name="M:Au.wpfBuilder.StartStack(System.Boolean,System.Boolean)">
            <summary>
            Adds <see cref="T:System.Windows.Controls.StackPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="vertical"></param>
            <param name="childOfLast">See <see cref="F:Au.Types.WBAdd.ChildOfLast"/>.</param>
        </member>
        <member name="M:Au.wpfBuilder.StartStack``1(System.Object,System.Boolean)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.StackPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="header">Header text/content.</param>
            <param name="vertical"></param>
        </member>
        <member name="M:Au.wpfBuilder.StartStack``1(``0@,System.Object,System.Boolean)">
            <summary>
            Adds a headered content control (<see cref="T:System.Windows.Controls.GroupBox"/>, <see cref="T:System.Windows.Controls.Expander"/>, etc) with child <see cref="T:System.Windows.Controls.StackPanel"/> panel that will contain elements added with <see cref="M:Au.wpfBuilder.Add(System.Windows.FrameworkElement,Au.Types.WBAdd)"/> etc. Finally call <see cref="M:Au.wpfBuilder.End"/> to return to current panel.
            </summary>
            <param name="container">Receives content control's variable. The function creates new control of the type.</param>
            <param name="header">Header text/content.</param>
            <param name="vertical"></param>
        </member>
        <member name="M:Au.wpfBuilder.StartOkCancel">
            <summary>
            Adds right-bottom-aligned horizontal stack panel (<see cref="M:Au.wpfBuilder.StartStack(System.Boolean,System.Boolean)"/>) for adding OK, Cancel and more buttons.
            When don't need more buttons, use just <see cref="M:Au.wpfBuilder.AddOkCancel(System.Windows.Controls.Button@,System.Windows.Controls.Button@,System.Windows.Controls.Button@,System.String,System.String,System.String)"/>.
            </summary>
            <example>
            <code><![CDATA[
            .StartOkCancel().AddOkCancel().AddButton("Apply", null).Width(70).End()
            ]]></code>
            </example>
        </member>
        <member name="T:Au.clipboard">
            <summary>
            Clipboard functions: copy, paste, get and set clipboard text and other data.
            </summary>
            <remarks>
            This class is similar to the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class, which uses OLE API, works only in STA threads and does not work well in automation scripts. This class uses non-OLE API and works well in automation scripts and any threads.
            
            To set/get clipboard data of non-text formats, use class <see cref="T:Au.clipboardData"/>; to paste, use it with <see cref="M:Au.clipboard.pasteData(Au.clipboardData,Au.Types.OKey)"/>; to copy (get from the active app), use it with <see cref="M:Au.clipboard.copyData(System.Action,System.Boolean,Au.Types.OKey)"/>.
            
            Don't copy/paste in windows of own thread. Call it from another thread. Example in <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.
            </remarks>
        </member>
        <member name="M:Au.clipboard.clear">
            <summary>
            Clears the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="P:Au.clipboard.text">
            <summary>
            Gets or sets clipboard text.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">The 'set' function failed to allocate memory.</exception>
            <remarks>
            The 'get' function calls <see cref="M:Au.clipboardData.getText(System.Int32)"/>. Returns null if there is no text.
            
            Gets/sets only data of text format. For other formats (files, HTML, image, etc) use <see cref="T:Au.clipboardData"/> class.
            </remarks>
        </member>
        <member name="M:Au.clipboard._SetClipboardData_ClipboardViewerIgnore">
            <summary>
            Calls API SetClipboardData("Clipboard Viewer Ignore"). Clipboard must be open.
            Then clipboard manager/viewer/etc programs that are aware of this convention don't try to get our clipboard data while we are pasting.
            Tested apps that support it: Ditto, Clipdiary. Other 5 tested apps don't. Windows 10 Clipboard History doesn't.
            </summary>
        </member>
        <member name="M:Au.clipboard.copy(System.Boolean,Au.Types.OKey)">
            <summary>
            Gets the selected text from the focused app using the clipboard.
            </summary>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.opt.key"/>.
            Uses <see cref="P:Au.Types.OKey.RestoreClipboard"/>, <see cref="P:Au.Types.OKey.NoBlockInput"/>, <see cref="P:Au.Types.OKey.KeySpeedClipboard"/>. Does not use <see cref="P:Au.Types.OKey.Hook"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed. Fails if there is no focused window or if it does not set clipboard data. Fails if other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc).</exception>
            <remarks>
            Also can get file paths, as multiline text.
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard text or file paths, for example if there is no selected text/files.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
        </member>
        <member name="M:Au.clipboard.copyData(System.Action,System.Boolean,Au.Types.OKey)">
            <summary>
            Gets data of any formats from the focused app using the clipboard and a callback function.
            </summary>
            <param name="callback">Callback function. It can get clipboard data of any formats. It can use any clipboard functions, for example the <see cref="T:Au.clipboardData"/> class or the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class. Don't call copy/paste functions.</param>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options">See <see cref="M:Au.clipboard.copy(System.Boolean,Au.Types.OKey)"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed. Fails if there is no focused window or if it does not set clipboard data. Fails if other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc).</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the callback function.</exception>
            <remarks>
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, calls callback function that gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard data.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
            <example>
            <code><![CDATA[
            string text = null; Bitmap image = null; string[] files = null;
            clipboard.copyData(() => { text = clipboardData.getText(); image = clipboardData.getImage(); files = clipboardData.getFiles(); });
            if(text == null) print.it("no text in clipboard"); else print.it(text);
            if(image == null) print.it("no image in clipboard"); else print.it(image.Size);
            if(files == null) print.it("no files in clipboard"); else print.it(files);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboard.paste(System.String,System.String,Au.Types.OKey)">
            <summary>
            Pastes text or HTML into the focused app using the clipboard.
            </summary>
            <param name="text">Text. Can be null if <i>html</i> used.</param>
            <param name="html">
            HTML. Can be full HTML or fragment. See <see cref="M:Au.clipboardData.AddHtml(System.String)"/>. Can be null.
            Can be specified only <i>text</i> or only <i>html</i> or both. If both, will paste <i>html</i> in apps that support it, elsewhere <i>text</i>. If only <i>html</i>, in apps that don't support HTML will paste <i>html</i> as text.
            </param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.opt.key"/>.
            Uses <see cref="P:Au.Types.OKey.RestoreClipboard"/>, <see cref="P:Au.Types.OKey.PasteWorkaround"/>, <see cref="P:Au.Types.OKey.NoBlockInput"/>, <see cref="P:Au.Types.OKey.SleepFinally"/>, <see cref="P:Au.Types.OKey.Hook"/>, <see cref="P:Au.Types.OKey.KeySpeedClipboard"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed. Fails if there is no focused window or if it does not get clipboard data. Fails if other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc).</exception>
            <remarks>
            Sets clipboard data, sends keys Ctrl+V, waits until the focused app gets clipboard data, finally restores clipboard data.
            Fails (exception) if nothing gets clipboard data in several seconds.
            Works with console windows too, even if they don't support Ctrl+V.
            A clipboard viewer/manager program can make this function slower and less reliable, unless it supports <see cref="P:Au.Types.ClipFormats.ClipboardViewerIgnore"/> or gets clipboard data with a delay.
            Possible problems with some virtual PC programs. Either pasting does not work in their windows, or they use a hidden clipboard viewer that makes this function slower and less reliable.
            </remarks>
            <seealso cref="M:Au.keys.sendt(System.String,System.String)"/>
            <example>
            <code><![CDATA[
            clipboard.paste("Example\r\n");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboard.pasteData(Au.clipboardData,Au.Types.OKey)">
            <summary>
            Pastes data added to an <see cref="T:Au.clipboardData"/> variable into the focused app using the clipboard.
            More info: <see cref="M:Au.clipboard.paste(System.String,System.String,Au.Types.OKey)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed. Fails if there is no focused window or if it does not get clipboard data. Fails if other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc).</exception>
            <example>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            clipboard.pasteData(new clipboardData().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboard.Paste_(System.Object,Au.Types.OKey,Au.wnd)">
            <summary>
            Used by <see cref="T:Au.clipboard"/> and <see cref="T:Au.keys"/>.
            The caller should block user input (if need), release modifier keys, get optk/wFocus, sleep finally (if need).
            </summary>
            <param name="data">string or clipboardData.</param>
            <param name="optk"></param>
            <param name="wFocus"></param>
        </member>
        <member name="T:Au.clipboard._ClipboardListener">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            For it subclasses our clipboard owner window and uses clipboard messages. Does not unsubclass.
            </summary>
        </member>
        <member name="P:Au.clipboard._ClipboardListener.Success">
            <summary>
            The clipboard message has been received. Probably the target window responded to the Ctrl+C or Ctrl+V.
            On Paste it is unreliable because of clipboard viewers/managers/etc. The caller also must check IsBadWindow.
            </summary>
        </member>
        <member name="F:Au.clipboard._ClipboardListener.IsBadWindow">
            <summary>
            On Paste, true if probably not the target process retrieved clipboard data. Probably a clipboard viewer/manager/etc.
            Not used on Copy.
            </summary>
        </member>
        <member name="F:Au.clipboard._ClipboardListener.FailedToSetData">
            <summary>
            Exception thrown/catched when failed to set clipboard data.
            </summary>
        </member>
        <member name="M:Au.clipboard._ClipboardListener.#ctor(System.Boolean,System.Object,Au.wnd,Au.wnd)">
            <summary>
            Subclasses clipOwner.
            </summary>
            <param name="paste">true if used for paste, false if for copy.</param>
            <param name="data">If used for paste, can be string containing Unicode text or int/string dictionary containing clipboard format/data.</param>
            <param name="clipOwner">Our clipboard owner window.</param>
            <param name="wFocus">The target control or window.</param>
        </member>
        <member name="M:Au.clipboard._ClipboardListener.Wait(Au.keys.Internal_.SendCopyPaste@)">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            Throws AuException on timeout (3 s normally, 28 s if the target window is hung).
            </summary>
            <param name="ctrlKey">The variable that was used to send Ctrl+V or Ctrl+C. This function may call Release to avoid too long Ctrl down.</param>
        </member>
        <member name="T:Au.clipboard.OpenClipboard_">
            <summary>
            Opens and closes clipboard using API OpenClipboard and CloseClipboard.
            Constructor tries to open for 10 s, then throws AuException.
            If the 'createOwner' parameter is true, creates temporary message-only clipboard owner window.
            If the 'noOpenNow' parameter is true, does not open, only creates owner if need.
            Dispose() closes clipboard and destroys the owner window.
            </summary>
        </member>
        <member name="M:Au.clipboard.OpenClipboard_.Reopen(System.Boolean)">
            <summary>
            Opens again.
            Must be closed.
            Owner window should be not destroyed; does not create again.
            </summary>
            <param name="noThrow">If fails, return false, no exception. Also then waits 1 s instead of 10 s.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="T:Au.clipboard._SaveRestore">
            <summary>
            Saves and restores clipboard data.
            Clipboard must be open. Don't need to call EmptyClipboard before Restore.
            </summary>
        </member>
        <member name="T:Au.clipboard._DisableClipboardHistory">
            <summary>
            Temporarily disables Windows 10 Clipboard History.
            Note: before disabling, we must open clipboard, else Clipboard History could be suspended while it has clipboard open.
            </summary>
        </member>
        <member name="T:Au.clipboardData">
            <summary>
            Sets or gets clipboard data in multiple formats.
            </summary>
            <remarks>
            The <b>AddX</b> functions add data to the variable (not to the clipboard). Then <see cref="M:Au.clipboardData.SetClipboard"/> copies the added data to the clipboard. Also you can use the variable with <see cref="M:Au.clipboard.pasteData(Au.clipboardData,Au.Types.OKey)"/>.
            The static <b>GetX</b> functions get data directly from the clipboard.
            </remarks>
            <example>
            Get bitmap image from clipboard.
            <code><![CDATA[
            var image = clipboardData.getImage();
            if(image == null) print.it("no image in clipboard"); else print.it(image.Size);
            ]]></code>
            Set clipboard data in two formats: text and image.
            <code><![CDATA[
            new clipboardData().AddText("text").AddImage(Image.FromFile(@"q:\file.png")).SetClipboard();
            ]]></code>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            clipboard.pasteData(new clipboardData().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            Copy data in two formats: HTML and text.
            <code><![CDATA[
            string html = null, text = null;
            clipboard.copyData(() => { html = clipboardData.getHtml(); text = clipboardData.getText(); });
            print.it(html); print.it(text);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboardData.AddText(System.String,System.Int32)">
            <summary>
            Adds text.
            Returns this.
            </summary>
            <param name="text">Text.</param>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Text.Encoding.GetBytes(System.String)"/>, which is called if encoding is not UTF-16.</exception>
        </member>
        <member name="M:Au.clipboardData.AddBinary(System.Byte[],System.Int32)">
            <summary>
            Adds data of any format as byte[].
            Returns this.
            </summary>
            <param name="data">byte[] containing data.</param>
            <param name="format">Clipboard format id. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
        </member>
        <member name="M:Au.clipboardData.AddImage(System.Drawing.Image)">
            <summary>
            Adds image. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns this.
            </summary>
            <param name="image">Image. Must be <see cref="T:System.Drawing.Bitmap"/>, else exception.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.clipboardData.AddHtml(System.String)">
            <summary>
            Adds HTML text. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns this.
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            <code><![CDATA[
            d.AddHtml("<i>italy</i>");
            d.AddHtml("<html><body><i>italy</i></body></html>");
            d.AddHtml("<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboardData.AddRtf(System.String)">
            <summary>
            Adds rich text (RTF). Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns this.
            </summary>
            <param name="rtf">Rich text. Simplest example: <c>@"{\rtf1 text\par}"</c>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.clipboardData.AddFiles(System.String[])">
            <summary>
            Adds list of files to copy/paste. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns this.
            </summary>
            <param name="files">One or more file paths.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.clipboardData.SetClipboard">
            <summary>
            Copies the added data of all formats to the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <remarks>
            Calls API <msdn>OpenClipboard</msdn>, <msdn>EmptyClipboard</msdn>, <msdn>SetClipboardData</msdn> and <msdn>CloseClipboard</msdn>.
            </remarks>
        </member>
        <member name="M:Au.clipboardData.SetOpenClipboard(System.Boolean,System.Int32)">
            <summary>
            Copies the added data of all formats to the clipboard which is open/owned by this thread.
            </summary>
            <param name="renderLater">Call API <msdn>SetClipboardData</msdn>(format, default). When/if some app will try to get clipboard data, the first time your clipboard owner window will receive <msdn>WM_RENDERFORMAT</msdn> message and should call <c>SetOpenClipboard(false);</c>.</param>
            <param name="format">Copy data only of this format. If 0 (default), of all formats.</param>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <exception cref="T:Au.Types.AuException">Failed to set clipboard data.</exception>
            <remarks>
            This function is similar to <see cref="M:Au.clipboardData.SetClipboard"/>. It calls API <msdn>SetClipboardData</msdn> and does not call <b>OpenClipboard</b>, <b>EmptyClipboard</b>, <b>CloseClipboard</b>. The clipboard must be open and owned by a window of this thread.
            </remarks>
        </member>
        <member name="M:Au.clipboardData.SetText_(System.String)">
            <summary>
            Copies Unicode text to the clipboard without open/empty/close.
            </summary>
        </member>
        <member name="M:Au.clipboardData.CreateHtmlFormatData_(System.String)">
            <summary>
            Converts HTML string to byte[] containing data in clipboard format "HTML Format".
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            HTML examples.
            <code><![CDATA[
            "<i>italy</i>"
            "<html><body><i>italy</i></body></html>"
            "<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>"
            ]]></code>
            </example>
        </member>
        <member name="M:Au.clipboardData.GetText_(System.Int32)">
            <summary>
            Gets clipboard text without open/close.
            If format is 0, tries CF_UNICODETEXT and CF_HDROP.
            </summary>
        </member>
        <member name="M:Au.clipboardData.getText(System.Int32)">
            <summary>
            Gets text from the clipboard.
            Returns null if there is no text.
            </summary>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            If 0, tries to get text (<see cref="F:Au.Types.ClipFormats.Text"/>) or file paths (<see cref="F:Au.Types.ClipFormats.Files"/>; returns multiline text).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.getBinary(System.Int32)">
            <summary>
            Gets clipboard data of any format as byte[].
            Returns null if there is no data of the specified format.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.getImage">
            <summary>
            Gets image from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>.</exception>
        </member>
        <member name="M:Au.clipboardData.getHtml">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.getHtml(System.Int32@,System.Int32@,System.String@)">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <param name="fragmentStart">Fragment start index in the returned string.</param>
            <param name="fragmentLength">Fragment length.</param>
            <param name="sourceURL">Source URL, or null if unavailable.</param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.getRtf">
            <summary>
            Gets rich text (RTF) from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.getFiles">
            <summary>
            Gets file paths from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.clipboardData.HdropToFiles_(System.IntPtr)">
            <summary>
            Gets file paths from HDROP.
            Returns array of 0 or more non-null elements.
            </summary>
        </member>
        <member name="M:Au.clipboardData.contains(System.Int32)">
            <summary>
            Returns true if the clipboard contains data of the specified format.
            </summary>
            <param name="format">Clipboard format id. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>IsClipboardFormatAvailable</msdn>.</remarks>
        </member>
        <member name="M:Au.clipboardData.contains(System.Int32[])">
            <summary>
            Returns the first of the specified formats that is in the clipboard.
            Returns 0 if the clipboard is empty. Returns -1 if the clipboard contains data but not in any of the specified formats.
            </summary>
            <param name="formats">Clipboard format ids. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>GetPriorityClipboardFormat</msdn>.</remarks>
        </member>
        <member name="T:Au.inputBlocker">
            <summary>
            Blocks keyboard and/or mouse input events from reaching applications.
            </summary>
            <remarks>
            Uses keyboard and/or mouse hooks. Does not use API <b>BlockInput</b>, it does not work on current Windows versions.
            Blocks hardware-generated events and software-generated events, except generated by functions of this library.
            Functions of this library that send keys or text use this class internally, to block user-pressed keys and resend them afterwards (see <see cref="P:Au.inputBlocker.ResendBlockedKeys"/>).
            Does not block:
            - In windows of the same thread that started blocking. For example, if your script shows a message box, the user can click its buttons.
            - In windows of higher [](xref:uac) integrity level (IL) processes, unless this process has uiAccess IL.
            - In special desktops/screens, such as when you press Ctrl+Alt+Delete or launch an admin program that requires UAC elevation. See also <see cref="P:Au.inputBlocker.ResumeAfterCtrlAltDelete"/>.
            - Some Windows hotkeys, such as Ctrl+Alt+Delete and Win+L.
            - Keyboard hooks don't work in windows of this process if this process uses direct input or raw input API.
            
            To stop blocking, can be used the 'using' pattern, like in the example. Or the 'try/finally' pattern, where the finally block calls <see cref="M:Au.inputBlocker.Dispose"/> or <see cref="M:Au.inputBlocker.Stop(System.Boolean)"/>. Also automatically stops when this thread ends. Users can stop with Ctrl+Alt+Delete.
            </remarks>
            <example>
            <code><![CDATA[
            using(new inputBlocker(BIEvents.All)) {
            	print.it("blocked");
            	5.s();
            }
            print.it("not blocked");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.inputBlocker.#ctor">
            <summary>
            This constructor does nothing (does not call <see cref="M:Au.inputBlocker.Start(Au.Types.BIEvents)"/>).
            </summary>
        </member>
        <member name="M:Au.inputBlocker.#ctor(Au.Types.BIEvents)">
            <summary>
            This constructor calls <see cref="M:Au.inputBlocker.Start(Au.Types.BIEvents)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"><i>what</i> is 0.</exception>
        </member>
        <member name="M:Au.inputBlocker.Start(Au.Types.BIEvents)">
            <summary>
            Starts blocking.
            </summary>
            <exception cref="T:System.ArgumentException"><i>what</i> is 0.</exception>
            <exception cref="T:System.InvalidOperationException">Already started.</exception>
        </member>
        <member name="M:Au.inputBlocker.Dispose">
            <summary>
            Calls <see cref="M:Au.inputBlocker.Stop(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.inputBlocker.Finalize">
            
        </member>
        <member name="M:Au.inputBlocker.Stop(System.Boolean)">
            <summary>
            Stops blocking.
            Plays back blocked keys if need. See <see cref="P:Au.inputBlocker.ResendBlockedKeys"/>.
            Does nothing if currently is not blocking.
            </summary>
            <param name="discardBlockedKeys">Do not play back blocked key-down events recorded because of <see cref="P:Au.inputBlocker.ResendBlockedKeys"/>.</param>
        </member>
        <member name="P:Au.inputBlocker.ResumeAfterCtrlAltDelete">
            <summary>
            Continue blocking when returned from a special screen where blocking is disabled: Ctrl+Alt+Delete, [](xref:uac) consent, etc.
            </summary>
        </member>
        <member name="P:Au.inputBlocker.ResendBlockedKeys">
            <summary>
            Record blocked keys, and play back when stopped blocking.
            </summary>
            <remarks>
            Will not play back if: 1. The blocking time is &gt; 10 seconds; then plays back only key-up events. 2. Detected Ctrl+Alt+Delete, [](xref:uac) consent or some other special screen. 3. Called <see cref="P:Au.inputBlocker.Pause"/>.
            </remarks>
        </member>
        <member name="P:Au.inputBlocker.DontBlockInjected">
            <summary>
            Don't block software-generated key/mouse events.
            If false (default), only events generated by functions of this library are not blocked.
            </summary>
        </member>
        <member name="P:Au.inputBlocker.Pause">
            <summary>
            Gets or sets whether the blocking is paused.
            </summary>
            <remarks>
            The 'set' function is much faster than <see cref="M:Au.inputBlocker.Stop(System.Boolean)"/>/<see cref="M:Au.inputBlocker.Start(Au.Types.BIEvents)"/>. Does not remove hooks etc. Discards blocked keys.
            </remarks>
        </member>
        <member name="T:Au.keys">
            <summary>
            Keyboard functions: send virtual keystrokes and text to the active window, get key states.
            </summary>
            <remarks>
            The main function is <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>. Most documentation is there. See also <see cref="M:Au.keys.sendt(System.String,System.String)"/>. These functions use <see cref="P:Au.opt.key"/>. Alternatively can be used <b>keys</b> variables, see <see cref="M:Au.keys.#ctor(Au.Types.OKey)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            keys.send("Ctrl+Shift+Left"); //press Ctrl+Shift+Left
            
            opt.key.KeySpeed = 300; //set options for static functions
            keys.send("Ctrl+A Del Tab*3", "!text", "Enter", 500); //press Ctrl+A, Del, Tab 3 times, send text, Enter, wait 500 ms
            
            keys.sendt("text\r\n"); //send text that ends with newline
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.#ctor(Au.Types.OKey)">
            <param name="cloneOptions">Options to be copied to <see cref="P:Au.keys.Options"/> of this variable. If null, uses default options.</param>
            <example>
            <code><![CDATA[
            var k = new keys(opt.init.key);
            k.Options.KeySpeed = 50;
            k.AddKeys("Tab // Space").AddRepeat(3).AddText("text").AddKey(KKey.Enter).AddSleep(500);
            k.Send(); //sends and clears the variable
            k.Add("Tab // Space*3", "!text", KKey.Enter, 500); //the same as the above k.AddKeys... line
            for(int i = 0; i < 5; i++) k.Send(true); //does not clear the variable
            ]]></code>
            </example>
        </member>
        <member name="P:Au.keys.Options">
            <summary>
            Options used by this variable.
            </summary>
        </member>
        <member name="M:Au.keys.AddKeys(System.String)">
            <summary>
            Adds keystrokes to the internal collection. They will be sent by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="keys_">
            Key names and operators, like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>. Can be null or "".
            Example: <c>"Tab Ctrl+V Alt+(E P) Left*3 Space a , 5 #5 $abc"</c>.
            If has prefix "!" or "%", calls <see cref="M:Au.keys.AddText(System.String,System.String)"/>; "!" for text, "%" for HTML.
            </param>
            <exception cref="T:System.ArgumentException">Error in <i>keys_</i> string, for example an unknown key name.</exception>
        </member>
        <member name="M:Au.keys.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})">
            <summary>
            Adds single key, specified as <see cref="T:Au.Types.KKey"/>, to the internal collection. It will be sent by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid <i>key</i> (0).</exception>
        </member>
        <member name="M:Au.keys.AddKey(Au.Types.KKey,System.UInt16,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Adds single key to the internal collection. Allows to specify scan code and whether it is an extended key. It will be sent by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255. Can be 0.</param>
            <param name="scanCode">Scan code of the physical key. Scan code values are 1-127, but this function allows 1-0xffff. Can be 0.</param>
            <param name="extendedKey">true if the key is an extended key.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid scan code.</exception>
        </member>
        <member name="M:Au.keys.AddRaw_(Au.Types.KKey,System.UInt16,System.Byte)">
            <summary>
            Adds key down or up event.
            </summary>
            <param name="vk"></param>
            <param name="scan"></param>
            <param name="siFlags">SendInput flags.</param>
        </member>
        <member name="M:Au.keys.SendBlocked_(System.Boolean)">
            <summary>
            Sends key events added by inputBlocker -> AddRaw_.
            Simply calls Api.SendInput. No options, no sleep, etc.
            If new events added while sending, sends them too, until there are no new events added.
            </summary>
            <param name="onlyUp">Send only 'up' events.</param>
        </member>
        <member name="M:Au.keys.AddText(System.String,System.String)">
            <summary>
            Adds text or HTML. It will be sent by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="text">Text. Can be null.</param>
            <param name="html">
            HTML. Can be full HTML or fragment. See <see cref="M:Au.clipboardData.AddHtml(System.String)"/>.
            Can be specified only <i>text</i> or only <i>html</i> or both. If both, will paste <i>html</i> in apps that support it, elsewhere <i>text</i>. If only <i>html</i>, in apps that don't support HTML will paste <i>html</i> as text.
            </param>
            <remarks>
            To send text can use keys, characters or clipboard, depending on <see cref="P:Au.opt.key"/> and text. If <i>html</i> not null, uses clipboard.
            </remarks>
        </member>
        <member name="M:Au.keys.AddText(System.String,Au.Types.OKeyText)">
            <summary>
            Adds text with explicitly specified sending method (keys, characters or paste).
            Returns this.
            </summary>
            <param name="text">Text. Can be null.</param>
            <param name="how">Overrides <see cref="P:Au.Types.OKey.TextHow"/>.</param>
        </member>
        <member name="M:Au.keys.AddClipboardData(Au.clipboardData)">
            <summary>
            Adds clipboard data, for example several formats. It will be pasted by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="cd">Clipboard data.</param>
        </member>
        <member name="M:Au.keys.AddAction(System.Action)">
            <summary>
            Adds a callback function.
            Returns this.
            </summary>
            <param name="a"></param>
            <remarks>
            The callback function will be called by <see cref="M:Au.keys.SendIt(System.Boolean)"/> and can do anything except sending keys and copy/paste.
            </remarks>
        </member>
        <member name="M:Au.keys.AddRepeat(System.Int32)">
            <summary>
            Adds the repeat-key operator. Then <see cref="M:Au.keys.SendIt(System.Boolean)"/> will send the last added key the specified number of times.
            Returns this.
            </summary>
            <param name="count">Repeat count.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>count</i> &gt;10000 or &lt;0.</exception>
            <exception cref="T:System.ArgumentException">The last added item is not key. Can repeat only single key; cannot repeat text etc.</exception>
        </member>
        <member name="M:Au.keys.AddSleep(System.Int32)">
            <summary>
            Adds a short pause. Then <see cref="M:Au.keys.SendIt(System.Boolean)"/> will sleep (wait).
            Returns this.
            </summary>
            <param name="timeMS">Time to sleep, milliseconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMS</i> &gt;10000 (1 minute) or &lt;0.</exception>
        </member>
        <member name="M:Au.keys.Add(Au.Types.KKeysEtc[])">
            <summary>
            Adds keystrokes, text, sleep and other events to the internal collection. They will be sent/executed by <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            Returns this.
            </summary>
            <param name="keysEtc">The same as with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.</param>
        </member>
        <member name="M:Au.keys.SendIt(System.Boolean)">
            <summary>
            Sends keys, text and executes other events added with the <b>AddX</b> functions.
            </summary>
            <param name="canSendAgain">Don't clear the internal collection. If true, this function then can be called again (eg in loop) to send/execute the same keys etc. If false (default), clears the added keys etc; then you can call <b>AddX</b> functions and <b>Send</b> again.</param>
            <exception cref="T:System.ArgumentException"><i>canSendAgain</i> is true and <i>keys_</i> end with + or (.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc). When sending text, fails if there is no focused window.</exception>
        </member>
        <member name="E:Au.keys.Pasting">
            <summary>
            Before pasting text through clipboard.
            </summary>
        </member>
        <member name="T:Au.keys.more">
            <summary>
            Miscellaneous rarely used keyboard-related functions.
            </summary>
        </member>
        <member name="M:Au.keys.more.parseKeyName(System.String)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="keyName">Key name, like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.</param>
        </member>
        <member name="M:Au.keys.more.ParseKeyNameThrow_(System.String)">
            <summary>
            Calls <see cref="M:Au.keys.more.parseKeyName(System.String)"/> and throws ArgumentException if invalid key string.
            </summary>
            <param name="keyName"></param>
        </member>
        <member name="M:Au.keys.more.parseKeyName(System.String,System.Int32,System.Int32)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="s">String containing key name, like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.</param>
            <param name="startIndex">Key name start index in <i>s</i>.</param>
            <param name="length">Key name length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid start index or length.</exception>
        </member>
        <member name="M:Au.keys.more.parseKeysString(System.String)">
            <summary>
            Converts keys string to <see cref="T:Au.Types.KKey"/> array.
            </summary>
            <param name="keys_">String containing one or more key names, like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>. Operators are not supported.</param>
            <exception cref="T:System.ArgumentException">Error in <i>keys_</i> string.</exception>
        </member>
        <member name="M:Au.keys.more.parseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)">
            <summary>
            Converts string to <see cref="T:Au.Types.KKey"/> and <see cref="T:Au.Types.KMod"/>.
            For example, if s is "Ctrl+Left", sets mod=KMod.Ctrl, key=KKey.Left.
            Returns false if the string is invalid.
            </summary>
            <remarks>
            Key names are like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.
            Must be single non-modifier key, preceded by zero or more of modifier keys Ctrl, Shift, Alt, Win, all joined with +.
            Valid hotkey examples: <c>"A"</c>, <c>"a"</c>, <c>"7"</c>, <c>"F12"</c>, <c>"."</c>, <c>"End"</c>, <c>"Ctrl+D"</c>, <c>"Ctrl+Alt+Shift+Win+Left"</c>, <c>" Ctrl + U "</c>.
            Invalid hotkey examples: null, "", <c>"A+B"</c>, <c>"Ctrl+A+K"</c>, <c>"A+Ctrl"</c>, <c>"Ctrl+Shift"</c>, <c>"Ctrl+"</c>, <c>"NoSuchKey"</c>, <c>"tab"</c>.
            </remarks>
        </member>
        <member name="M:Au.keys.more.parseHotkeyString(System.String,System.Windows.Forms.Keys@)">
            <summary>
            Converts string to winforms <see cref="T:System.Windows.Forms.Keys"/>.
            For example, if s is <c>"Ctrl+Left"</c>, sets hotkey=Keys.Control|Keys.Left.
            Returns false if the string is invalid or contains "Win".
            </summary>
        </member>
        <member name="M:Au.keys.more.parseHotkeyString(System.String,System.Windows.Input.ModifierKeys@,System.Windows.Input.Key@,System.Windows.Input.MouseAction@)">
            <summary>
            Converts string to WPF <see cref="T:System.Windows.Input.ModifierKeys"/> and <see cref="T:System.Windows.Input.Key"/> or <see cref="T:System.Windows.Input.MouseAction"/>.
            For example, if s is <c>"Ctrl+Left"</c>, sets mod=ModifierKeys.Control and key=Key.Left.
            Returns false if the string is invalid or contains incorrectly specified mouse buttons.
            Supported mouse button strings: "Click", "D-click", "R-click", "M-click", "Wheel". Example: "Ctrl+R-click". The first character of a mouse word is case-insensitive.
            </summary>
        </member>
        <member name="M:Au.keys.more.ParseHotkeyTriggerString_(System.String,Au.Types.KMod@,Au.Types.KMod@,Au.Types.KKey@,System.Boolean)">
            <summary>
            Used for parsing of hotkey triggers and mouse trigger modifiers.
            Like <see cref="M:Au.keys.more.parseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)"/>, but supports 'any mod' (like "Shift?+K" or "?+K") and <i>noKey</i>.
            <i>noKey</i> - s can contain only modifiers, not key. If false, s must be "key" or "mod+key", else returns false. Else s must be "mod" or null/"", else returns false.
            </summary>
        </member>
        <member name="M:Au.keys.more.KModToWinforms(Au.Types.KMod)">
            <summary>
            Converts modifier key flags from <b>KMod</b> to winforms <b>Keys</b>.
            </summary>
            <remarks>
            For Win returns flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.keys.more.KModFromWinforms(System.Windows.Forms.Keys)">
            <summary>
            Converts modifier key flags from winforms <b>Keys</b> to <b>KMod</b>.
            </summary>
            <remarks>
            For Win can be used flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.keys.more.KModToWpf(Au.Types.KMod)">
            <summary>
            Converts modifier key flags from <b>KMod</b> to WPF <b>ModifierKeys</b>.
            </summary>
        </member>
        <member name="M:Au.keys.more.KModFromWpf(System.Windows.Input.ModifierKeys)">
            <summary>
            Converts modifier key flags from WPF <b>ModifierKeys</b> to <b>KMod</b>.
            </summary>
        </member>
        <member name="M:Au.keys.more.KKeyToWpf(Au.Types.KKey)">
            <summary>
            Converts key from <b>KKey</b> to WPF <b>Key</b>.
            </summary>
        </member>
        <member name="M:Au.keys.more.KKeyFromWpf(System.Windows.Input.Key)">
            <summary>
            Converts key from WPF <b>Key</b> to <b>KKey</b>.
            </summary>
        </member>
        <member name="T:Au.keys.more.Hotkey">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>. Unregisters when disposing.
            </summary>
            <remarks>
            Can be used as a lightweight alternative to hotkey triggers.
            
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Unregister</b>) or with the 'using' pattern.
            </remarks>
            <example>
            <code><![CDATA[
            using Au;
            using System;
            using System.Windows.Forms;
            using Au.Types;
            
            var f = new FormRegisterHotkey();
            f.ShowDialog();
            
            class FormRegisterHotkey :Form
            {
            	keys.more.Hotkey _hk1, _hk2;
            
            	protected override void WndProc(ref Message m)
            	{
            		switch(m.Msg) {
            		case 1: //WM_CREATE
            			bool r1 = _hk1.Register(1, "Ctrl+Alt+F10", this);
            			bool r2 = _hk2.Register(2, (KMod.Ctrl | KMod.Shift, KKey.D), this); //Ctrl+Shift+D
            			print.it(r1, r2);
            			break;
            		case 2: //WM_DESTROY
            			_hk1.Unregister();
            			_hk2.Unregister();
            			break;
            		case keys.more.Hotkey.WM_HOTKEY:
            			print.it(m.WParam);
            			break;
            		}
            		base.WndProc(ref m);
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.more.Hotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="id">Hotkey id. Must be 0 to 0xBFFF or value returned by API <msdn>GlobalAddAtom</msdn>. It will be <i>wParam</i> of the <msdn>WM_HOTKEY</msdn> message.</param>
            <param name="hotkey">Hotkey. Can be: string like "Ctrl+Shift+Alt+Win+K", tuple (KMod, KKey), enum KKey, enum Keys, struct KHotkey.</param>
            <param name="window">Window/form that will receive the <msdn>WM_HOTKEY</msdn> message. Must be of this thread. If default, the message must be retrieved in the message loop of this thread.</param>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:System.InvalidOperationException">This variable already registered a hotkey.</exception>
            <remarks>
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            <note>Most single-key and Shift+key hotkeys don't work when the active window has higher UAC integrity level (eg admin) than this process. Media keys may work.</note>
            A single variable cannot register multiple hotkeys simultaneously. Use multiple variables, for example array.
            </remarks>
            <seealso cref="M:Au.keys.waitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>
            <example>See <see cref="T:Au.keys.more.Hotkey"/>.</example>
        </member>
        <member name="M:Au.keys.more.Hotkey.Unregister">
            <summary>
            Unregisters the hotkey.
            </summary>
            <remarks>
            Called implicitly when disposing this variable.
            Must be called from the same thread as when registering, and the window must be still alive.
            If fails, calls <see cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.keys.more.Hotkey.Dispose">
            <summary>
            Calls <see cref="M:Au.keys.more.Hotkey.Unregister"/>.
            </summary>
        </member>
        <member name="F:Au.keys.more.Hotkey.WM_HOTKEY">
            <summary>
            This message is posted to the window or to the thread's message loop.
            More info: <msdn>WM_HOTKEY</msdn>.
            </summary>
        </member>
        <member name="T:Au.keys.gui">
            <summary>
            Gets key states for using in UI code (winforms, WPF, etc).
            </summary>
            <remarks>
            Use functions of this class in user interface code (winforms, WPF, etc). In other code (automation scrits, etc) usually it's better to use functions of <see cref="T:Au.keys"/> class.
            
            In Windows there are two API to get key state - <msdn>GetKeyState</msdn> and <msdn>GetAsyncKeyState</msdn>.
            
            API <b>GetAsyncKeyState</b> is used by class <see cref="T:Au.keys"/> and not by this class (<b>keys.gui</b>). When physical key state changes (pressed/released), <b>GetAsyncKeyState</b> sees the change immediately. It is good in automation scripts, but not good in UI code because the state is not synchronized with the message queue.
            
            This class (<b>keys.gui</b>) uses API <msdn>GetKeyState</msdn>. In the foreground thread (of the active window), it sees key state changes not immediately but after the thread reads key messages from its queue. It is good in UI threads. In background threads this API usually works like <b>GetAsyncKeyState</b>, but it depends on API <msdn>AttachThreadInput</msdn> and in some cases is less reliable, for example may be unaware of keys pressed before the thread started.
            
            The key state returned by these API is not always the same as of the physical keyboard. There is no API to get real physical state. Some cases when it is different:
            1. The key is pressed or released by software, such as the <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> function of this library.
            2. The key is blocked by a low-level hook. For example, hotkey triggers of this library use hooks.
            3. The foreground window belongs to a process with higher UAC integrity level.
            
            Also there is API <msdn>GetKeyboardState</msdn>. It gets states of all keys in single call. Works like <b>GetKeyState</b>.
            </remarks>
        </member>
        <member name="M:Au.keys.gui.getKeyState(Au.Types.KKey)">
            <summary>
            Calls API <msdn>GetKeyState</msdn> and returns its return value.
            </summary>
            <remarks>
            If returns &lt; 0, the key is pressed. If the low-order bit is 1, the key is toggled; it works only with CapsLock, NumLock, ScrollLock and several other keys, as well as mouse buttons.
            Can be used for mouse buttons too, for example <c>keys.gui.getKeyState(KKey.MouseLeft)</c>. When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
        </member>
        <member name="M:Au.keys.gui.isPressed(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is pressed.
            </summary>
            <remarks>
            Can be used for mouse buttons too. Example: <c>keys.gui.isPressed(KKey.MouseLeft)</c>. When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
        </member>
        <member name="M:Au.keys.gui.isToggled(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is toggled.
            </summary>
            <remarks>
            Works only with CapsLock, NumLock, ScrollLock and several other keys, as well as mouse buttons.
            </remarks>
        </member>
        <member name="P:Au.keys.gui.isAlt">
            <summary>
            Returns true if the Alt key is pressed.
            </summary>
        </member>
        <member name="P:Au.keys.gui.isCtrl">
            <summary>
            Returns true if the Ctrl key is pressed.
            </summary>
        </member>
        <member name="P:Au.keys.gui.isShift">
            <summary>
            Returns true if the Shift key is pressed.
            </summary>
        </member>
        <member name="P:Au.keys.gui.isWin">
            <summary>
            Returns true if the Win key is pressed.
            </summary>
        </member>
        <member name="M:Au.keys.gui.isMod(Au.Types.KMod)">
            <summary>
            Returns true if some modifier keys are pressed.
            </summary>
            <param name="mod">Return true if some of these keys are pressed. Default: Ctrl, Shift or Alt.</param>
            <remarks>
            By default does not check the Win key, as it is not used in UI, but you can include it in <i>mod</i> if need.
            </remarks>
        </member>
        <member name="M:Au.keys.gui.getMod(Au.Types.KMod)">
            <summary>
            Gets flags indicating which modifier keys are pressed.
            </summary>
            <param name="mod">Check only these keys. Default: Ctrl, Shift, Alt.</param>
            <remarks>
            By default does not check the Win key, as it is not used in UI, but you can include it in <i>mod</i> if need.
            </remarks>
        </member>
        <member name="P:Au.keys.gui.isCapsLock">
            <summary>
            Returns true if the Caps Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.keys.isCapsLock"/>.
            </remarks>
        </member>
        <member name="P:Au.keys.gui.isNumLock">
            <summary>
            Returns true if the Num Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.keys.isNumLock"/>.
            </remarks>
        </member>
        <member name="P:Au.keys.gui.isScrollLock">
            <summary>
            Returns true if the Scroll Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.keys.isScrollLock"/>.
            </remarks>
        </member>
        <member name="M:Au.keys.isPressed(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is pressed.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
            <remarks>
            Uses API <msdn>GetAsyncKeyState</msdn>.
            </remarks>
        </member>
        <member name="P:Au.keys.isAlt">
            <summary>
            Returns true if the Alt key is pressed. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
        </member>
        <member name="P:Au.keys.isCtrl">
            <summary>
            Returns true if the Ctrl key is pressed. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
        </member>
        <member name="P:Au.keys.isShift">
            <summary>
            Returns true if the Shift key is pressed. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
        </member>
        <member name="P:Au.keys.isWin">
            <summary>
            Returns true if the Win key is pressed. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
        </member>
        <member name="M:Au.keys.isMod(Au.Types.KMod)">
            <summary>
            Returns true if some modifier keys are pressed: Ctrl, Shift, Alt, Win. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
            <param name="mod">Return true if some of these keys are pressed. Default - any (Ctrl, Shift, Alt or Win).</param>
            <seealso cref="M:Au.keys.waitForNoModifierKeys(System.Double,Au.Types.KMod)"/>
        </member>
        <member name="M:Au.keys.getMod(Au.Types.KMod)">
            <summary>
            Gets flags indicating which modifier keys are pressed: Ctrl, Shift, Alt, Win. Calls <see cref="M:Au.keys.isPressed(Au.Types.KKey)"/>.
            In UI code use <see cref="T:Au.keys.gui"/> instead.
            </summary>
            <param name="mod">Check only these keys. Default - all four.</param>
        </member>
        <member name="P:Au.keys.isCapsLock">
            <summary>
            Returns true if the Caps Lock key is toggled.
            </summary>
        </member>
        <member name="P:Au.keys.isNumLock">
            <summary>
            Returns true if the Num Lock key is toggled.
            </summary>
        </member>
        <member name="P:Au.keys.isScrollLock">
            <summary>
            Returns true if the Scroll Lock key is toggled.
            </summary>
        </member>
        <member name="M:Au.keys.waitForNoModifierKeys(System.Double,Au.Types.KMod)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) are pressed. See <see cref="M:Au.keys.isMod(Au.Types.KMod)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="mod">Check only these keys. Default: all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.keys.waitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) or mouse buttons are pressed.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="mod">Check only these keys. Default: all.</param>
            <param name="buttons">Check only these buttons. Default: all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <seealso cref="M:Au.keys.isMod(Au.Types.KMod)"/>
            <seealso cref="M:Au.mouse.isPressed(Au.Types.MButtons)"/>
            <seealso cref="M:Au.mouse.waitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.keys.waitForReleased(System.Double,Au.Types.KKey[])">
            <summary>
            Waits while the specified keys or/and mouse buttons are pressed.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="keys_">One or more keys or/and mouse buttons. Waits until all are released.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.keys.waitForReleased(System.Double,System.String)">
            <summary>
            Waits while the specified keys are pressed.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="keys_">One or more keys. Waits until all are released. String like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>, without operators.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.ArgumentException">Error in <i>keys_</i> string.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.keys.waitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)">
            <summary>
            Registers a temporary hotkey and waits for it.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="hotkey">See <see cref="M:Au.keys.more.Hotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)"/>.</param>
            <param name="waitModReleased">Also wait until hotkey modifier keys released.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:Au.Types.AuException">Failed to register hotkey.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Uses <see cref="T:Au.keys.more.Hotkey"/>; it uses API <msdn>RegisterHotKey</msdn>.
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            <note>Most single-key and Shift+key hotkeys don't work when the active window has higher UAC integrity level (eg admin) than this process. Media keys may work.</note>
            </remarks>
            <example>
            <code><![CDATA[
            keys.waitForHotkey(0, "F11");
            keys.waitForHotkey(0, KKey.F11);
            keys.waitForHotkey(0, "Shift+A", true);
            keys.waitForHotkey(0, (KMod.Ctrl | KMod.Shift, KKey.P)); //Ctrl+Shift+P
            keys.waitForHotkey(0, Keys.Control | Keys.Alt | Keys.H); //Ctrl+Alt+H
            keys.waitForHotkey(5, "Ctrl+Win+K"); //exception after 5 s
            if(!keys.waitForHotkey(-5, "Left")) print.it("timeout"); //returns false after 5 s
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.waitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of the specified key.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="key">Wait for this key.</param>
            <param name="up">Wait for key-up event.</param>
            <param name="block">Make the event invisible for other apps. If <i>up</i> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <exception cref="T:System.ArgumentException"><i>key</i> is 0.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Waits for key event, not for key state.
            Uses low-level keyboard hook. Can wait for any single key. See also <see cref="M:Au.keys.waitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>.
            Ignores key events injected by functions of this library.
            </remarks>
            <example>
            <code><![CDATA[
            keys.waitForKey(0, KKey.Ctrl, up: false, block: true);
            print.it("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.waitForKey(System.Double,System.String,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of the specified key.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout"></param>
            <param name="key">Wait for this key. A single-key string like with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.</param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.ArgumentException">Invalid <i>key</i> string.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            keys.waitForKey(0, "Ctrl", up: false, block: true);
            print.it("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.waitForKey(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of any key, and gets the key code.
            </summary>
            <returns>
            Returns the key code. On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.
            For modifier keys returns the left or right key code, for example LCtrl/RCtrl, not Ctrl.
            </returns>
            <param name="secondsTimeout"></param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            var key = keys.waitForKey(0, up: true, block: true);
            print.it(key);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.waitForKeys(System.Double,System.Func{Au.Types.HookData.Keyboard,System.Boolean},System.Boolean)">
            <summary>
            Waits for keyboard events using callback function.
            </summary>
            <returns>
            Returns the key code. On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.
            For modifier keys returns the left or right key code, for example LCtrl/RCtrl, not Ctrl.
            </returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="f">Callback function that receives key down and up events. Let it return true to stop waiting.</param>
            <param name="block">Make the key down event invisible for other apps (when the callback function returns true).</param>
            <remarks>
            Waits for key event, not for key state.
            Uses low-level keyboard hook.
            Ignores key events injected by functions of this library.
            </remarks>
            <example>
            Wait for F3 or Esc.
            <code><![CDATA[
            var k = keys.waitForKeys(0, k => !k.IsUp && k.Key is KKey.F3 or KKey.Escape, block: true);
            print.it(k);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.send(Au.Types.KKeysEtc[])">
            <summary>
            Generates virtual keystrokes (keys, text).
            </summary>
            <param name="keysEtc">
            Arguments of these types:
            <list type="bullet">
            <item><description>string - keys. Key names separated by spaces or operators, like <c>"Enter A Ctrl+A"</c>.
            Tool: in <c>""</c> string press Ctrl+Space.
            </description></item>
            <item><description>string with prefix "!" - literal text.
            Example: <c>var p = "pass"; keys.send("!user", "Tab", "!" + p, "Enter");</c>
            </description></item>
            <item><description>string with prefix "%" - HTML to paste. Full or fragment.
            </description></item>
            <item><description><see cref="T:Au.clipboardData"/> - clipboard data to paste.
            </description></item>
            <item><description><see cref="T:Au.Types.KKey"/> - a single key.
            Example: <c>keys.send("Shift+", KKey.Left, "*3");</c> is the same as <c>keys.send("Shift+Left*3");</c>.
            </description></item>
            <item><description>int - sleep milliseconds. Max 10000.
            Example: <c>keys.send("Left", 500, "Right");</c>
            </description></item>
            <item><description><see cref="T:System.Action"/> - callback function.
            Example: <c>Action click = () => mouse.click(); keys.send("Shift+", click);</c>
            </description></item>
            <item><description><see cref="T:Au.Types.KKeyScan"/> - a single key, specified using scan code and/or virtual-key code and extended-key flag.
            Example: <c>keys.send(new KKeyScan(0x3B, false)); //key F1</c>
            Example: <c>keys.send(new KKeyScan(KKey.Enter, true)); //numpad Enter</c>
            </description></item>
            </list>
            </param>
            <exception cref="T:System.ArgumentException">An invalid value, for example an unknown key name.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc). When sending text, fails if there is no focused window.</exception>
            <remarks>
            Usually keys are specified in string, like in this example:
            <code><![CDATA[keys.send("A F2 Ctrl+Shift+A Enter*2"); //keys A, F2, Ctrl+Shift+A, Enter Enter
            ]]></code>
            
            Key names:
            <table>
            <tr>
            <th>Group</th>
            <th style="width:40%">Keys</th>
            <th>Info</th>
            </tr>
            <tr>
            <td>Named keys</td>
            <td>
            <b>Modifier:</b> <c>Alt</c>, <c>Ctrl</c>, <c>Shift</c>, <c>Win</c>, <c>RAlt</c>, <c>RCtrl</c>, <c>RShift</c>, <c>RWin</c>
            <br/><b>Navigate:</b> <c>Esc</c>, <c>End</c>, <c>Home</c>, <c>PgDn</c>, <c>PgUp</c>, <c>Down</c>, <c>Left</c>, <c>Right</c>, <c>Up</c>
            <br/><b>Other:</b> <c>Back</c>, <c>Del</c>, <c>Enter</c>, <c>Menu</c>, <c>Pause</c>, <c>PrtSc</c>, <c>Space</c>, <c>Tab</c>
            <br/><b>Function:</b> <c>F1</c>-<c>F24</c>
            <br/><b>Lock:</b> <c>CapsLock</c>, <c>NumLock</c>, <c>ScrollLock</c>, <c>Ins</c>
            </td>
            <td>Start with an uppercase character. Only the first 3 characters are significant; others can be any ASCII letters. For example, can be <c>"Back"</c>, <c>"Bac"</c>, <c>"Backspace"</c> or <c>"BACK"</c>, but not <c>"back"</c> or <c>"Ba"</c> or <c>"Back5"</c>.
            <br/>
            <br/>Alias: <c>AltGr</c> (RAlt), <c>App</c> (Menu), <c>PageDown</c> or <c>PD</c> (PgDn), <c>PageUp</c> or <c>PU</c> (PgUp), <c>PrintScreen</c> or <c>PS</c> (PrtSc), <c>BS</c> (Back), <c>PB</c> (Pause/Break), <c>CL</c> (CapsLock), <c>NL</c> (NumLock), <c>SL</c> (ScrollLock), <c>HM</c> (Home).
            </td>
            </tr>
            <tr>
            <td>Text keys</td>
            <td>
            <b>Alphabetic:</b> <c>A</c>-<c>Z</c> (or <c>a</c>-<c>z</c>)
            <br/><b>Number:</b> <c>0</c>-<c>9</c>
            <br/><b>Numeric keypad:</b> <c>#/</c> <c>#*</c> <c>#-</c> <c>#+</c> <c>#.</c> <c>#0</c>-<c>#9</c>
            <br/><b>Other:</b> <c>`</c> <c>-</c> <c>=</c> <c>[</c> <c>]</c> <c>\</c> <c>;</c> <c>'</c> <c>,</c> <c>.</c> <c>/</c>
            </td>
            <td>Spaces between keys are optional, except for uppercase A-Z. For example, can be <c>"A B"</c>, <c>"a b"</c>, <c>"A b"</c> or <c>"ab"</c>, but not <c>"AB"</c> or <c>"Ab"</c>.
            <br/>
            <br/>For <c>`</c> <c>-</c> <c>[</c> <c>]</c> <c>\</c> <c>;</c> <c>'</c> <c>,</c> <c>.</c> <c>/</c> also can be used <c>~</c> <c>_</c> <c>{</c> <c>}</c> <c>|</c> <c>:</c> <c>"</c> <c>&lt;</c> <c>&gt;</c> <c>?</c>.
            </td>
            </tr>
            <tr>
            <td>Other keys</td>
            <td>Names of enum <see cref="T:Au.Types.KKey"/> members.</td>
            <td>Example: <c>keys.send("BrowserBack");</c>
            </td>
            </tr>
            <tr>
            <td>Other keys</td>
            <td>Virtual-key codes.</td>
            <td>Start with VK or Vk.
            Example: <c>keys.send("VK65 VK0x42");</c>
            </td>
            </tr>
            <tr>
            <td>Forbidden</td>
            <td>Fn, Ctrl+Alt+Del, Win+L, some other.</td>
            <td>Programs cannot press these keys.</td>
            </tr>
            <tr>
            <td>Special characters</td>
            <td>
            <b>Operator:</b> + * ( )
            <br/><b>Numpad key prefix:</b> #
            <br/><b>Text/HTML argument prefix:</b> ! %
            <br/><b>Reserved:</b> @ $ ^ &amp;
            </td>
            <td>These characters cannot be used as keys. Instead use = 8 9 0 4 3 1 2 5 6 7.</td>
            </tr>
            </table>
            
            Operators:
            <table>
            <tr>
            <th>Operator</th>
            <th>Examples</th>
            <th>Description</th>
            </tr>
            <tr>
            <td><c>*n</c></td>
            <td><c>"Left*3"</c></td>
            <td>Press key n times, like <c>"Left Left Left"</c>.
            <br/>See <see cref="M:Au.keys.AddRepeat(System.Int32)"/>.
            </td>
            <tr>
            <td><c>*down</c></td>
            <td><c>"Ctrl*down"</c></td>
            <td>Press key and don't release.</td>
            </tr>
            <tr>
            <td><c>*up</c></td>
            <td><c>"Ctrl*up"</c></td>
            <td>Release key.</td>
            </tr>
            </tr>
            <tr>
            <td><c>+</c></td>
            <td><c>"Ctrl+Shift+A"</c><br/><c>"Alt+E+P"</c></td>
            <td>The same as <c>"Ctrl*down Shift*down A Shift*up Ctrl*up"</c> and <c>"Alt*down E*down P E*up Alt*up"</c>.</td>
            </tr>
            <tr>
            <td><c>+()</c></td>
            <td><c>"Alt+(E P)"</c></td>
            <td>The same as <c>"Alt*down E P Alt*up"</c>.
            <br/>Inside () cannot be used + and +().
            </td>
            </tr>
            </table>
            
            Operators and related keys can be in separate arguments. Examples: <c>keys.send("Shift+", KKey.A); keys.send(KKey.A, "*3");</c>.
            
            Uses <see cref="P:Au.opt.key"/>:
            <table>
            <tr>
            <th>Option</th>
            <th>Default</th>
            <th>Changed</th>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.NoBlockInput"/></td>
            <td>false.
            Blocks user-pressed keys. Sends them afterwards.
            <br/>If the last argument is 'sleep', stops blocking before executing it; else stops blocking after executing all arguments.</td>
            <td>true.
            Does not block user-pressed keys.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.NoCapsOff"/></td>
            <td>false.
            If the CapsLock key is toggled, untoggles it temporarily (presses it before and after).</td>
            <td>true.
            Does not touch the CapsLock key.
            <br/>Alphabetic keys of "keys" arguments can depend on CapsLock. Text of "text" arguments doesn't depend on CapsLock, unless <see cref="P:Au.Types.OKey.TextHow"/> is <b>KeysX</b>.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.NoModOff"/></td>
            <td>false.
            Releases modifier keys (Alt, Ctrl, Shift, Win).
            <br/>Does it only at the start; later they cannot interfere, unless <see cref="P:Au.Types.OKey.NoBlockInput"/> is true.</td>
            <td>true.
            Does not touch modifier keys.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.TextSpeed"/></td>
            <td>0 ms.</td>
            <td>0 - 1000.
            Changes the speed for "text" arguments (makes slower).</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.KeySpeed"/></td>
            <td>1 ms.</td>
            <td>0 - 1000.
            Changes the speed for "keys" arguments (makes slower if &gt;1).</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.KeySpeedClipboard"/></td>
            <td>5 ms.</td>
            <td>0 - 1000.
            Changes the speed of Ctrl+V keys when pasting text or HTML using clipboard.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.SleepFinally"/></td>
            <td>10 ms.</td>
            <td>0 - 10000.
            <br/>Tip: to sleep finally, also can be used code like this: <c>keys.send("keys", 1000);</c>.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.TextHow"/></td>
            <td><see cref="F:Au.Types.OKeyText.Characters"/></td>
            <td><b>KeysOrChar</b>, <b>KeysOrPaste</b> or <b>Paste</b>.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.PasteLength"/></td>
            <td>200.
            <br/>This option is used for "text" arguments. If text length &gt;= this value, uses clipboard.</td>
            <td>&gt;=0.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.PasteWorkaround"/></td>
            <td>false.
            <br/>This option is used for "text" arguments when using clipboard.
            </td>
            <td>true.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.RestoreClipboard"/></td>
            <td>true.
            Restore clipboard data (by default only text).
            <br/>This option is used for "text" and "HTML" arguments when using clipboard.</td>
            <td>false.
            Don't restore clipboard data.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OKey.Hook"/></td>
            <td>null.</td>
            <td>Callback function that can modify options depending on active window etc.</td>
            </tr>
            </table>
            
            This function does not wait until the target app receives and processes sent keystrokes and text; there is no reliable way to know it. It just adds small delays depending on options (<see cref="P:Au.Types.OKey.SleepFinally"/> etc). If need, change options or add 'sleep' arguments or wait after calling this function. Sending text through the clipboard normally does not have these problems.
            
            Don't use this function to automate windows of own thread. Call it from another thread. See the last example.
            
            Administrator and uiAccess processes don't receive keystrokes sent by standard user processes. See [](xref:uac).
            
            Mouse button codes/names (eg <see cref="F:Au.Types.KKey.MouseLeft"/>) cannot be used to click. Instead use callback, like in the "Ctrl+click" example.
            
            You can use an <see cref="T:Au.keys"/> variable instead of this function. Example: <c>new keys(null).Add("keys", "!text").Send();</c>. More examples in <see cref="M:Au.keys.#ctor(Au.Types.OKey)"/> topic.
            
            This function calls <see cref="M:Au.keys.Add(Au.Types.KKeysEtc[])"/>, which calls these functions depending on argument type: <see cref="M:Au.keys.AddKeys(System.String)"/>, <see cref="M:Au.keys.AddText(System.String,System.String)"/>, <see cref="M:Au.keys.AddClipboardData(Au.clipboardData)"/>, <see cref="M:Au.keys.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})"/>, <see cref="M:Au.keys.AddKey(Au.Types.KKey,System.UInt16,System.Boolean,System.Nullable{System.Boolean})"/>, <see cref="M:Au.keys.AddSleep(System.Int32)"/>, <see cref="M:Au.keys.AddAction(System.Action)"/>. Then calls <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            
            Uses API <msdn>SendInput</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            //Press key Enter.
            keys.send("Enter");
            
            //Press keys Ctrl+A.
            keys.send("Ctrl+A");
            
            //Ctrl+Alt+Shift+Win+A.
            keys.send("Ctrl+Alt+Shift+Win+A");
            
            //Alt down, E, P, Alt up.
            keys.send("Alt+(E P)");
            
            //Alt down, E, P, Alt up.
            keys.send("Alt*down E P Alt*up");
            
            //Press key End, key Backspace 3 times, send text "Text".
            keys.send("End Back*3", "!Text");
            
            //Press Tab n times, send text "user", press Tab, send text "password", press Enter.
            int n = 5; string pw = "password";
            keys.send($"Tab*{n}", "!user", "Tab", "!" + pw, "Enter");
            
            //Send text "Example".
            keys.sendt("Example");
            
            //Press Ctrl+V, wait 500 ms, press Enter.
            keys.send("Ctrl+V", 500, "Enter");
            
            //F2, Ctrl+K, Left 3 times, Space, A, comma, 5, numpad 5, Shift+A, B, C, BrowserBack.
            keys.send("F2 Ctrl+K Left*3 Space a , 5 #5 $abc", KKey.BrowserBack);
            
            //Shift down, A 3 times, Shift up.
            keys.send("Shift+A*3");
            
            //Shift down, A 3 times, Shift up.
            keys.send("Shift+", KKey.A, "*3");
            
            //Shift down, A, wait 500 ms, B, Shift up.
            keys.send("Shift+(", KKey.A, 500, KKey.B, ")");
            
            //Send keys and text slowly.
            opt.key.KeySpeed = opt.key.TextSpeed = 50;
            keys.send("keys Shift+: Space 123456789 Space 123456789 ,Space", "!text: 123456789 123456789\n");
            
            //Ctrl+click
            Action click = () => mouse.click();
            keys.send("Ctrl+", click);
            
            //Ctrl+drag
            Action drag = () => { using(mouse.leftDown()) mouse.moveRelative(0, 50); };
            keys.send("Ctrl+", drag);
            
            //Ctrl+drag, poor man's version
            keys.send("Ctrl*down");
            using(mouse.leftDown()) mouse.moveRelative(0, 50);
            keys.send("Ctrl*up");
            ]]></code>
            Show form and send keys/text to it when button clicked.
            <code><![CDATA[
            var f = new Form();
            var b = new Button { Text = "Key" };
            var t = new TextBox { Top = 100 };
            var c = new Button { Text = "Close", Left = 100 };
            f.Controls.Add(b);
            f.Controls.Add(t);
            f.Controls.Add(c); f.CancelButton = c;
            
            b.Click += async (_, _) =>
            {
            	//keys.send("Tab", "!text", 2000, "Esc"); //no
            	await Task.Run(() => { keys.send("Tab", "!text", 2000, "Esc"); }); //use other thread
            };
            
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys.sendt(System.String,System.String)">
            <summary>
            Sends text to the active window, using virtual keystrokes or clipboard.
            </summary>
            <param name="text">Text. Can be null.</param>
            <param name="html">
            HTML. Can be full HTML or fragment. See <see cref="M:Au.clipboardData.AddHtml(System.String)"/>.
            Can be specified only <i>text</i> or only <i>html</i> or both. If both, will paste <i>html</i> in apps that support it, elsewhere <i>text</i>. If only <i>html</i>, in apps that don't support HTML will paste <i>html</i> as text.
            </param>
            <exception cref="T:Au.Types.AuException">Failed. For example other desktop is active (PC locked, screen saver, UAC consent, Ctrl+Alt+Delete, etc). Also fails if there is no focused window.</exception>
            <remarks>
            Calls <see cref="M:Au.keys.AddText(System.String,System.String)"/> and <see cref="M:Au.keys.SendIt(System.Boolean)"/>.
            To send text can use keys, characters or clipboard, depending on <see cref="P:Au.opt.key"/> and text. If <i>html</i> not null, uses clipboard.
            </remarks>
            <seealso cref="M:Au.clipboard.paste(System.String,System.String,Au.Types.OKey)"/>
            <example>
            <code><![CDATA[
            keys.sendt("Text.\r\n");
            ]]></code>
            Or use function <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> and prefix "!". For HTML use prefix "%".
            <code><![CDATA[
            keys.send("!Send this text and press key", "Enter");
            keys.send("%<b>bold</b> <i>italic</i>", "Enter");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.keys._KeynameToKey(System.String,System.Int32,System.Int32)">
            <summary>
            Converts part of string to <see cref="T:Au.Types.KKey"/>.
            The substring should contain single key name, eg "Esc", "A", "=".
            Returns 0 if invalid key name.
            </summary>
        </member>
        <member name="T:Au.keys.Internal_">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.Sleep(System.Int32)">
            <summary>
            Calls <see cref="M:Au.wait.doEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.LimitSleepTime(System.Int32)">
            <summary>
            If t &gt; 10, returns (t / 4 + 8).
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.KeyToMod(Au.Types.KKey)">
            <summary>
            If k is Shift, Ctrl, Alt or Win or their left/right versions, returns it as modifier flag, eg KMod.Shift.
            Else returns 0.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.VkToSc(Au.Types.KKey,System.IntPtr)">
            <summary>
            Gets scan code from virtual-key code.
            </summary>
            <param name="vk"></param>
            <param name="hkl">Keyboard layout. If 0, uses of current thread.</param>
        </member>
        <member name="M:Au.keys.Internal_.SendKeyEventRaw(Au.Types.KKey,System.UInt16,System.UInt32)">
            <summary>
            Sends one key event.
            Just calls API SendInput with raw parameters.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.SendKey(Au.Types.KKey,System.Int32)">
            <summary>
            Sends key.
            Not used for keys whose scancode can depend on keyboard layout. To get scancode, uses keyboard layout of current thread.
            </summary>
            <param name="k"></param>
            <param name="downUp">1 down, 2 up, 0 down-up.</param>
        </member>
        <member name="M:Au.keys.Internal_.ModPressRelease(System.Boolean,Au.Types.KMod)">
            <summary>
            Presses or releases one or more modifier keys.
            Sends in this order: Ctrl, Alt, Shift, Win.
            </summary>
            <param name="press"></param>
            <param name="mod">Modifier keys. Does nothing if 0.</param>
        </member>
        <member name="M:Au.keys.Internal_.ReleaseModAndCapsLock(Au.Types.OKey)">
            <summary>
            Releases modifier keys if pressed and no option NoModOff. Turns off CapsLock if toggled and no option NoCapsOff.
            When releasing modifiers, if pressed Alt or Win without Ctrl, presses-releases Ctrl to avoid menu mode.
            Returns true if turned off CapsLock.
            Does not sleep, blockinput, etc.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.ReleaseModAndDisableModMenu">
            <summary>
            Releases modifier keys if pressed.
            If pressed Alt or Win without Ctrl, presses-releases Ctrl to avoid menu mode.
            Does not use options, sleep, blockinput, etc.
            </summary>
        </member>
        <member name="T:Au.keys.Internal_.SendCopyPaste">
            <summary>
            Sends Ctrl+V or Ctrl+C or Ctrl+X, and/or optionally one or more keys.
            Caller gets optk and wFocus with GetOptionsAndWndFocused_ (it may want to know some options too).
            Caller calls Press, waits until the target app gets clipboard data, then calls Release.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.SendCopyPaste.Press(Au.Types.KKey,Au.Types.OKey,Au.wnd,System.Collections.Generic.List{Au.Types.KKey})">
            <summary>
            Presses Ctrl+key. Does not release.
            If andKeys used, Release will press/relase them.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.SendCopyPaste.Release">
            <summary>
            Releases keys.
            Does nothing if already released.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.SendCopyPaste.AndSendKeys(System.Collections.Generic.List{Au.Types.KKey},Au.Types.OKey)">
            <summary>
            Sends one or more keys.
            Not used for keys whose scancode can depend on keyboard layout. To get scancode, uses keyboard layout of current thread.
            </summary>
        </member>
        <member name="M:Au.keys.Internal_.GetWndFocusedOrActive(System.Boolean)">
            <summary>
            Gets focused or active window. Waits for it max 20-40 ms (820 ms if <i>requireFocus</i>). On timeout returns default (throws if <i>requireFocus</i>).
            </summary>
            <param name="requireFocus">Wait for focused (and not just active) window longer, and throw exception on timeout. Used for clipboard copy/paste and send text.</param>
            <exception cref="T:Au.Types.AuException">No focused window when <i>requireFocus</i>.</exception>
        </member>
        <member name="M:Au.keys.GetOptionsAndWndFocused_(Au.wnd@,System.Boolean,System.Boolean)">
            <summary>
            Returns <b>OKey</b> of this variable or <b>OKey</b> cloned from this variable and possibly modified by <b>Hook</b>.
            </summary>
            <param name="wFocus">receives the focused or active window. Also the function uses it to avoid frequent calling of Hook.</param>
            <param name="getWndAlways">if false, the caller does not need wFocus. Then wFocus will be default(wnd) if Hook is null.</param>
            <param name="requireFocus">Wait for focused (and not just active) window longer, and throw exception on timeout. Used for clipboard copy/paste and send text.</param>
            <exception cref="T:Au.Types.AuException">No focused window when <i>requireFocus</i>.</exception>
        </member>
        <member name="M:Au.keys.GetOptions_(Au.wnd)">
            <summary>
            Returns <b>OKey</b> of this variable or <b>OptKey</b> cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">the focused or active window. The function uses it to avoid frequent calling of Hook. If you don't have it, use GetOptionsAndWndFocused_ instead.</param>
        </member>
        <member name="M:Au.keys.KeyTypes_.IsMod(Au.Types.KKey)">
            <summary>
            Ctrl, LCtrl, etc.
            </summary>
        </member>
        <member name="M:Au.keys.KeyTypes_.IsGetKeyStateReliable(Au.Types.KKey)">
            <summary>
            API GetKeyState always works.
            For other keys returns 0 if pressed or toggled before starting current thread.
            Modifiers (left/right too), xLock, mouse, some other.
            </summary>
        </member>
        <member name="M:Au.keys.KeyTypes_.IsToggleable(Au.Types.KKey)">
            <summary>
            The same as <see cref="M:Au.keys.KeyTypes_.IsGetKeyStateReliable(Au.Types.KKey)"/>.
            </summary>
        </member>
        <member name="T:Au.miscInfo">
            <summary>
            Contains static functions to get miscellaneous info not found in other classes of this library and .NET.
            </summary>
            <seealso cref="T:Au.osVersion"/>
            <seealso cref="T:Au.folders"/>
            <seealso cref="T:Au.process"/>
            <seealso cref="T:Au.screen"/>
            <seealso cref="T:Au.script"/>
            <seealso cref="T:Au.perf"/>
            <seealso cref="T:Au.uacInfo"/>
            <seealso cref="T:Au.More.Dpi"/>
            <seealso cref="T:System.Environment"/>
            <seealso cref="T:System.Windows.Forms.SystemInformation"/>
            <seealso cref="T:System.Windows.SystemParameters"/>
        </member>
        <member name="M:Au.miscInfo.getGUIThreadInfo(Au.Types.GUITHREADINFO@,System.Int32)">
            <summary>
            Calls API <msdn>GetGUIThreadInfo</msdn>. It gets info about mouse capturing, menu mode, move/size mode, focus, caret, etc.
            </summary>
            <param name="g">API <msdn>GUITHREADINFO</msdn>.</param>
            <param name="idThread">Thread id. If 0 - the foreground (active window) thread. See <see cref="P:Au.process.thisThreadId"/>, <see cref="P:Au.wnd.ThreadId"/>.</param>
        </member>
        <member name="M:Au.miscInfo.getTextCursorRect(Au.Types.RECT@,Au.wnd@,System.Boolean)">
            <summary>
            Gets text cursor (caret) position and size.
            Returns false if fails.
            </summary>
            <param name="r">Receives the rectangle, in screen coordinates.</param>
            <param name="w">Receives the control that contains the text cursor.</param>
            <param name="orMouse">If fails, get mouse pointer coodinates.</param>
            <remarks>
            Can get only standard text cursor. Many apps use non-standard cursor; then fails.
            Also fails if the text cursor currently is not displayed.
            </remarks>
        </member>
        <member name="M:Au.miscInfo.isInputDesktop(System.Boolean)">
            <summary>
            Returns true if current thread is on the input desktop and therefore can use mouse, keyboard, clipboard and window functions.
            </summary>
            <param name="detectLocked">Return false if the active window is a full-screen window of LockApp.exe on Windows 10. It is when computer has been locked but still not displaying the password field. Slower.</param>
            <remarks>
            Usually this app is running on default desktop. Examples of other desktops: the Ctrl+Alt+Delete screen, the PC locked screen, screen saver, UAC consent, custom desktops. If one of these is active, this app cannot use many mouse, keyboard, clipboard and window functions. They either throw exception or do nothing.
            </remarks>
        </member>
        <member name="T:Au.mouse">
            <summary>
            Mouse functions.
            </summary>
            <remarks>
            Should not be used to click windows of own thread. It may work or not. If need, use another thread. Example in <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.
            </remarks>
        </member>
        <member name="P:Au.mouse.xy">
            <summary>
            Gets cursor (mouse pointer) position.
            </summary>
        </member>
        <member name="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to window w.
            </summary>
            <returns>Cursor position in primary screen coordinates.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:Au.Types.AuWndException">
            - Invalid window.
            - The top-level window is hidden. No exception if just cloaked, for example in another desktop; then on click will activate, which usually uncloaks.
            - Other window-related failures.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <returns>Normalized cursor position.</returns>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            
            May fail to move the cursor to the specified x y. Some reasons:
            - Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc).
            - The active window belongs to a process of higher [](xref:uac) integrity level.
            - Some application called API ClipCursor. No exception if option <b>Relaxed</b> is true (then final cursor position is undefined).
            </remarks>
        </member>
        <member name="M:Au.mouse.move(Au.Types.POINT)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <param name="p">
            Coordinates.
            Tip: To specify coordinates relative to the right, bottom, work area or a non-primary screen, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen,System.Boolean,System.Boolean)"/>, like in the example.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            </remarks>
            <example>
            Save-restore mouse position.
            <code><![CDATA[
            var p = mouse.xy;
            //...;
            mouse.move(p);
            ]]></code>
            Use coodinates in the first non-primary screen.
            <code><![CDATA[
            mouse.move(Coord.Normalize(10, Coord.Reverse(10), screen: 1));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.mouse.save">
            <summary>
            Remembers current mouse cursor position to be later restored with <see cref="M:Au.mouse.restore"/>.
            </summary>
        </member>
        <member name="M:Au.mouse.restore">
            <summary>
            Moves the mouse cursor where it was at the time of the last <see cref="M:Au.mouse.save"/> call in this thread. If it was not called - of the first 'mouse move' or 'mouse click' function call in this thread. Does nothing if these functions were not called.
            </summary>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="P:Au.mouse.lastXY">
            <summary>
            Mouse cursor position of the most recent successful 'mouse move' or 'mouse click' function call in this thread.
            If such functions are still not called in this thread, returns <see cref="P:Au.mouse.xy"/>.
            </summary>
        </member>
        <member name="M:Au.mouse.moveRelative(System.Int32,System.Int32)">
            <summary>
            Moves the cursor (mouse pointer) relative to <see cref="P:Au.mouse.lastXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="dx">X offset from <b>LastXY.x</b>.</param>
            <param name="dy">Y offset from <b>LastXY.y</b>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The calculated x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the calculated x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher [](xref:uac) integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.mouse.moveRecorded(System.String,System.Double)">
            <summary>
            Plays recorded mouse movements, relative to <see cref="P:Au.mouse.lastXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="recordedString">String containing mouse movement data recorded by a recorder tool that uses <see cref="M:Au.More.RecordingUtil.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)"/>.</param>
            <param name="speedFactor">Speed factor. For example, 0.5 makes 2 times faster.</param>
            <exception cref="T:System.FormatException">Invalid Base64 string.</exception>
            <exception cref="T:System.ArgumentException">The string is not compatible with this library version (recorded with a newer version and has additional options).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The last x y is not in screen. No exception option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the last x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher [](xref:uac) integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.Relaxed"/> (only for the last movement; always relaxed in intermediate movements).
            </remarks>
        </member>
        <member name="M:Au.mouse._SendMove(Au.Types.POINT)">
            <summary>
            Sends single mouse movement event.
            x y are normal absolute coordinates.
            </summary>
        </member>
        <member name="M:Au.mouse._SendButton(Au.Types.MButton,System.Boolean,Au.Types.POINT)">
            <summary>
            Sends single mouse button down or up event.
            Does not use the action flags of button.
            Applies SM_SWAPBUTTON.
            Also moves to p in the same API SendInput call.
            </summary>
        </member>
        <member name="M:Au.mouse._SendRaw(Au.Types.Api.IMFlags,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls Api.SendInput to send single mouse movement or/and button down or up or wheel event.
            Converts x, y and wheelTicks as need for MOUSEINPUT.
            For X buttons use Api.IMFlag.XDown|Api.IMFlag.X1 etc.
            If Api.IMFlag.Move, adds Api.IMFlag.Absolute.
            </summary>
        </member>
        <member name="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to window w.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuWndException">x y is not in the window (read more in Remarks).</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/> (between moving and clicking), <see cref="P:Au.Types.OMouse.ClickSpeed"/>, <see cref="P:Au.Types.OMouse.ClickSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            If after moving the cursor it is not in the window (or a window of its thread), activates the window (or its top-level parent window). Throws exception if then x y is still not in the window. Skips all this when just releasing button or if option <b>Relaxed</b> is true. Also, if it is a control, x y can be somewhere else in its top-level parent window.
            </remarks>
        </member>
        <member name="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at the specified position in screen.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.MoveSpeed"/>, <see cref="P:Au.Types.OMouse.MoveSleepFinally"/> (between moving and clicking), <see cref="P:Au.Types.OMouse.ClickSpeed"/>, <see cref="P:Au.Types.OMouse.ClickSleepFinally"/>, <see cref="P:Au.Types.OMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.POINT)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at the specified position in screen.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="p">
            Coordinates.
            Tip: To specify coordinates relative to the right, bottom, work area or a non-primary screen, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen,System.Boolean,System.Boolean)"/>, like in the example.
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
            <example>
            Click at 100 200.
            <code><![CDATA[
            mouse.clickEx(MButton.Left, (100, 200));
            ]]></code>
            
            Right-click at 50 from left and 100 from bottom of the work area.
            <code><![CDATA[
            mouse.clickEx(MButton.Right, Coord.Normalize(50, Coord.Reverse(100), true));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button.
            By default does not move the mouse cursor.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action. Default: left click.</param>
            <param name="useLastXY">
            Use <see cref="P:Au.mouse.lastXY"/>. It is the mouse cursor position set by the most recent 'mouse move' or 'mouse click' function called in this thread. Use this option for reliability.
            Example: <c>mouse.move(100, 100); mouse.clickEx(..., true);</c>. The click is always at 100 100, even if somebody changes cursor position between <c>mouse.move</c> sets it and <c>mouse.clickEx</c> uses it. In such case this option atomically moves the cursor to <b>LastXY</b>. This movement is instant and does not use <see cref="T:Au.opt"/>.
            If false (default), clicks at the current cursor position (does not move it).
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.ClickSpeed"/>, <see cref="P:Au.Types.OMouse.ClickSleepFinally"/>.
            </remarks>
        </member>
        <member name="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button click at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.click(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button click at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.click(System.Boolean)">
            <summary>
            Left button click.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.rightClick(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button click at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button click at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightClick(System.Boolean)">
            <summary>
            Right button click.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.doubleClick(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button double click at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.doubleClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button double click at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.doubleClick(System.Boolean)">
            <summary>
            Left button double click.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.leftDown(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.leftDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button down (press and don't release) at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.leftDown(System.Boolean)">
            <summary>
            Left button down (press and don't release).
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.leftUp(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.leftUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button up (release pressed button) at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.leftUp(System.Boolean)">
            <summary>
            Left button up (release pressed button).
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.rightDown(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button down (press and don't release) at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightDown(System.Boolean)">
            <summary>
            Right button down (press and don't release).
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.rightUp(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button up (release pressed button) at position x y.
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.mouse.move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.mouse.rightUp(System.Boolean)">
            <summary>
            Right button up (release pressed button).
            Calls <see cref="M:Au.mouse.clickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.mouse.lastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.mouse.wheel(System.Int32,System.Boolean)">
            <summary>
            Mouse wheel forward or backward.
            </summary>
            <param name="ticks">Number of wheel ticks forward (positive) or backward (negative).</param>
            <param name="horizontal">Horizontal wheel.</param>
            <remarks>
            Uses <see cref="P:Au.opt.mouse"/>: <see cref="P:Au.Types.OMouse.ClickSleepFinally"/>.
            </remarks>
        </member>
        <member name="M:Au.mouse.isPressed(Au.Types.MButtons)">
            <summary>
            Returns true if some mouse buttons are pressed.
            </summary>
            <param name="buttons">Return true if some of these buttons are down. Default: any (Left, Right, Middle, X1 or X2).</param>
            <remarks>
            Uses API <msdn>GetAsyncKeyState</msdn>.
            When processing user input in UI code (forms, WPF), instead use class <see cref="T:Au.keys.gui"/> or .NET functions. They use API <msdn>GetKeyState</msdn>.
            When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
            <seealso cref="M:Au.mouse.waitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.mouse.waitForNoButtonsPressed(System.Double,Au.Types.MButtons)">
            <summary>
            Waits while some mouse buttons are pressed. See <see cref="M:Au.mouse.isPressed(Au.Types.MButtons)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="buttons">Wait only for these buttons. Default - all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <seealso cref="M:Au.keys.waitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.mouse.WaitForNoButtonsPressed_">
            <summary>
            Waits while some buttons are pressed, except those pressed by an <see cref="T:Au.mouse"/> class function in this thread.
            Does nothing option <b>Relaxed</b> is true.
            </summary>
        </member>
        <member name="M:Au.mouse.waitForClick(System.Double,Au.Types.MButtons,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of the specified mouse button or buttons.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="button">Mouse button. If several buttons specified, waits for any of them.</param>
            <param name="up">Wait for button-up event.</param>
            <param name="block">Make the event invisible for other apps. If <i>up</i> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <exception cref="T:System.ArgumentException"><i>button</i> is 0.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Unlike <see cref="M:Au.mouse.waitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>, waits for down or up event, not for button state.
            Uses low-level mouse hook.
            Ignores mouse events injected by functions of this library.
            </remarks>
            <example>
            <code><![CDATA[
            mouse.waitForClick(0, MButtons.Left, up: true, block: false);
            print.it("click");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.mouse.waitForClick(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of any mouse button, and gets the button code.
            </summary>
            <returns>Returns the button code. On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout"></param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            var button = mouse.waitForClick(0, up: true, block: true);
            print.it(button);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.mouse.waitForCursor(System.Double,Au.Types.MCursor,System.Boolean)">
            <summary>
            Waits for a standard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="cursor">Id of a standard cursor.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.mouse.waitForCursor(System.Double,System.Int64,System.Boolean)">
            <summary>
            Waits for a nonstandard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="cursorHash">Cursor hash, as returned by <see cref="M:Au.More.MouseCursor.Hash(System.IntPtr)"/>.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="T:Au.lastError">
             <summary>
             Gets, sets or clears the last error code of Windows API. Gets error text.
             </summary>
             <remarks>
             Many Windows API functions, when failed, set an error code. Code 0 means no error. It is stored in an internal thread-specific int variable. But only if the API declaration's DllImport attribute has SetLastError = true.
             
             Some functions of this library simply call these API functions and don't throw exception when API fail. For example, most <see cref="T:Au.wnd"/> propery-get functions.
             When failed, they return false/0/null/empty. Then you can use <see cref="P:Au.lastError.code"/> to get the error code or <see cref="P:Au.lastError.message"/> to get error text.
             
             Most of functions set error code only when failed, and don't clear the old error code when succeeded. Therefore may need to call <see cref="M:Au.lastError.clear"/> before.
            
             Windows API error code definitions and documentation are not included in this library. You can look for them in API function documentation on the internet.
             </remarks>
             <example>
             <code><![CDATA[
             wnd w = wnd.find("Notepag");
             lastError.clear();
             bool enabled = w.IsEnabled; //returns true if enabled, false if disabled or failed
             if(!enabled && lastError.code != 0) { print.it(lastError.message); return; } //1400, Invalid window handle
             print.it(enabled);
             ]]></code>
             </example>
        </member>
        <member name="M:Au.lastError.clear">
            <summary>
            Calls API <msdn>SetLastError</msdn>(0), which clears the Windows API last error code of this thread.
            </summary>
            <remarks>
            Need it before calling some functions if you want to use <see cref="P:Au.lastError.code"/> or <see cref="P:Au.lastError.message"/>.
            The same as <c>lastError.code = 0;</c>.
            </remarks>
        </member>
        <member name="P:Au.lastError.code">
            <summary>
            Gets (<see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>) or sets (API <msdn>SetLastError</msdn>) the Windows API last error code of this thread.
            </summary>
        </member>
        <member name="P:Au.lastError.message">
            <summary>
            Gets the text message of the Windows API last error code of this thread.
            Returns null if the code is 0.
            </summary>
            <remarks>
            The string always ends with ".".
            </remarks>
        </member>
        <member name="M:Au.lastError.messageFor(System.Int32)">
            <summary>
            Gets the text message of a Windows API error code.
            Returns null if errorCode is 0.
            </summary>
            <remarks>
            The string always ends with ".".
            </remarks>
        </member>
        <member name="T:Au.opt">
            <summary>
            Options for some functions of this library.
            </summary>
            <remarks>
            Some frequently used static functions of this library have some options (settings). For example <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> allows to change speed, text sending method, etc. Passing options as parameters in each call usually isn't what you want to do in automation scripts. Instead you can set options using static properties. This class contains several groups of options for functions of various classes. See examples.
            
            There are two sets of identical or similar options - in class <b>opt</b> and in class <see cref="T:Au.opt.init"/>:
            - <b>opt</b> - thread-static options (each thread has its own instance). Functions of this library use them. You can change or change-restore them anywhere in script. Initial options are automatically copied from <b>opt.init</b> when that group of options (<b>Key</b>, <b>Mouse</b>, etc) is used first time in that thread (explicitly or by library functions).
            - <b>opt.init</b> - static options. Contains initial property values for <b>opt</b>. Normally you change them when script starts. Don't change later, it's not thread-safe.
            </remarks>
        </member>
        <member name="P:Au.opt.key">
            <summary>
            Options for keyboard and clipboard functions (classes <see cref="T:Au.keys"/>, <see cref="T:Au.clipboard"/> and functions that use them).
            </summary>
            <remarks>
            Each thread has its own <b>opt.key</b> instance. It inherits options from <see cref="P:Au.opt.init.key"/>.
            Also can be used when creating <see cref="T:Au.keys"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            opt.key.KeySpeed = 100;
            keys.send("Right*10 Ctrl+A");
            ]]></code>
            Use a <b>keys</b> instance.
            <code><![CDATA[
            var k = new keys(opt.key); //create new keys instance and copy options from opt.key to it
            k.Options.KeySpeed = 100; //changes option of k but not of opt.key
            k.Add("Right*10 Ctrl+A").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.opt.mouse">
            <summary>
            Options for mouse functions (class <see cref="T:Au.mouse"/> and functions that use it).
            </summary>
            <remarks>
            Each thread has its own <b>opt.mouse</b> instance. It inherits options from <see cref="P:Au.opt.init.mouse"/>.
            </remarks>
            <example>
            <code><![CDATA[
            opt.mouse.ClickSpeed = 100;
            mouse.click();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.opt.wait">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <remarks>
            Each thread has its own <b>opt.wait</b> instance. There is no <b>opt.init.wait</b>.
            Most 'wait for' functions of this library use these options. Functions of .NET classes don't.
            </remarks>
        </member>
        <member name="P:Au.opt.warnings">
            <summary>
            Options for showing run-time warnings and other info that can be useful to find problems in code at run time.
            </summary>
            <remarks>
            Each thread has its own <b>opt.warnings</b> instance. It inherits options from <see cref="P:Au.opt.init.warnings"/>.
            </remarks>
            <example>
            <code><![CDATA[
            opt.warnings.Verbose = false;
            print.warning("Example");
            print.warning("Example");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.opt.init">
            <summary>
            Default <see cref="T:Au.opt"/> properties of a thread.
            </summary>
            <remarks>
            You can change these options at the start of your script/program. Don't change later.
            </remarks>
        </member>
        <member name="P:Au.opt.init.key">
            <summary>
            Default option values for <see cref="P:Au.opt.key"/> of a thread.
            </summary>
            <remarks>
            Also can be used when creating <see cref="T:Au.keys"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            opt.init.key.KeySpeed = 10;
            ...
            keys.send("Tab Ctrl+V"); //uses opt.key, which is implicitly copied from opt.init.key
            ]]></code>
            Use a <b>keys</b> instance.
            <code><![CDATA[
            var k = new keys(opt.init.key); //create new keys instance and copy options from opt.init.key to it
            k.Options.KeySpeed = 100; //changes option of k
            k.Add("Tab Ctrl+V").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.opt.init.mouse">
            <summary>
            Default option values for <see cref="P:Au.opt.mouse"/> of a thread.
            </summary>
            <example>
            <code><![CDATA[
            opt.init.mouse.ClickSpeed = 10;
            ...
            mouse.click(); //uses opt.mouse, which is implicitly copied from opt.init.mouse
            ]]></code>
            </example>
        </member>
        <member name="P:Au.opt.init.warnings">
            <summary>
            Default option values for <see cref="P:Au.opt.warnings"/> of a thread.
            </summary>
            <example>
            <code><![CDATA[
            opt.init.warnings.Verbose = false;
            ]]></code>
            </example>
        </member>
        <member name="T:Au.opt.scope">
            <summary>
            Creates temporary scopes for options.
            Example: <c>using(opt.scope.Key()) { opt.key.KeySpeed=5; ... }</c>.
            </summary>
        </member>
        <member name="M:Au.opt.scope.mouse(System.Boolean)">
            <summary>
            Creates temporary scope for <see cref="P:Au.opt.mouse"/> options. See example.
            </summary>
            <param name="inherit">If true (default), inherit current options. If false, inherit default options (<see cref="T:Au.opt.init"/>).</param>
            <example>
            <code><![CDATA[
            print.it(opt.mouse.ClickSpeed);
            using(opt.scope.Mouse()) {
            	opt.mouse.ClickSpeed = 100;
            	print.it(opt.mouse.ClickSpeed);
            } //here restored automatically
            print.it(opt.mouse.ClickSpeed);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.opt.scope.key(System.Boolean)">
            <summary>
            Creates temporary scope for <see cref="P:Au.opt.key"/> options. See example.
            </summary>
            <param name="inherit">If true (default), inherit current options. If false, inherit default options (<see cref="T:Au.opt.init"/>).</param>
            <example>
            <code><![CDATA[
            print.it(opt.key.KeySpeed);
            using(opt.scope.Key()) {
            	opt.key.KeySpeed = 5;
            	print.it(opt.key.KeySpeed);
            } //here restored automatically
            print.it(opt.key.KeySpeed);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.opt.scope.wait(System.Boolean)">
            <summary>
            Creates temporary scope for <see cref="P:Au.opt.wait"/> options. See example.
            </summary>
            <param name="inherit">If true (default), inherit current options. If false, inherit default options (<see cref="T:Au.opt.init"/>).</param>
            <example>
            <code><![CDATA[
            print.it(opt.wait.Period);
            using(opt.scope.wait()) {
            	opt.wait.Period = 5;
            	print.it(opt.wait.Period);
            } //here restored automatically
            print.it(opt.wait.Period);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.opt.scope.warnings(System.Boolean)">
            <summary>
            Creates temporary scope for <see cref="P:Au.opt.warnings"/> options. See example.
            </summary>
            <param name="inherit">If true (default), inherit current options. If false, inherit default options (<see cref="T:Au.opt.init"/>).</param>
            <example>
            <code><![CDATA[
            opt.warnings.Verbose = false;
            print.it(opt.warnings.Verbose, opt.warnings.IsDisabled("Test*"));
            using(opt.scope.Warnings()) {
            	opt.warnings.Verbose = true;
            	opt.warnings.Disable("Test*");
            	print.it(opt.warnings.Verbose, opt.warnings.IsDisabled("Test*"));
            } //here restored automatically
            print.it(opt.warnings.Verbose, opt.warnings.IsDisabled("Test*"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.opt.scope.all(System.Boolean)">
            <summary>
            Creates temporary scope for all options. See example.
            </summary>
            <param name="inherit">If true (default), inherit current options. If false, inherit default options (<see cref="T:Au.opt.init"/>).</param>
            <example>
            <code><![CDATA[
            print.it(opt.key.KeySpeed, opt.mouse.ClickSpeed);
            using(opt.scope.All()) {
            	opt.key.KeySpeed = 5;
            	opt.mouse.ClickSpeed = 50;
            	print.it(opt.key.KeySpeed, opt.mouse.ClickSpeed);
            } //here restored automatically
            print.it(opt.key.KeySpeed, opt.mouse.ClickSpeed);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.print">
            <summary>
            Writes text to the output window, console, log file or custom writer.
            </summary>
        </member>
        <member name="P:Au.print.isConsoleProcess">
            <summary>
            Returns true if this is a console process.
            </summary>
        </member>
        <member name="P:Au.print.isWritingToConsole">
            <summary>
            Returns true if is writing to console, false if to the output window or log file. Assuming that <see cref="P:Au.print.writer"/> is not changed.
            </summary>
            <remarks>
            Does not write to console in these cases:
            - <see cref="P:Au.print.isConsoleProcess"/> is false.
            - <see cref="P:Au.print.ignoreConsole"/> is true.
            - <see cref="P:Au.print.logFile"/> is not null.
            - The startup info of this process tells to not show console window and to not redirect the standard output.
            </remarks>
        </member>
        <member name="P:Au.print.ignoreConsole">
            <summary>
            If true, Write and related functions in console process don't use the console window. Then everything is like in non-console process.
            </summary>
            <seealso cref="P:Au.print.redirectConsoleOutput"/>
            <seealso cref="P:Au.print.redirectDebugOutput"/>
        </member>
        <member name="M:Au.print.clear">
            <summary>
            Clears the output window or console text (if <see cref="P:Au.print.isWritingToConsole"/>) or log file (if <see cref="P:Au.print.logFile"/> not null).
            </summary>
        </member>
        <member name="M:Au.print.it(System.String)">
            <summary>
            Writes text + <c>"\r\n"</c> to the output.
            </summary>
            <param name="value">
            Text.
            If "" or null, writes empty line. To write "null" if variable s is null, use code <c>print.it((object)s);</c>.
            </param>
            <remarks>
            Can display links, colors, images, etc. More info: [](xref:output_tags).
            
            Where the text goes:
            - If redirected, to wherever it is redirected. See <see cref="P:Au.print.writer"/>.
            - Else if using log file (<see cref="P:Au.print.logFile"/> not null), writes to the file.
            - Else if using console (<see cref="P:Au.print.isWritingToConsole"/> returns true), writes to console.
            - Else if using local <see cref="T:Au.print.Server"/> (in this process), writes to it.
            - Else if exists global <see cref="T:Au.print.Server"/> (in any process), writes to it.
            - Else nowhere.
            </remarks>
        </member>
        <member name="M:Au.print.it(System.Object)">
            <summary>
            Writes value of any type to the output.
            </summary>
            <param name="value">Value of any type. If null, writes "null".</param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.print.it(System.String)"/>.
            If the type is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            
            This overload is used for all types except: strings, arrays, generic collections. They have own overloads; to use this function need to cast to object.
            For <b>Span</b> and other ref struct types use <c>print.it(x.ToString());</c>.
            </remarks>
        </member>
        <member name="M:Au.print.ObjectToString_(System.Object)">
            <summary>
            Converts object to string like <see cref="M:Au.print.it(System.Object)"/> does.
            </summary>
        </member>
        <member name="M:Au.print.it``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of items separated by "\r\n".
            </summary>
            <param name="value">Array or generic collection of any type. If null, writes "null".</param>
            <remarks>
            Calls <see cref="M:Au.print.it(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.print.it(System.Object,System.Object,System.Object[])">
            <summary>
            Writes multiple arguments of any type to the output, using separator ", ".
            </summary>
            <remarks>
            If a value is null, writes "null".
            If a value is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            </remarks>
        </member>
        <member name="P:Au.print.writer">
            <summary>
            Gets or sets object that actually writes text when is called <see cref="M:Au.print.it(System.String)"/>.
            </summary>
            <remarks>
            If you want to redirect or modify or just monitor output text, use code like in the example. It is known as "output redirection".
            Redirection is applied to whole process, not just this thread.
            Redirection affects <see cref="M:Au.print.it(System.String)"/>, <see cref="P:Au.print.redirectConsoleOutput"/> and <see cref="P:Au.print.redirectDebugOutput"/>. It does not affect <see cref="M:Au.print.directly(System.String)"/> and <see cref="M:Au.print.clear"/>.
            Don't call <see cref="M:Au.print.it(System.String)"/> in method <b>WriteLine</b> of your writer class. It would call itself and create stack overflow. Call <see cref="M:Au.print.directly(System.String)"/>, like in the example.
            </remarks>
            <example>
            <code><![CDATA[
            [STAThread]
            static void Main()
            {
            	print.writer = new TestOutputWriter();
            
            	print.it("test");
            }
            
            class TestOutputWriter :TextWriter
            {
            	public override void WriteLine(string value) { print.directly("redirected: " + value); }
            	public override Encoding Encoding => Encoding.Unicode;
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.print._OutputWriter">
            <summary>
            Our default writer class for the Writer property.
            </summary>
        </member>
        <member name="M:Au.print.directly(System.String)">
            <summary>
            Same as <see cref="M:Au.print.it(System.String)"/>, but does not pass the string to <see cref="P:Au.print.writer"/>.
            </summary>
        </member>
        <member name="M:Au.print.warning(System.String,System.Int32,System.String)">
            <summary>
            Writes warning text to the output.
            By default appends the stack trace.
            </summary>
            <param name="text">Warning text.</param>
            <param name="showStackFromThisFrame">If &gt;= 0, appends the stack trace, skipping this number of frames. Default 0.</param>
            <param name="prefix">Text before <i>text</i>. Default <c>"&lt;&gt;Warning: "</c>.</param>
            <remarks>
            Calls <see cref="M:Au.print.it(System.String)"/>.
            Does not show more than 1 warning/second, unless <b>opt.warnings.Verbose</b> == true (see <see cref="P:Au.Types.OWarnings.Verbose"/>).
            To disable some warnings, use code <c>opt.warnings.Disable("warning text wildcard");</c> (see <see cref="M:Au.Types.OWarnings.Disable(System.String[])"/>).
            </remarks>
            <seealso cref="T:Au.Types.OWarnings"/>
        </member>
        <member name="P:Au.print.redirectConsoleOutput">
            <summary>
            Let <b>Console.WriteX</b> methods in non-console process write to the same destination as <see cref="M:Au.print.it(System.String)"/>.
            </summary>
            <remarks>
            If <b>Console.Write</b> text does not end with '\n' character, it is buffered and not displayed until called again with text ending with '\n' character or until called <b>Console.WriteLine</b>.
            
            <b>Console.Clear</b> will not clear output; it will throw exception.
            </remarks>
        </member>
        <member name="P:Au.print.redirectDebugOutput">
            <summary>
            Let <b>Debug.Write</b>, <b>Trace.Write</b> and similar methods also write to the same destination as <see cref="M:Au.print.it(System.String)"/>.
            </summary>
            <remarks>
            Does not replace existing <b>Debug.Write</b> etc destinations, just add new destination.
            
            If <b>Debug/Trace.Write</b> text does not end with '\n' character, it is buffered and not displayed until called again with text ending with '\n' character or until called <b>Debug/Trace.WriteLine</b>.
            
            Tip: To write to the output window even in console process, set <c>print.ignoreConsole=true;</c> before calling this method first time.
            </remarks>
        </member>
        <member name="P:Au.print.logFile">
            <summary>
            Sets log file path.
            When set (not null), text passed to <see cref="M:Au.print.it(System.String)"/> will be written to the file.
            If value is null - restores default behavior.
            </summary>
            <remarks>
            The first <see cref="M:Au.print.it(System.String)"/> etc call (in this process) creates or opens the file and deletes old content if the file already exists.
            
            Also supports mailslots. For <b>LogFile</b> use mailslot name, as documented in <msdn>CreateMailslot</msdn>. Multiple processes can use the same mailslot.
            </remarks>
            <exception cref="T:System.ArgumentException">The 'set' function throws this exception if the value is not full path and not null.</exception>
        </member>
        <member name="P:Au.print.logFileTimestamp">
            <summary>
            Let Write etc also add current time when using log file (see <see cref="P:Au.print.logFile"/>).
            The time is local, not UTC.
            </summary>
        </member>
        <member name="M:Au.print._LogFile.Open">
            <summary>
            Opens LogFile file handle for writing.
            Uses CREATE_ALWAYS, GENERIC_WRITE, FILE_SHARE_READ.
            </summary>
        </member>
        <member name="M:Au.print._LogFile.WriteLine(System.String)">
            <summary>
            Writes s + "\r\n" and optionally timestamp.
            </summary>
            <remarks>
            If fails to write to file: Sets LogFile=null, which closes file handle. Writes a warning and s to the output window or console.
            </remarks>
        </member>
        <member name="M:Au.print._LogFile.Clear">
            <summary>
            Sets file size = 0.
            </summary>
        </member>
        <member name="M:Au.print._LogFile.Close">
            <summary>
            Closes file handle.
            </summary>
        </member>
        <member name="M:Au.print.CreateFile_(System.String,System.Boolean)">
            <summary>
            Calls Api.CreateFile to open file or mailslot.
            </summary>
            <param name="name">File path or mailslot name.</param>
            <param name="openExisting">Use OPEN_EXISTING. If false, uses CREATE_ALWAYS.</param>
        </member>
        <member name="T:Au.print.qm2">
            
        </member>
        <member name="P:Au.print.qm2.use">
            <summary>
            Sets to use QM2 as the output server.
            </summary>
        </member>
        <member name="M:Au.print.qm2.clear">
            <summary>
            Clears QM2 output panel.
            </summary>
        </member>
        <member name="M:Au.print.qm2.write(System.Object)">
            <summary>
            Writes line to QM2.
            </summary>
        </member>
        <member name="M:Au.print.qm2.write(System.Object,System.Object,System.Object[])">
            <summary>
            Writes multiple arguments of any type to the output, using separator ", ".
            </summary>
            <remarks>
            If a value is null, writes "null".
            If a value is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            </remarks>
        </member>
        <member name="M:Au.print.qm2._WriteToQM2(System.String)">
            <param name="s">If null, clears output.</param>
        </member>
        <member name="T:Au.print.Server">
            <summary>
            Receives messages sent by <see cref="M:Au.print.it(System.String)"/>.
            </summary>
            <remarks>
            If server is global, clients can be multiple processes, including this. Else only this process.
            Works asynchronously, to make writing messages faster.
            When a client writes a message, the message arrives to the server with some delay and is placed in a queue.
            You then can get/remove messages from the queue (call <see cref="M:Au.print.Server.GetMessage(Au.Types.PrintServerMessage@)"/>) and display them in a window (for example).
            You can be notified about new messages.
            
            Recommended setup (see example):
            1. When your application starts, create a <b>print.Server</b> instance and assign to a static variable. Call <see cref="M:Au.print.Server.Start"/>.
            2. When your application creates its output window, call <see cref="M:Au.print.Server.SetNotifications(Au.wnd,System.Int32)"/> to set window/message for notifications.
            3. In window procedure, when received the notification message, get/remove/display all new output messages.
            4. Call <see cref="M:Au.print.Server.Stop"/> when closing the window.
            </remarks>
            <example>
            Simple program with output window.
            <code><![CDATA[
            using Au;
            using Au.Types;
            using System;
            using System.Windows.Forms;
            using System.Threading.Tasks;
            
            class OutputFormExample : Form
            {
            	TextBox _tb;
            
            	public OutputFormExample()
            	{
            		_tb = new TextBox();
            		_tb.ReadOnly = true;
            		_tb.Multiline = true;
            		_tb.ScrollBars = ScrollBars.Both;
            		_tb.WordWrap = false;
            		_tb.Dock = DockStyle.Fill;
            		_tb.TabStop = false;
            		this.Controls.Add(_tb);
            	}
            
            	protected override void OnHandleCreated(EventArgs e) {
            		_os.SetNotifications(this.Hwnd(), WM_APP);
            		base.OnHandleCreated(e);
            	}
            
            	protected override void WndProc(ref Message m) {
            		if(m.Msg == WM_APP) _ProcessMessages();
            		base.WndProc(ref m);
            	}
            	
            	internal const int WM_APP = 0x8000;
            
            	void _ProcessMessages()
            	{
            		while(_os.GetMessage(out var m)) {
            			switch(m.Type) {
            			case PrintServerMessageType.Clear:
            				_tb.Clear();
            				break;
            			case PrintServerMessageType.Write:
            				//_tb.AppendText(m.Text);
            				_tb.AppendText($"{DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime()}  {m.Caller}  {m.Text}");
            				break;
            			}
            		}
            	}
            
            	static print.Server _os = new(isGlobal: false);
            
            	[STAThread]
            	static void Main()
            	{
            		_os.Start();
            
            		//test Write and Clear, before and after creating window
            		print.ignoreConsole = true;
            		print.it("test before setting notifications");
            		Task.Run(() => { 1.s(); print.it("test after"); 1.s(); print.clear(); 1.s(); print.it("test after Clear"); });
            
            		Application.Run(new OutputFormExample());
            		_os.Stop();
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.print.Server.#ctor(System.Boolean)">
            <param name="isGlobal">
            If true, will receive output from all processes that don't have local server.
            </param>
        </member>
        <member name="M:Au.print.Server.Start">
            <summary>
            Starts server.
            Returns false if server already exists (if global - in any process).
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.print.Server.Stop">
            <summary>
            Stops server.
            </summary>
        </member>
        <member name="M:Au.print.Server.Finalize">
            <summary>
            Calls Stop.
            </summary>
        </member>
        <member name="M:Au.print.Server.SetNotifications(Au.wnd,System.Int32)">
            <summary>
            Sets window/message to be notified about server events.
            </summary>
            <param name="w">Your window that displays output, or any other window. Its window procedure on <i>message</i> should call <see cref="M:Au.print.Server.GetMessage(Au.Types.PrintServerMessage@)"/> until it returns false. See example in class help.</param>
            <param name="message">Windows message to send to <i>w</i> when one or more output events are available. For example WM_USER or WM_APP.</param>
            <remarks>
            </remarks>
        </member>
        <member name="M:Au.print.Server.LocalWrite_(System.String,System.Int64,System.String)">
            <summary>
            Adds s directly to _messages and sets timer.
            If s is null, it is 'Clear' command.
            Else if !NoNewline, appends "\r\n".
            Used with local server; also with global server when writes server's process.
            </summary>
        </member>
        <member name="M:Au.print.Server.GetMessage(Au.Types.PrintServerMessage@)">
            <summary>
            Gets next message and removes from the queue.
            Returns false if there are no messages.
            </summary>
            <remarks>
            Messages are added to an internal queue when clients call <see cref="M:Au.print.it(System.String)"/> etc. They contain the text, time, etc. This function gets the oldest message and removes it from the queue.
            </remarks>
        </member>
        <member name="P:Au.print.Server.MessageCount">
            <summary>
            Gets the count of messages in the queue.
            </summary>
        </member>
        <member name="P:Au.print.Server.NoNewline">
            <summary>
            Let messages don't end with "\r\n".
            </summary>
            <remarks>
            This can be used for performance, to avoid string copying when using local server. Does not affect performance of global server.
            </remarks>
        </member>
        <member name="P:Au.print.Server.MailslotName_">
            <summary>
            Gets mailslot name like <c>@"\\.\mailslot\Au.print\" + sessionId</c>.
            </summary>
        </member>
        <member name="P:Au.print.Server.TimerName_">
            <summary>
            Gets waitable timer name like "timer.Au.print".
            </summary>
        </member>
        <member name="T:Au.print.Server.SharedMemoryData_">
            <summary>
            Shared memory variables. Used with global server only.
            </summary>
        </member>
        <member name="M:Au.print.TaskEvent_(System.String,System.Int64,System.String,System.Int32)">
            <summary>
            Logs start/end/fail events of miniProgram trigger actions.
            Editor displays it in the "Recent tasks" window, not in the output panel.
            Could also log other events. For example at first used for task start/end/fail events, but now it is implemented in editor.
            </summary>
        </member>
        <member name="T:Au.screen">
            <summary>
            Represents a screen device. Gets its rectangle etc.
            </summary>
            <remarks>
            A computer can have one or more screens (aka display devices, monitors). One of them is the <i>primary</i> screen; its top-left coordinate is 0 0.
            To show or find a window or some object in a particular screen, need to identify the screen somehow. At Windows API level each screen has a unique integer identifier, known as screen handle or HMONITOR. But it is a random variable value and therefore cannot be specified directly in script etc. Instead can be used screen index or some object on that screen (window, point, rectangle).
            
            A <b>screen</b> variable can contain either a screen handle or a callback function that returns a screen handle. If empty, most functions interpret it as the primary screen.
            
            To create <b>screen</b> variables use static functions (like <c>screen.index(1)</c> or <c>screen.primary</c>) or constructors (like <c>new screen(()=>screen.index(1))</c>). Then call non-static functions to get screen properties.
            
            A screen handle cannot be reliably used for a long time. Screen handles may change when changing the configuration of multiple screens. Consider a "lazy" variable, ie with callback function <see cref="P:Au.screen.LazyFunc"/>. Then, whenever a function needs a screen handle, it calls the callback function which returns <b>screen</b> with fresh handle.
            </remarks>
        </member>
        <member name="M:Au.screen.#ctor(System.IntPtr)">
            <summary>
            Creates variable with screen handle, aka HMONITOR.
            </summary>
        </member>
        <member name="M:Au.screen.#ctor(System.Func{Au.screen})">
            <summary>
            Creates variable that calls your function to get screen when need.
            </summary>
        </member>
        <member name="P:Au.screen.Handle">
            <summary>
            Gets screen handle, aka HMONITOR. Returns default(IntPtr) if it wasn't set; see <see cref="P:Au.screen.Now"/>.
            </summary>
        </member>
        <member name="P:Au.screen.LazyFunc">
            <summary>
            Gets callback function that gets screen when need. Returns null if it wasn't set.
            </summary>
        </member>
        <member name="P:Au.screen.IsEmpty">
            <summary>
            Returns true if this variable has no screen handle and no callback function.
            </summary>
        </member>
        <member name="P:Au.screen.Now">
            <summary>
            Returns a copy of this variable with <see cref="P:Au.screen.Handle"/>.
            </summary>
            <remarks>
            If this variable has <see cref="P:Au.screen.Handle"/>, returns its clone. Else if has <see cref="P:Au.screen.LazyFunc"/>, calls it. Else gets the primary screen.
            </remarks>
        </member>
        <member name="P:Au.screen.primary">
            <summary>
            Gets the primary screen.
            </summary>
            <remarks>
            The returned variable has <see cref="P:Au.screen.Handle"/>. To create lazy variable (with <see cref="P:Au.screen.LazyFunc"/>), use <c>screen.index(0, lazy: true)</c>.
            </remarks>
        </member>
        <member name="P:Au.screen.ofMouse">
            <summary>
            Gets lazy <b>screen</b> variable that later will get the screen from the mouse cursor position at that time.
            </summary>
            <remarks>
            If need non-lazy: <c>screen.of(mouse.xy)</c>.
            </remarks>
        </member>
        <member name="P:Au.screen.ofActiveWindow">
            <summary>
            Gets lazy <b>screen</b> variable that later will get the screen of the active window at that time.
            </summary>
            <remarks>
            If need non-lazy: <c>screen.of(wnd.active)</c>.
            </remarks>
        </member>
        <member name="M:Au.screen.of(Au.wnd,Au.Types.SODefault,System.Boolean)">
            <summary>
            Gets screen containing the biggest part of the specified window or nearest to it.
            </summary>
            <param name="w">Window or control. If default(wnd) or invalid, gets the primary screen.</param>
            <param name="defaultScreen"></param>
            <param name="lazy">
            Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will get screen handle.
            Other ways to create lazy:
            - use <b>wndFinder</b>. Example: <c>screen.of(new wndFinder("* Notepad"))</c>.
            - use constructor. Example: <c>new screen(() => screen.of(wnd.findFast(cn: "Notepad")))</c>.
            </param>
        </member>
        <member name="M:Au.screen.of(Au.wndFinder,Au.Types.SODefault,System.Boolean)">
            <summary>
            Gets screen containing the biggest part of the specified window or nearest to it.
            </summary>
            <param name="f">Window finder. If window not found, gets the primary screen.</param>
            <param name="defaultScreen"></param>
            <param name="lazy">Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will find window and get screen handle. Default true.</param>
        </member>
        <member name="M:Au.screen.of(System.Windows.Forms.Control,Au.Types.SODefault,System.Boolean)">
            <summary>
            Gets screen containing the biggest part of the specified winforms window or control or nearest to it.
            </summary>
            <param name="c">Window or control. If handle not created, gets the primary screen. Cannot be null.</param>
            <param name="defaultScreen"></param>
            <param name="lazy">Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will get screen handle.</param>
        </member>
        <member name="M:Au.screen.of(System.Windows.Window,Au.Types.SODefault,System.Boolean)">
            <summary>
            Gets screen containing the biggest part of the specified WPF window or nearest to it.
            </summary>
            <param name="w">WPF window. If handle not created, gets the primary screen. Cannot be null.</param>
            <param name="defaultScreen"></param>
            <param name="lazy">Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will get screen handle.</param>
        </member>
        <member name="M:Au.screen.of(System.Windows.FrameworkElement,Au.Types.SODefault,System.Boolean)">
            <summary>
            Gets screen containing the biggest part of the specified WPF element (of its rectangle) or nearest to it.
            </summary>
            <param name="elem">WPF element. If not loaded, gets the primary screen. Cannot be null.</param>
            <param name="defaultScreen"></param>
            <param name="lazy">Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will get screen handle.</param>
        </member>
        <member name="M:Au.screen.of(Au.Types.POINT,Au.Types.SODefault)">
            <summary>
            Gets screen containing the specified point or nearest to it.
            </summary>
            <param name="p"></param>
            <param name="defaultScreen"></param>
            <remarks>
            The returned variable has <see cref="P:Au.screen.Handle"/>. To create lazy variable (with <see cref="P:Au.screen.LazyFunc"/>), use constructor. Example: <c>new screen(() => screen.of(500, screen.primary.Rect.Height))</c>.
            </remarks>
        </member>
        <member name="M:Au.screen.of(System.Int32,System.Int32,Au.Types.SODefault)">
            <summary>
            Gets screen containing the specified point or nearest to it.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="defaultScreen"></param>
        </member>
        <member name="M:Au.screen.of(Au.Types.RECT,Au.Types.SODefault)">
            <summary>
            Gets screen containing the biggest part of the specified rectangle or nearest to it.
            </summary>
            <param name="r"></param>
            <param name="defaultScreen"></param>
            <remarks>
            The returned variable has <see cref="P:Au.screen.Handle"/>. To create lazy variable (with <see cref="P:Au.screen.LazyFunc"/>), use constructor. Example: <c>new screen(() => screen.of(new RECT(...)))</c>.
            </remarks>
        </member>
        <member name="P:Au.screen.all">
            <summary>
            Gets all screens.
            </summary>
            <remarks>
            The order of array elements may be different than in Windows Settings (Control Panel). The primary screen is always at index 0.
            The array is not cached. Each time calls API <msdn>EnumDisplayMonitors</msdn>.
            </remarks>
        </member>
        <member name="M:Au.screen.index(System.Int32,System.Boolean)">
            <summary>
            Gets screen at the specified index of the <see cref="P:Au.screen.all"/> array.
            </summary>
            <param name="index">0-based screen index. Index 0 is the primary screen. If index too big, gets the primary screen.</param>
            <param name="lazy">Create variable with <see cref="P:Au.screen.LazyFunc"/> that later will get screen handle.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative index.</exception>
        </member>
        <member name="P:Au.screen.ScreenIndex">
            <summary>
            Gets index of this screen in the <see cref="P:Au.screen.all"/> array.
            </summary>
            <remarks>
            Returns 0 (index of primary screen) if this variable is empty. Returns -1 if the screen handle is invalid; it can happen after changing display settings, but is rare.
            </remarks>
        </member>
        <member name="P:Au.screen.Info">
            <summary>
            Gets screen rectangle and other info.
            </summary>
            <returns>
            Tuple containing:
            - rect - screen rectangle.
            - workArea - work area rectangle.
            - isPrimary - true if it is the primary screen.
            - isAlive - false if the screen handle is invalid; then the function gets info of the primary screen.
            </returns>
            <remarks>
            If this variable holds a callback function, this function calls it to get screen handle. See also <see cref="P:Au.screen.Now"/>.
            </remarks>
        </member>
        <member name="M:Au.screen.GetRect(System.Boolean)">
            <summary>
            Calls <see cref="P:Au.screen.Info"/> and returns rectangle of the screen or its work area.
            </summary>
            <param name="workArea">Get work area rectangle.</param>
        </member>
        <member name="P:Au.screen.Rect">
            <summary>
            Calls <see cref="P:Au.screen.Info"/> and returns screen rectangle.
            </summary>
        </member>
        <member name="P:Au.screen.WorkArea">
            <summary>
            Calls <see cref="P:Au.screen.Info"/> and returns work area rectangle.
            </summary>
        </member>
        <member name="P:Au.screen.Dpi">
            <summary>
            Gets DPI of this screen.
            Calls <see cref="M:Au.More.Dpi.OfScreen(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="P:Au.screen.IsAlive">
            <summary>
            True if the screen handle is valid.
            </summary>
            <remarks>
            Don't use with variables that hold a callback function. This function does not call it and returns false.
            </remarks>
        </member>
        <member name="M:Au.screen.ToString">
            
        </member>
        <member name="M:Au.screen.GetHashCode">
            
        </member>
        <member name="M:Au.screen.Equals(Au.screen)">
            
        </member>
        <member name="M:Au.screen.op_Equality(Au.screen,Au.screen)">
            
        </member>
        <member name="M:Au.screen.op_Inequality(Au.screen,Au.screen)">
            
        </member>
        <member name="M:Au.screen.isInAnyScreen(Au.Types.POINT)">
            <summary>
            Returns true if point p is in some screen.
            </summary>
        </member>
        <member name="M:Au.screen.isInAnyScreen(Au.Types.RECT)">
            <summary>
            Returns true if rectangle r intersects with some screen.
            </summary>
        </member>
        <member name="M:Au.screen.isInAnyScreen(Au.wnd)">
            <summary>
            Returns true if rectangle of window w intersects with some screen.
            </summary>
        </member>
        <member name="P:Au.screen.virtualScreen">
            <summary>
            Gets bounding rectangle of all screens.
            </summary>
        </member>
        <member name="T:Au.csvTable">
            <summary>
            Parses and composes CSV text. Stores CSV table data in memory as a <b>List</b> of string arrays.
            </summary>
            <remarks>
            CSV is a text format used to store a single table of data in human-readable/editable way.
            It is a list of lines (called rows or records) containing one or more values (called fields or cells) separated by a separator character.
            There is no strictly defined CSV standard. <b>csvTable</b> uses these rules:
            	Fields containg separator characters (default ','), quote characters (default '"') and multiple lines are enclosed in quote characters. Example: "ab, cd".
            	Each quote character in such fields is escaped (replaced) with two quote characters. Example: "ab ""cd"" ef".
            	If a field value starts or ends with ASCII space or tab characters, it is enclosed in quote characters. Example: " ab ". Or use parameter <i>trimSpaces</i> false when parsing.
            	Rows in CSV text can have different field count. All rows in in-memory CSV table have equal field count.
            </remarks>
        </member>
        <member name="M:Au.csvTable.#ctor">
            <summary>
            Initializes new <see cref="T:Au.csvTable"/> variable that can be used to add rows.
            To create new variables from CSV text, file or dictionary, instead use static functions, for example <see cref="M:Au.csvTable.parse(System.String,System.Char,System.Char,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.csvTable.Rows">
            <summary>
            Gets the internal <b>List</b> containing rows as string arrays.
            </summary>
            <remarks>
            It's not a copy; changing its content will change content of this <see cref="T:Au.csvTable"/> variable.
            You can do anything with the <b>List</b>. For example, sort it, find rows containing certain field values, get/set field values directly, add/remove rows directly.
            All row arrays have <b>Length</b> equal to <see cref="P:Au.csvTable.ColumnCount"/>, and it must remain so; you can change <b>Length</b>, but then need to call <c>ColumnCount=newLength</c>.
            </remarks>
            <example>
            <code><![CDATA[
            x.Rows.Sort((a,b) => string.CompareOrdinal(a[0], b[0]));
            ]]></code>
            </example>
        </member>
        <member name="P:Au.csvTable.Separator">
            <summary>
            Sets or gets the field separator character used when composing CSV text.
            Initially it is ','.
            </summary>
        </member>
        <member name="P:Au.csvTable.Quote">
            <summary>
            Sets or gets the quote character used when composing CSV text.
            Initially it is '"'.
            </summary>
        </member>
        <member name="M:Au.csvTable.parse(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Parses CSV string and creates new <see cref="T:Au.csvTable"/> variable that contains data in internal <b>List</b> of string arrays.
            </summary>
            <param name="csv">
            CSV text.
            If rows in CSV text have different field count, the longest row sets the <see cref="P:Au.csvTable.ColumnCount"/> property and lenghts of all row arrays; array elements of missing CSV fields will be null.
            </param>
            <param name="separator">Field separator character used in CSV text. Default ','.</param>
            <param name="quote">Character used in CSV text to enclose some fields. Default '"'.</param>
            <param name="trimSpaces">Ignore ASCII space and tab characters surrounding fields in CSV text. Default true.</param>
            <exception cref="T:System.FormatException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
        </member>
        <member name="M:Au.csvTable.ToString">
            <summary>
            Composes CSV text from the internal <b>List</b> of string arrays.
            </summary>
            <remarks>
            Depends on these properties: <see cref="P:Au.csvTable.Separator"/> (initially ','), <see cref="P:Au.csvTable.Quote"/> (initially '"').
            </remarks>
        </member>
        <member name="P:Au.csvTable.RowCount">
            <summary>
            Gets or sets row count.
            The 'get' function returns the <b>Count</b> property of the internal <b>List</b> of string arrays.
            The 'set' function can add new rows or remove rows at the end.
            </summary>
        </member>
        <member name="P:Au.csvTable.ColumnCount">
            <summary>
            Gets or sets column count.
            The 'get' function returns the length of all string arrays in the internal <b>List</b>.
            The 'set' function can add new columns or remove columns at the right.
            </summary>
        </member>
        <member name="P:Au.csvTable.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a field.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.csvTable.RowCount"/>; then adds new row.</param>
            <param name="column">0-based column index. With the 'set' function it can be &gt;= <see cref="P:Au.csvTable.ColumnCount"/> and &lt; 1000; then sets <c>ColumnCount = column + 1</c>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.csvTable.Item(System.Int32)">
            <summary>
            Gets or sets fields in a row.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.csvTable.RowCount"/>; then adds new row.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'get' function gets the row array. It's not a copy; changing its elements will change content of this <see cref="T:Au.csvTable"/> variable.
            The 'set' function sets the row array. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.csvTable.ColumnCount"/>.
            </remarks>
        </member>
        <member name="M:Au.csvTable.AddRow(System.String[])">
            <summary>
            Adds new row and sets its fields.
            </summary>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.csvTable.ColumnCount"/>. Adds new columns if array <b>Length</b> (or the number of string arguments) is greater than ColumnCount.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.InsertRow(System.Int32,System.String[])">
            <summary>
            Inserts new row and sets its fields.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.csvTable.RowCount"/>, adds to the end.</param>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.csvTable.ColumnCount"/>. Adds new columns if array <b>Length</b> (or the number of string arguments) is greater than ColumnCount.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.InsertRow(System.Int32)">
            <summary>
            Inserts new empty row.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.csvTable.RowCount"/>, adds to the end.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.RemoveRow(System.Int32,System.Int32)">
            <summary>
            Removes one or more rows.
            </summary>
            <param name="index">0-based row index.</param>
            <param name="count">How many rows to remove, default 1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.csvTable.load(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Loads and parses a CSV file.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.</param>
            <param name="separator">Field separator character used in CSV text. Default ','.</param>
            <param name="quote">Character used in CSV text to enclose some fields. Default '"'.</param>
            <param name="trimSpaces">Ignore ASCII space and tab characters surrounding fields in CSV text. Default true.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllText(System.String)"/>.</exception>
            <exception cref="T:System.FormatException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
            <remarks>
            Calls <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.csvTable.parse(System.String,System.Char,System.Char,System.Boolean)"/>. Also uses <see cref="M:Au.filesystem.waitIfLocked(System.Action,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.csvTable.Save(System.String,System.Boolean)">
            <summary>
            Composes CSV and saves to file.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>. The file can exist or not; this function overwrites it.</param>
            <param name="backup">Create backup file named file + "~backup".</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.</exception>
            <remarks>
            Calls <see cref="M:Au.csvTable.ToString"/> and <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>. Also uses <see cref="M:Au.filesystem.save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.csvTable.fromDictionary(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates 2-column CSV table from dictionary keys and values of type string.
            </summary>
            <param name="d"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.csvTable.fromDictionary``1(System.Collections.Generic.Dictionary{System.String,``0},System.Func{``0,System.String})">
            <summary>
            Creates 2-column CSV table from dictionary keys and values of any type, using a callback function to convert values to string.
            </summary>
            <param name="d"></param>
            <param name="valueToString">Callback function that converts value of type T to string.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.csvTable.fromDictionary``1(System.Collections.Generic.Dictionary{System.String,``0},System.Int32,System.Action{``0,System.String[]})">
            <summary>
            Creates CSV table of any column count from dictionary keys and values of any type, using a callback function to convert values to cell strings.
            </summary>
            <param name="d"></param>
            <param name="columnCount">CSV column count. Must be 2 or more.</param>
            <param name="valueToCells">Callback function that converts value of type T to one or more strings and puts them in row array elements starting from index 1. At index 0 is key.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">columnCount less than 2.</exception>
        </member>
        <member name="M:Au.csvTable.ToDictionary(System.Boolean,System.Boolean)">
            <summary>
            Creates dictionary from this 2-column CSV table.
            </summary>
            <param name="ignoreCase">Case-insensitive dictionary keys.</param>
            <param name="ignoreDuplicates">Don't throw exception if column 0 contains duplicate strings. Replace old value with new value.</param>
            <exception cref="T:System.InvalidOperationException"><b>ColumnCount</b> not 2.</exception>
            <exception cref="T:System.ArgumentException">Column 0 contains duplicate strings.</exception>
        </member>
        <member name="M:Au.csvTable.ToDictionary``1(System.Boolean,System.Boolean,System.Func{System.String[],``0})">
            <summary>
            Creates dictionary from this CSV table of any column count, using a callback function to convert cell strings to dictionary values of any type.
            </summary>
            <param name="ignoreCase">Case-insensitive dictionary keys.</param>
            <param name="ignoreDuplicates">Don't throw exception if column 0 contains duplicate strings. Replace old value with new value.</param>
            <param name="rowToValue">Callback function that converts one or more cell strings to single value of type T. The array is whole row; element 0 is key, and usually is not used.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"><b>ColumnCount</b> less than 2.</exception>
            <exception cref="T:System.ArgumentException">Column 0 contains duplicate strings.</exception>
        </member>
        <member name="M:Au.csvTable.SetInt(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <param name="hex">Let the number be in hexadecimal format, like 0x3A.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.GetInt(System.Int32,System.Int32)">
            <summary>
            Gets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.SetDouble(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.csvTable.GetDouble(System.Int32,System.Int32)">
            <summary>
            Gets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.csvTable.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.ExtString">
            <summary>
            Adds extension methods for <see cref="T:System.String"/>.
            </summary>
            <remarks>
            Some .NET <see cref="T:System.String"/> methods use <see cref="F:System.StringComparison.CurrentCulture"/> by default, while others use ordinal or invariant comparison. It is confusing (difficult to remember), dangerous (easy to make bugs), slower and rarely useful.
            Microsoft recommends to specify <b>StringComparison.Ordinal[IgnoreCase]</b> explicitly. See https://msdn.microsoft.com/en-us/library/ms973919.aspx.
            This class adds ordinal comparison versions of these methods. Same or similar name, for example <b>Ends</b> for <b>EndsWith</b>.
            See also <see cref="P:Au.process.thisProcessCultureIsInvariant"/>.
            
            This class also adds more methods.
            You also can find string functions in other classes of this library, including <see cref="T:Au.More.StringUtil"/>, <see cref="T:Au.regexp"/>, <see cref="T:Au.pathname"/>, <see cref="T:Au.csvTable"/>, <see cref="T:Au.keys.more"/>, <see cref="T:Au.More.Convert2"/>, <see cref="T:Au.More.Hash"/>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.String,System.Boolean)">
            <summary>
            Compares this and other string. Returns true if equal.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="s">Other string. Can be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
            <seealso cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
            <seealso cref="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.Boolean,System.String[])">
            <summary>
            Compares this strings with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings. Strings can be null.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Compares part of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string. If invalid, returns false.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
            <seealso cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
            <seealso cref="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.Int32,System.Boolean,System.String[])">
            <summary>
            Compares part of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string. If invalid, returns false.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.Range,System.String,System.Boolean)">
            <summary>
            Compares part of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="range">Range of this string. Can return true only if its length == s.Length. If invalid, returns false.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
            <seealso cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
            <seealso cref="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Au.ExtString.Eq(System.String,System.Int32,System.Char)">
            <summary>
            Returns true if the specified character is at the specified position in this string.
            </summary>
            <param name="t">This string.</param>
            <param name="index">Offset in this string. If invalid, returns false.</param>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.ExtString.Eqi(System.String,System.String)">
            <summary>
            Compares this and other string ignoring case (case-insensitive). Returns true if equal.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="s">Other string. Can be null.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Ends(System.String,System.String,System.Boolean)">
            <summary>
            Compares the end of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Ends(System.String,System.Boolean,System.String[])">
            <summary>
            Compares the end of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Ends(System.String,System.Char)">
            <summary>
            Returns true if this string ends with the specified character.
            </summary>
            <param name="t">This string.</param>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.ExtString.Starts(System.String,System.String,System.Boolean)">
            <summary>
            Compares the beginning of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Starts(System.String,System.Boolean,System.String[])">
            <summary>
            Compares the beginning of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Starts(System.String,System.Char)">
            <summary>
            Returns true if this string starts with the specified character.
            </summary>
            <param name="t">This string.</param>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.ExtString.Find(System.String,System.String,System.Boolean)">
            <summary>
            Finds substring in this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Find(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Finds substring in part of this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="startIndex">The search start index.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startIndex</i>.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Find(System.String,System.String,System.Range,System.Boolean)">
            <summary>
            Finds substring in part of this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="range">The search range.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.FindAny(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the first character specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.ExtString.FindNot(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the first character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.ExtString.IndexOfNot(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Finds the first character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.LastIndexOfNot(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Finds the last character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.FindLastAny(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the last character specified in <i>chars</i> (searches right to left). Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.ExtString.FindLastNot(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the last character not specified in <i>chars</i> (searches right to left). Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.ExtString.Trim(System.String,System.String)">
            <summary>
            Removes specified characters from the start and end of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.TrimStart(System.String,System.String)">
            <summary>
            Removes specified characters from the start of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.TrimEnd(System.String,System.String)">
            <summary>
            Removes specified characters from the end of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.FindWord(System.String,System.String,System.Nullable{System.Range},System.Boolean,System.String)">
            <summary>
            Finds whole word. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="range">The search range.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="otherWordChars">Additional word characters, for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false. For example "_".</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <remarks>
            If <i>s</i> starts with a word character finds substring that is not preceded by a word character.
            If <i>s</i> ends with a word character, finds substring that is not followed by a word character.
            Word characters are those for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns true plus those specified in <i>otherWordChars</i>.
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.ExtString.Lenn(System.String)">
            <summary>
            Returns <see cref="P:System.String.Length"/>. Returns 0 if this string is null.
            </summary>
            <param name="t">This string.</param>
        </member>
        <member name="M:Au.ExtString.NE(System.String)">
            <summary>
            Returns true if this string is null or empty ("").
            </summary>
            <param name="t">This string.</param>
        </member>
        <member name="M:Au.ExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})">
            <summary>
            This function can be used with foreach to split this string into substrings as start/end offsets.
            </summary>
            <param name="t">This string.</param>
            <param name="separators">Characters that delimit the substrings. Or one of <see cref="T:Au.Types.SegSep"/> constants.</param>
            <param name="flags"></param>
            <param name="range">Part of this string to split.</param>
            <example>
            <code><![CDATA[
            string s = "one * two three ";
            foreach(var t in s.Segments(" ")) print.it(s[t.start..t.end]);
            foreach(var t in s.Segments(SegSep.Word, SegFlags.NoEmpty)) print.it(s[t.start..t.end]);
            ]]></code>
            </example>
            <seealso cref="M:Au.ExtString.Lines(System.String,System.Boolean)"/>
        </member>
        <member name="M:Au.ExtString.Lines(System.String,System.Boolean)">
            <summary>
            Splits this string using newline separators "\r\n", "\n", "\r".
            </summary>
            <param name="t">This string.</param>
            <param name="noEmpty">Don't need empty lines.</param>
            <seealso cref="M:Au.ExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/>
            <seealso cref="F:Au.Types.SegSep.Line"/>
        </member>
        <member name="M:Au.ExtString.Lines(System.String,System.Int32,System.StringSplitOptions)">
            <summary>
            Splits this string into lines using separators "\r\n", "\n", "\r".
            </summary>
            <param name="t">This string.</param>
            <param name="maxCount">The maximal number of substrings to get.</param>
            <param name="options"></param>
            <seealso cref="M:Au.ExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/>
            <seealso cref="F:Au.Types.SegSep.Line"/>
        </member>
        <member name="M:Au.ExtString.LineCount(System.String,System.Boolean,System.Nullable{System.Range})">
            <summary>
            Returns the number of lines.
            Counts line separators "\r\n", "\n", "\r".
            </summary>
            <param name="t">This string.</param>
            <param name="preferMore">Add 1 if the string ends with a line separator or its length is 0.</param>
            <param name="range">Part of this string or null (default).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:Au.More.StringUtil.LineAndColumn(System.String,System.Int32,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Au.ExtString.Lower(System.String)">
            <summary>
            Converts this string to lower case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <remarks>
            Calls <see cref="M:System.String.ToLowerInvariant"/>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.Upper(System.String)">
            <summary>
            Converts this string to upper case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <remarks>
            Calls <see cref="M:System.String.ToUpperInvariant"/>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.Upper(System.String,Au.Types.SUpper,System.Globalization.CultureInfo)">
            <summary>
            Converts this string or only the first character to upper case or all words to title case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="how"></param>
            <param name="culture">Culture, for example <c>CultureInfo.CurrentCulture</c>. If null (default) uses invariant culture.</param>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number and gets the number end index.
            Returns the number, or 0 if fails to convert.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in this string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike <b>int.Parse</b> and <b>Convert.ToInt32</b>:
            	The number in string can be followed by more text, like <c>"123text"</c>.
            	Has <i>startIndex</i> parameter that allows to get number from middle, like <c>"text123text"</c>.
            	Gets the end of the number part.
            	No exception when cannot convert.
            	The number can be decimal (like <c>"123"</c>) or hexadecimal (like <c>"0x1A"</c>); don't need separate flags for each style.
            	Does not depend on current culture. As minus sign recognizes '-' and '−'.
            	Faster.
            
            The number in string can start with ASCII whitespace (spaces, newlines, etc), like <c>" 5"</c>.
            The number in string can be with <c>"-"</c> or <c>"+"</c>, like <c>"-5"</c>, but not like <c>"- 5"</c>.
            Fails if the number is greater than +- <b>uint.MaxValue</b> (0xffffffff).
            The return value becomes negative if the number is greater than <b>int.MaxValue</b>, for example <c>"0xffffffff"</c> is -1, but it becomes correct if assigned to uint (need cast).
            Does not support non-integer numbers; for example, for <c>"3.5E4"</c> returns 3 and sets <c>numberEndIndex=startIndex+1</c>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number.
            Returns the number, or 0 if fails to convert.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int32@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number and gets the number end index.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in this string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int32@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.UInt32@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to uint number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.UInt32@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to uint number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int64@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to long number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.Int64@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to long number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.UInt64@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to ulong number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToInt(System.String,System.UInt64@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to ulong number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to double number.
            Returns the number, or 0 if fails to convert.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            Fails if the string is null or "" or isn't a valid floating-point number.
            Examples of valid numbers: "12", " -12.3 ", ".12", "12.", "12E3", "12.3e-45", "1,234.5" (with style <c>NumberStyles.Float | NumberStyles.AllowThousands</c>). String like "2text" is invalid, unless range is <c>0..1</c>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.Double@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to double number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.Single@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to float number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.Int32@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to int number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Int32.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.UInt32@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to uint number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.UInt32.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt32@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.Int64@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to long number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Int64.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ToNumber(System.String,System.UInt64@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to ulong number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.UInt64.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt64@)"/>. Uses <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> if the string range contains only ASCII characters, else uses current culture.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ReplaceAt(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Replaces part of this string with other string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string.</param>
            <param name="count">Count of characters to replace.</param>
            <param name="s">The replacement string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startIndex</i> or <i>count</i>.</exception>
        </member>
        <member name="M:Au.ExtString.RemoveSuffix(System.String,System.String,System.Boolean)">
            <summary>
            Removes <i>suffix</i> string from the end.
            Returns the result string. Returns this string if does not end with <i>suffix</i>.
            </summary>
            <param name="t">This string.</param>
            <param name="suffix">Substring to remove.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>suffix</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.RemoveSuffix(System.String,System.Char)">
            <summary>
            Removes <i>suffix</i> character from the end.
            Returns the result string. Returns this string if does not end with <i>suffix</i>.
            </summary>
            <param name="t">This string.</param>
            <param name="suffix">Character to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>suffix</i> is null.</exception>
        </member>
        <member name="M:Au.ExtString.Limit(System.String,System.Int32,System.Boolean)">
            <summary>
            If this string is longer than <i>limit</i>, returns its substring 0 to <i>limit</i>-1 with appended '…' character.
            Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">Maximal length of the result string. If less than 1, is used 1.</param>
            <param name="middle">Let "…" be in middle. For example it is useful when the string is a path, to avoid removing filename.</param>
        </member>
        <member name="M:Au.ExtString.Escape(System.String,System.Int32,System.Boolean)">
            <summary>
            Replaces unsafe characters with C# escape sequences.
            If the string contains these characters, replaces and returns new string. Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">If the final string is longer than <i>limit</i>, get its substring 0 to <i>limit</i>-1 with appended '…' character. The enclosing "" are not counted.</param>
            <param name="quote">Enclose in "".</param>
            <remarks>
            Replaces these characters: <c>'\\'</c>, <c>'\"'</c>, <c>'\t'</c>, <c>'\n'</c>, <c>'\r'</c> and all in range 0-31.
            </remarks>
        </member>
        <member name="M:Au.ExtString.Unescape(System.String,System.String@)">
            <summary>
            Replaces C# escape sequences to characters in this string.
            Returns true if successful. Returns false if the string contains an invalid or unsupported escape sequence.
            </summary>
            <param name="t">This string.</param>
            <param name="result">Receives the result string. It is this string if there are no escape sequences or if fails.</param>
            <remarks>
            Supports all escape sequences of <see cref="M:Au.ExtString.Escape(System.String,System.Int32,System.Boolean)"/>: \\ \" \t \n \r \0 \uXXXX.
            Does not support \a \b \f \v \' \xXXXX \UXXXXXXXX.
            </remarks>
        </member>
        <member name="M:Au.ExtString.ReverseString(System.String,System.Boolean)">
            <summary>
            Reverses this string, like "Abc" -> "cbA".
            Returns the result string.
            </summary>
            <param name="t"></param>
            <param name="raw">Ignore char sequences such as Unicode surrogates and grapheme clusters. Faster, but if the string contains these sequences, the result string is incorrect.</param>
        </member>
        <member name="M:Au.ExtString.IsAscii(System.String)">
            <summary>
            Returns true if specified part of string does not contain non-ASCII characters.
            </summary>
            <seealso cref="M:Au.ExtString.IsAscii(System.ReadOnlySpan{System.Char})"/>
        </member>
        <member name="M:Au.ExtString.IsAscii(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if specified part of string does not contain non-ASCII characters.
            </summary>
        </member>
        <member name="M:Au.ExtString.RegexIsMatch(System.String,System.String,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexMatch(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="result">Receives match info.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexMatch(System.String,System.String,System.Int32,System.String@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets whole match or some group, as string.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.MatchS(System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of result. If 0 (default) - whole match.</param>
            <param name="result">Receives the match value.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexMatch(System.String,System.String,System.Int32,Au.Types.RXGroup@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets whole match or some group, as index and length.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of result. If 0 (default) - whole match.</param>
            <param name="result">Receives match info.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexFindAll(System.String,System.String,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexFindAll(System.String,System.String,Au.Types.RXMatch[]@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.FindAll(System.String,Au.Types.RXMatch[]@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="result">Receives all found matches.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexFindAll(System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.FindAllS(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of results. If 0 (default) - whole match.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexFindAll(System.String,System.String,System.Int32,System.String[]@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>. Gets array of strings.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.FindAllS(System.String,System.String[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of results. If 0 (default) - whole match.</param>
            <param name="result">Receives all found matches.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexReplace(System.String,System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="repl">Replacement pattern.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid regular expression.
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexReplace(System.String,System.String,System.String,System.String@,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Replace(System.String,System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="repl">Replacement pattern.</param>
            <param name="result">The result string.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid regular expression.
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexReplace(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>. Uses a callback function.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="replFunc">Callback function that receives found matches and returns replacements.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid regular expression.
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexReplace(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>. Uses a callback function.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="replFunc">Callback function that receives found matches and returns replacements.</param>
            <param name="result">The result string.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid regular expression.
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString.RegexSplit(System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns array of substrings delimited by PCRE regular expression <i>rx</i> matches.
            Parameters etc are of <see cref="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.regexp.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.regexp"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="maxCount">Maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.ExtString._RegexCache.AddOrGet(System.String,Au.Types.RXFlags)">
            <summary>
            If rx/flags is in the cache, returns the cached code.
            Else compiles rx/flags, adds to the cache and returns the code.
            </summary>
            <param name="rx"></param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason.</exception>
        </member>
        <member name="M:Au.ExtString.Like(System.String,System.String,System.Boolean)">
            <summary>
            Compares this string with a string that possibly contains wildcard characters.
            Returns true if the strings match.
            </summary>
            <param name="t">This string. If null, returns false. If "", returns true if pattern is "" or "*".</param>
            <param name="pattern">String that possibly contains wildcard characters. Cannot be null. If "", returns true if this string is "". If "*", always returns true except when this string is null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Wildcard characters:
            
            Character | Will match | Examples
            | - | - | - |
            | * | Zero or more of any characters. | <c>"start*"</c>, <c>"*end"</c>, <c>"*middle*"</c>
            | ? | Any single character. | <c>"date ????-??-??"</c>
            
            There are no escape sequences for * and ? characters.
            
            Uses ordinal comparison, ie does not depend on current culture.
            
            Much faster than regular expression.
            
            See also: [](xref:wildcard_expression).
            </remarks>
            <example>
            <code><![CDATA[
            string s = @"C:\abc\mno.xyz";
            if(s.Like(@"C:\abc\mno.xyz")) print.it("matches whole text (no wildcard characters)");
            if(s.Like(@"C:\abc\*")) print.it("starts with");
            if(s.Like(@"*.xyz")) print.it("ends with");
            if(s.Like(@"*mno*")) print.it("contains");
            if(s.Like(@"C:\*.xyz")) print.it("starts and ends with");
            if(s.Like(@"?:*")) print.it("any character, : and possibly more text");
            ]]></code>
            </example>
            <seealso cref="T:Au.wildex"/>
        </member>
        <member name="M:Au.ExtString.Like(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/> for each wildcard pattern specified in the argument list until it returns true.
            Returns 1-based index of matching pattern, or 0 if none.
            </summary>
            <param name="t"></param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="patterns">One or more wildcard strings. The array and strings cannot be null.</param>
        </member>
        <member name="T:Au.regexp">
            <summary>
            PCRE regular expression.
            </summary>
            <remarks>
            PCRE is a regular expression library: <see href="https://www.pcre.org/"/>.
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            Some websites with tutorials and info: <see href="https://www.rexegg.com/">rexegg</see>, <see href="https://www.regular-expressions.info/">regular-expressions.info</see>.
            
            This class is an alternative to the .NET <see cref="T:System.Text.RegularExpressions.Regex"/> class. The regular expression syntax is similar. PCRE has some features unavailable in .NET, and vice versa. In most cases PCRE is about 2 times faster. You can use any of these classes. Functions of <see cref="T:Au.elm"/> class support only PCRE.
            
            Terms used in this documentation and in names of functions and types:
            - <i>regular expression</i> - regular expression string. Also known as <i>pattern</i>.
            - <i>subject string</i> - the string in which to search for the regular expression. Also known as <i>input string</i>.
            - <i>match</i> - the part (substring) of the subject string that matches the regular expression.
            - <i>groups</i> - regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). Also known as <i>capturing group</i>, <i>capturing subpattern</i>. Often term <i>group</i> also is used for group matches.
            - <i>group match</i> - the part (substring) of the subject string that matches the group. Also known as <i>captured substring</i>.
            
            This library uses an unmanaged code dll AuCpp.dll that contains PCRE code. This class is a managed wrapper for it. The main PCRE API functions used by this class are <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile and pcre2_match</see>. The <b>regexp</b> constructor calls <b>pcre2_compile</b> and stores the compiled code in the variable. Other <b>regexp</b> functions call <b>pcre2_match</b>. Compiling to native code (JIT) is not supported.
            
            A <b>regexp</b> variable can be used by multiple threads simultaneously.
            
            Also there are several <b>String</b> extension methods that use this class. The string variable is the subject string. These methods create and use cached <b>regexp</b> instances for speed. The <b>regexp</b> constructor does not use caching.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var x = new regexp(@"\b(\w+?)(\d+)\b"); //regular expression
             
             print.it("//IsMatch:");
            print.it(x.IsMatch(s));
             
             print.it("//Match:");
            if(x.Match(s, out var m)) print.it(m.Value, m[1].Value, m[2].Value);
             
             print.it("//FindAll with foreach:");
            foreach(var v in x.FindAll(s)) print.it(v.Value, v[1].Value, v[2].Value);
             print.it("//FindAllS, get only strings of group 2:");
            print.it(x.FindAllS(s, 2));
             
             print.it("//Replace:");
            print.it(x.Replace(s, "'$2$1'"));
             print.it("//Replace with callback:");
            print.it(x.Replace(s, o => o.Value.Upper()));
             print.it("//Replace with callback and ExpandReplacement:");
            print.it(x.Replace(s, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             print.it("//Split:");
            print.it(new regexp(@" *, *").Split(s));
            ]]></code>
             Examples with <b>String</b> extension methods. 
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var rx = @"\b(\w+?)(\d+)\b"; //regular expression
             
             print.it("//RegexIsMatch:");
            print.it(s.RegexIsMatch(rx));
             
             print.it("//RegexMatch:");
            if(s.RegexMatch(rx, out var m)) print.it(m.Value, m[1].Value, m[2].Value);
             
             print.it("//RegexMatch, get only string:");
            if(s.RegexMatch(rx, 0, out var s0)) print.it(s0);
             print.it("//RegexMatch, get only string of group 1:");
            if(s.RegexMatch(rx, 1, out var s1)) print.it(s1);
             
             print.it("//RegexFindAll with foreach:");
            foreach(var v in s.RegexFindAll(rx)) print.it(v.Value, v[1].Value, v[2].Value);
             
             print.it("//RegexFindAll with foreach, get only strings:");
            foreach(var v in s.RegexFindAll(rx, 0)) print.it(v);
             print.it("//RegexFindAll with foreach, get only strings of group 2:");
            foreach(var v in s.RegexFindAll(rx, 2)) print.it(v);
             
             print.it("//RegexFindAll, get array:");
            if(s.RegexFindAll(rx, out var am)) foreach(var k in am) print.it(k.Value, k[1].Value, k[2].Value);
             
             print.it("//RegexFindAll, get array of strings:");
            if(s.RegexFindAll(rx, 0, out var av)) print.it(av);
             print.it("//RegexFindAll, get array of group 2 strings:");
            if(s.RegexFindAll(rx, 2, out var ag)) print.it(ag);
             
             print.it("//RegexReplace:");
            print.it(s.RegexReplace(rx, "'$2$1'"));
             
             print.it("//RegexReplace with callback:");
            print.it(s.RegexReplace(rx, o => o.Value.Upper()));
             print.it("//RegexReplace with callback and ExpandReplacement:");
            print.it(s.RegexReplace(rx, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             print.it("//RegexReplace, get replacement count:");
            if(0 != s.RegexReplace(rx, "'$2$1'", out var s2)) print.it(s2);
             
             print.it("//RegexReplace with callback, get replacement count:");
            if(0 != s.RegexReplace(rx, o => o.Value.Upper(), out var s3)) print.it(s3);
             
             print.it("//RegexSplit:");
            print.it(s.RegexSplit(@" *, *"));
            ]]></code></example>
        </member>
        <member name="M:Au.regexp.#ctor(System.String,Au.Types.RXFlags)">
            <summary>
            Compiles regular expression string.
            </summary>
            <param name="rx">Regular expression. Cannot be null.</param>
            <param name="flags">
            Options.
            Default 0. Flag UTF is implicitly added if <i>rx</i> contains non-ASCII characters and there is no flag NEVER_UTF.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason (unlikely).</exception>
            <remarks>
            Calls PCRE API function <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile</see>.
            
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            
            Examples in class help: <see cref="T:Au.regexp"/>.
            </remarks>
        </member>
        <member name="M:Au.regexp.Finalize">
            
        </member>
        <member name="P:Au.regexp.Callout">
            <summary>
            Sets callout callback function.
            </summary>
            <value>Callback delegate (eg lambda) or null.</value>
            <remarks>
            Callouts can be used to: 1. Track the matching progress. 2. Get all instances of a group that can match multiple times. 3. Evaluate and reject some matches or match parts. 4. Etc.
            The callback function is called by <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.regexp.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.regexp.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.regexp.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and similar functions, when they reach callout points in regular expression. To insert callout points use (?C), (?C1), (?C2), (?C'name') etc or pass flag AUTO_CALLOUT to the constructor.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            See also: <see href="https://www.rexegg.com/pcre-callouts.html"/>
            </remarks>
            <example>
            Track the matching progress.
            <code><![CDATA[
            var s = "text <a href='url'>link</a> text";
            var rx = @"(?C1)<a (?C2)href='.+?'>(?C3)[^<]*(?C4)</a>";
            var x = new regexp(rx);
            x.Callout = o => { print.it(o.callout_number, o.current_position, s.Substring(o.start_match, o.current_position), rx.Substring(o.pattern_position, o.next_item_length)); };
            print.it(x.IsMatch(s));
            ]]></code>
            Track the matching progress with flag AUTO_CALLOUT.
            <code><![CDATA[
            var s = "one 'two' three";
            var rx = @"'(.+?)'";
            var x = new regexp(rx, RXFlags.AUTO_CALLOUT);
            x.Callout = o => print.it(o.current_position, o.pattern_position, rx.Substring(o.pattern_position, o.next_item_length));
            print.it(x.IsMatch(s));
            ]]></code>
            Get all instances of a group that can match multiple times.
            <code><![CDATA[
            var s = "BEGIN 111 2222 333 END";
            var x = new regexp(@"^(\w+) (?:(\d+) (?C1))+(\w+)$");
            var a = new List<string>();
            x.Callout = o => a.Add(o.LastGroupValue);
            if(!x.Match(s, out var m)) { print.it("no match"); return; }
            print.it(m[1]);
            print.it(a); //all numbers. m[2] contains only the last number.
            print.it(m[3]);
            ]]></code>
            Evaluate and reject some matches or match parts. This code rejects matches longer than 5.
            <code><![CDATA[
            var s = "one 123-5 two 12-456 three 1-34 four";
            var x = new regexp(@"\b\d+-\d+\b(?C1)");
            x.Callout = o => { int len = o.current_position - o.start_match; /*print.it(len);*/ if(len > 5) o.Result = 1; };
            print.it(x.FindAllS(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.GetGroupNumberOf(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Multiple groups have this name.</exception>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String)"/>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Au.regexp.GetMaxGroupNumber">
            <summary>
            Returns the highest capture group number in the regular expression. If <c>(?|</c> not used, this is also the total count of capture groups.
            </summary>
        </member>
        <member name="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="range">
            Start and end offsets in the subject string. If null (default), uses whole string.
            Examples: <c>i..j</c> (from i to j), <c>i..</c> (from i to the end), <c>..j</c> (from 0 to j).
            The subject part before the start index is not ignored if regular expression starts with a lookbehind assertion or anchor, eg <c>^</c> or <c>\b</c> or <c>(?&lt;=...)</c>. Instead of <c>^</c> you can use <c>\G</c>. More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>, chapter "The string to be matched by pcre2_match()".
            The subject part after the end index is always ignored.
            </param>
            <param name="matchFlags">Options.
            The same options also can be set in <b>regexp</b> constructor's <i>flags</i>. Constructor's flags and <i>matchFlags</i> are added, which means that <i>matchFlags</i> cannot unset flags set by constructor.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            print.it(x.IsMatch(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info. Read more in Remarks.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            If full match, returns true, and <i>result</i> contains the match and all groups that exist in the regular expressions.
            If partial match, returns true, and <i>result</i> contains the match without groups. Partial match is possible if used a PARTIAL_ flag.
            If no match, returns false, and <i>result</i> normally is null. But if a mark is available, <i>result</i> is an object with two valid properties - <see cref="P:Au.Types.RXMatch.Exists"/> (false) and <see cref="P:Au.Types.RXMatch.Mark"/>; other properties have undefined values or throw exception.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(x.Match(s, out var m)) print.it(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets whole match or some group, as <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            If full match, returns true, and <i>result</i> contains the match or the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <i>group</i> should be 0.
            If no match, returns false, and <i>result</i> is empty.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(x.MatchG(s, out var g)) print.it(g.Value, g.Start);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.MatchS(System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets whole match or some group, as string.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives the match value.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.regexp.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and <see cref="M:Au.regexp.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            If full match, returns true, and <i>result</i> contains the value of the match or of the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <i>group</i> should be 0.
            If no match, returns false, and <i>result</i> is null.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(x.MatchS(s, out var v)) print.it(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            foreach(var m in x.FindAll(s)) print.it(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAll(System.String,Au.Types.RXMatch[]@,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(!x.FindAll(s, out var a)) { print.it("not found"); return; }
            foreach(var m in a) print.it(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAllG(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new regexp(@"\b\w+\b");
            foreach(var g in x.FindAllG(s)) print.it(g.Start, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new regexp(@"\b\w+\b");
            if(!x.FindAllG(s, out var a)) { print.it("not found"); return; }
            foreach(var g in a) print.it(g.Start, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAllS(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;string&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new regexp(@"\b\w+\b");
            foreach(var v in x.FindAllS(s)) print.it(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.FindAllS(System.String,System.String[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of strings.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.regexp.GetGroupNumberOf(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new regexp(@"\b\w+\b");
            if(!x.FindAllS(s, out var a)) { print.it("not found"); return; }
            foreach(var v in a) print.it(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} etc with the return value of a function registered with <see cref="M:Au.regexp.addReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.Int32,System.String,System.String})"/>.
            </param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, "'$2$1'");
            print.it(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Replace(System.String,System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} etc with the return value of a function registered with <see cref="M:Au.regexp.addReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.Int32,System.String,System.String})"/>.
            </param>
            <param name="result">The result string. Can be <i>s</i>.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, "'$2$1'", out s)) print.it("not found");
            else print.it(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, o => o.Value.Upper());
            print.it(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="result">The result string. Can be <i>s</i>.</param>
            <param name="maxCount">Maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">
            - Invalid $replacement.
            - Used a PARTIAL_ flag.
            - The regular expression contains <c>(?=...\K)</c>.
            </exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new regexp(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, o => o.Value.Upper(), out s)) print.it("not found");
            else print.it(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.ExpandReplacement_(Au.Types.RXMatch,System.String,System.Text.StringBuilder)">
            <summary>
            Used by _ReplaceAll and RXMatch.ExpandReplacement.
            Fully supports .NET regular expression substitution syntax. Also: replaces $* with the name of the last encountered mark; replaces ${+func} etc with the return value of a function registered with <see cref="M:Au.regexp.addReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.Int32,System.String,System.String})"/>.
            </summary>
        </member>
        <member name="M:Au.regexp.addReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.Int32,System.String,System.String})">
            <summary>
            Adds or replaces a function that is called when a regular expression replacement string contains ${+name} or ${+name(g)} or ${+name(g, v)}, where g is group number or name and v is any string.
            </summary>
            <param name="name">A string used to identify the function. Can contain any characters except '}', '(' and ')'.</param>
            <param name="replFunc">
            Callback function. Called for each found match. Returns the replacement.
            Parameters:
            - current match.
            - group number g, if replacement is like ${+name(g)} or ${+name(g, v)}; else 0.
            - string v, if replacement is like ${+name(g, v)}; else null.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <remarks>
            Useful when there is no way to use <b>Replace</b> overloads with a <i>replFunc</i> parameter. For example in Find/Replace UI.
            </remarks>
            <example>
            Create new script in editor and add this code. In Properties set role editorExtension. Run.
            Then in the Find panel in the replacement field you can use <c>${+Lower}</c>, <c>${+Lower(1)}</c>, <c>${+Lower(2)}</c> etc.
            <code><![CDATA[
            regexp.addReplaceFunc("Lower", (m, g, v) => m[g].Value.Lower()); //make lowercase
            ]]></code>
            Another example. Replacement could be like ${+mul(1, 10)}.
            <code><![CDATA[
            regexp.addReplaceFunc("mul", (m, g, v) => (m[g].Value.ToInt() * v.ToInt()).ToString()); //multiply by v
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">Maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <i>s</i> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <i>s</i>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new regexp(@" *, *");
            var a = x.Split(s);
            for(int i = 0; i < a.Length; i++) print.it(i, a[i]);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.SplitG(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns <see cref="T:Au.Types.RXGroup"/> array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">Maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="range">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.regexp.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <i>s</i> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <i>s</i>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new regexp(@" *, *");
            var a = x.SplitG(s);
            foreach(var v in a) print.it(v.Start, v.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.regexp.escapeQE(System.String,System.Boolean)">
            <summary>
            Encloses string in <c>\Q</c> <c>\E</c> if it contains metacharacters <c>\^$.[|()?*+{</c> or if <i>always</i> == true.
            </summary>
            <param name="s"></param>
            <param name="always">Enclose always, even if the string does not contain metacharacters. Should be true if the regular expression in which this string will be used has option "extended", because then whitespace is ignored and # is a special character too.</param>
            <remarks>
            Such enclosed substring in a regular expression is interpreted as a literal string.
            This function also escapes \E, so that it does not end the literal string.
            </remarks>
        </member>
        <member name="T:Au.wildex">
            <summary>
            Parses and compares [](xref:wildcard_expression).
            </summary>
            <remarks>
            Used in 'find' functions. For example in <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> to compare window name, class name and program.
            The 'find' function creates a <b>wildex</b> instance (which parses the wildcard expression), then calls <see cref="M:Au.wildex.Match(System.String)"/> for each item (eg window) to compare some its property text.
            </remarks>
            <example>
            <code><![CDATA[
            //This version does not support wildcard expressions.
            Document Find1(string name, string date)
            {
            	return Documents.Find(x => x.Name.Eqi(name) && x.Date.Eqi(date));
            }
            
            //This version supports wildcard expressions.
            //null-string arguments are not compared.
            Document Find2(string name, string date)
            {
            	wildex n = name, d = date; //null if the string is null
            	return Documents.Find(x => (n == null || n.Match(x.Name)) && (d == null || d.Match(x.Date)));
            }
            
            //Example of calling such function.
            //Find item whose name is "example" (case-insensitive) and date starts with "2017-".
            var item = x.Find2("example", "2017-*");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wildex.#ctor(System.String)">
            <param name="wildcardExpression">
            [Wildcard expression](xref:wildcard_expression).
            Cannot be null (throws exception).
            "" will match "".
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid <c>"**options "</c> or regular expression.</exception>
        </member>
        <member name="M:Au.wildex.op_Implicit(System.String)~Au.wildex">
            <summary>
            Creates new <b>wildex</b> from wildcard expression string.
            If the string is null, returns null.
            </summary>
            <param name="wildcardExpression">[Wildcard expression](xref:wildcard_expression). </param>
            <exception cref="T:System.ArgumentException">Invalid <c>"**options "</c> or regular expression.</exception>
        </member>
        <member name="M:Au.wildex.Match(System.String)">
            <summary>
            Compares a string with the [](xref:wildcard_expression) used to create this <see cref="T:Au.wildex"/>.
            Returns true if they match.
            </summary>
            <param name="s">String. If null, returns false. If "", returns true if it was "" or "*" or a regular expression that matches "".</param>
        </member>
        <member name="P:Au.wildex.Text">
            <summary>
            Gets the wildcard or simple text.
            null if TextType is Regex or Multi.
            </summary>
        </member>
        <member name="P:Au.wildex.RegexPcre">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexPcre (no option r).
            </summary>
        </member>
        <member name="P:Au.wildex.RegexNet">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexNet (no option R).
            </summary>
        </member>
        <member name="P:Au.wildex.MultiArray">
            <summary>
            Array of <b>wildex</b> variables, one for each part in multi-part text.
            null if TextType is not Multi (no option m).
            </summary>
        </member>
        <member name="P:Au.wildex.TextType">
            <summary>
            Gets the type of text (wildcard, regex, etc).
            </summary>
        </member>
        <member name="P:Au.wildex.IgnoreCase">
            <summary>
            Is case-insensitive?
            </summary>
        </member>
        <member name="P:Au.wildex.Not">
            <summary>
            Has option n?
            </summary>
        </member>
        <member name="M:Au.wildex.ToString">
            
        </member>
        <member name="M:Au.wildex.hasWildcardChars(System.String)">
            <summary>
            Returns true if string contains wildcard characters: '*', '?'.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="P:Au.computer.tickCountWithoutSleep">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup, not including the time when the computer sleeps or hibernates.
            To get time with sleep, use <see cref="P:System.Environment.TickCount64"/>.
            </summary>
            <remarks>
            Uses API <msdn>QueryUnbiasedInterruptTime</msdn>.
            Uses the low-resolution system timer. Its period usually is 15.25 ms.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="T:Au.osVersion">
            <summary>
            Provides Windows version info and current process 32/64 bit info.
            </summary>
            <remarks>
            The Windows version properties return true Windows version. If you need version that depends on manifest and debugger, use <see cref="P:System.Environment.OSVersion"/>.
            </remarks>
            <seealso cref="T:System.OperatingSystem"/>
        </member>
        <member name="P:Au.osVersion.winVer">
            <summary>
            Gets classic Windows major+minor version value:
            Win7 (0x601), Win8 (0x602), Win8_1 (0x603), Win10 (0xA00).
            Example: <c>if(osVersion.winVer >= osVersion.win8) ...</c>
            </summary>
        </member>
        <member name="P:Au.osVersion.winBuild">
            <summary>
            Gets Windows build number.
            For example 14393 for Windows 10 version 1607.
            </summary>
        </member>
        <member name="F:Au.osVersion.win7">
            <summary>
            Classic Windows version major+minor value that can be used with <see cref="P:Au.osVersion.winVer"/>.
            Example: <c>if(osVersion.winVer >= osVersion.win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.osVersion.win8">
            <summary>
            Classic Windows version major+minor value that can be used with <see cref="P:Au.osVersion.winVer"/>.
            Example: <c>if(osVersion.winVer >= osVersion.win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.osVersion.win8_1">
            <summary>
            Classic Windows version major+minor value that can be used with <see cref="P:Au.osVersion.winVer"/>.
            Example: <c>if(osVersion.winVer >= osVersion.win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.osVersion.win10">
            <summary>
            Classic Windows version major+minor value that can be used with <see cref="P:Au.osVersion.winVer"/>.
            Example: <c>if(osVersion.winVer >= osVersion.win8) ...</c>
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin8">
            <summary>
            true if Windows 8.0 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin8_1">
            <summary>
            true if Windows 8.1 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10">
            <summary>
            true if Windows 10 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1607">
            <summary>
            true if Windows 10 version 1607 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1703">
            <summary>
            true if Windows 10 version 1703 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1709">
            <summary>
            true if Windows 10 version 1709 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1803">
            <summary>
            true if Windows 10 version 1803 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1809">
            <summary>
            true if Windows 10 version 1809 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1903">
            <summary>
            true if Windows 10 version 1903 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_1909">
            <summary>
            true if Windows 10 version 1909 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.minWin10_2004">
            <summary>
            true if Windows 10 version 2004 or later.
            </summary>
        </member>
        <member name="P:Au.osVersion.is32BitProcess">
            <summary>
            true if this process is 32-bit, false if 64-bit.
            The same as <c>sizeof(nint) == 4</c>.
            </summary>
        </member>
        <member name="P:Au.osVersion.is32BitOS">
            <summary>
            true if Windows is 32-bit, false if 64-bit.
            </summary>
        </member>
        <member name="P:Au.osVersion.is32BitProcessAnd64BitOS">
            <summary>
            Returns true if this process is a 32-bit process running on 64-bit Windows. Also known as WOW64 process.
            </summary>
        </member>
        <member name="T:Au.process">
            <summary>
            Contains static functions to work with processes (find, enumerate, get basic info, etc), current process (get info), current thread (get info).
            </summary>
            <seealso cref="T:Au.run"/>
            <seealso cref="T:Au.script"/>
            <seealso cref="T:System.Diagnostics.Process"/>
        </member>
        <member name="M:Au.process.getName(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe") or full path.
            Returns null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <param name="fullPath">
            Get full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="noSlowAPI">When the fast API QueryFullProcessImageName fails, don't try to use another much slower API WTSEnumerateProcesses. Not used if <i>fullPath</i> is true.</param>
            <remarks>
            This function is much slower than getting window name or class name.
            </remarks>
            <seealso cref="P:Au.wnd.ProgramName"/>
            <seealso cref="P:Au.wnd.ProgramPath"/>
            <seealso cref="P:Au.wnd.ProcessId"/>
        </member>
        <member name="M:Au.process.GetNameCached_(Au.wnd,System.Int32,System.Boolean)">
            <summary>
            Same as GetName, but faster when called several times for same window, like <c>if(w.ProgramName=="A" || w.ProgramName=="B")</c>.
            </summary>
        </member>
        <member name="M:Au.process.ProcessInfo_.GetName(System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe"). Not full path.
            If contains looks like a DOS path and !cannotOpen, tries to unexpand DOS path.
            Don't call multiple times, because always converts from raw char*.
            </summary>
        </member>
        <member name="M:Au.process.allProcesses(System.Boolean)">
            <summary>
            Gets basic info of all processes: name, id, session id.
            </summary>
            <param name="ofThisSession">Get processes only of this user session (skip services etc).</param>
            <exception cref="T:Au.Types.AuException">Failed. Unlikely.</exception>
        </member>
        <member name="M:Au.process.getProcessIds(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets process ids of all processes of the specified program.
            Returns array containing 0 or more elements.
            </summary>
            <param name="processName">
            Process executable file name, like "notepad.exe".
            String format: [](xref:wildcard_expression).
            </param>
            <param name="fullPath">
            <i>processName</i> is full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="ofThisSession">Get processes only of this user session.</param>
            <exception cref="T:System.ArgumentException">
            - <i>processName</i> is "" or null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
        </member>
        <member name="M:Au.process.getProcessId(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets process id of the first found process of the specified program.
            Returns 0 if not found.
            More info: <see cref="M:Au.process.getProcessIds(System.String,System.Boolean,System.Boolean)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Au.process.getVersionInfo(System.Int32)">
            <summary>
            Gets version info of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="M:Au.process.getDescription(System.Int32)">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <remarks>
            Calls <see cref="M:Au.process.getVersionInfo(System.Int32)"/> and <see cref="P:System.Diagnostics.FileVersionInfo.FileDescription"/>.
            </remarks>
        </member>
        <member name="M:Au.process.processIdFromHandle(System.IntPtr)">
            <summary>
            Gets process id from handle (API <msdn>GetProcessId</msdn>).
            Returns 0 if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="processHandle">Process handle.</param>
        </member>
        <member name="M:Au.process.terminate(System.Int32,System.Int32)">
            <summary>
            Terminates (ends) the specified process.
            Returns false if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="processId">Process id.</param>
            <param name="exitCode">Process exit code.</param>
            <remarks>
            This function does not try to end process "softly" (close main window). Unsaved data will be lost.
            Alternatives: run taskkill.exe or pskill.exe (download). See <see cref="M:Au.run.console(System.String,System.String,System.String,System.Text.Encoding)"/>. More info on the internet.
            </remarks>
        </member>
        <member name="M:Au.process.terminate(System.String,System.Boolean,System.Int32)">
            <summary>
            Terminates (ends) all processes of the specified program or programs.
            Returns the number of successfully terminated processes.
            </summary>
            <param name="processName">
            Process executable file name, like "notepad.exe".
            String format: [](xref:wildcard_expression).
            </param>
            <param name="allSessions">Processes of any user session. If false (default), only processes of this user session.</param>
            <param name="exitCode">Process exit code.</param>
            <exception cref="T:System.ArgumentException">
            - <i>processName</i> is "" or null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
        </member>
        <member name="M:Au.process.suspend(System.Boolean,System.Int32)">
            <summary>
            Suspends or resumes the specified process.
            Returns false if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="suspend">true suspend, false resume.</param>
            <param name="processId">Process id.</param>
            <remarks>
            If suspended multiple times, must be resumed the same number of times.
            </remarks>
        </member>
        <member name="M:Au.process.suspend(System.Boolean,System.String,System.Boolean)">
            <summary>
            Suspends or resumes all processes of the specified program or programs.
            Returns the number of successfully suspended/resumed processes.
            </summary>
            <param name="suspend">true suspend, false resume.</param>
            <param name="processName">
            Process executable file name, like "notepad.exe".
            String format: [](xref:wildcard_expression).
            </param>
            <param name="allSessions">Processes of any user session. If false (default), only processes of this user session.</param>
            <exception cref="T:System.ArgumentException">
            - <i>processName</i> is "" or null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
            <remarks>
            If suspended multiple times, must be resumed the same number of times.
            </remarks>
        </member>
        <member name="M:Au.process.getSessionId(System.Int32)">
            <summary>
            Gets user session id of a process (API <msdn>ProcessIdToSessionId</msdn>).
            Returns -1 if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="P:Au.process.thisProcessId">
            <summary>
            Gets current process id.
            See API <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.process.thisProcessHandle">
            <summary>
            Returns current process handle.
            See API <msdn>GetCurrentProcess</msdn>.
            Don't need to close the handle.
            </summary>
        </member>
        <member name="P:Au.process.thisExePath">
            <summary>
            Gets full path of the program file of this process (API <msdn>GetModuleFileName</msdn>).
            </summary>
        </member>
        <member name="P:Au.process.thisExeName">
            <summary>
            Gets file name of the program file of this process, like "name.exe".
            </summary>
        </member>
        <member name="P:Au.process.thisProcessSessionId">
            <summary>
            Gets user session id of this process.
            </summary>
        </member>
        <member name="P:Au.process.thisProcessCultureIsInvariant">
            <summary>
            Gets or sets whether <see cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentCulture"/> and <see cref="P:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture"/> are <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <remarks>
            If your app doesn't want to use current culture (default in .NET apps), it can set these properties = <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> or set this property = true.
            It prevents potential bugs when app/script/components don't specify invariant culture in string functions and 'number to/from string' functions.
            Also, there is a bug in 'number to/from string' functions in some .NET versions with some cultures: they use wrong minus sign, not ASII '-' which is specified in Control Panel.
            The default compiler sets this property = true; as well as <see cref="M:Au.script.setup(System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Boolean,Au.Types.UExcept,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.process.ThisProcessMinimizePhysicalMemory_(System.Int32)">
            <summary>
            After afterMS milliseconds invokes GC and calls API SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="E:Au.process.thisProcessExit">
            <summary>
            Before this process exits, either normally or on unhandled exception.
            </summary>
            <remarks>
            The event handler is called on <see cref="E:System.AppDomain.ProcessExit"/> (then the parameter is null) and <see cref="E:System.AppDomain.UnhandledException"/> (then the parameter is <b>Exception</b>).
            </remarks>
        </member>
        <member name="P:Au.process.thisThreadId">
            <summary>
            Gets native thread id of this thread (API <msdn>GetCurrentThreadId</msdn>).
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
            <seealso cref="P:Au.wnd.ThreadId"/>
        </member>
        <member name="P:Au.process.thisThreadHandle">
            <summary>
            Returns native thread handle of this thread (API <msdn>GetCurrentThread</msdn>).
            </summary>
        </member>
        <member name="M:Au.process.thisThreadHasMessageLoop(System.Boolean@)">
            <summary>
            Returns true if this thread has a .NET message loop (winforms or WPF).
            </summary>
            <param name="isWPF">Has WPF message loop and no winforms message loop.</param>
            <seealso cref="M:Au.wnd.getwnd.threadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.process.thisThreadHasMessageLoop">
            
        </member>
        <member name="T:Au.run">
            <summary>
            Contains static functions to execute or open programs, files, folders, web pages, etc, start new threads.
            </summary>
        </member>
        <member name="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)">
            <summary>
            Runs/opens a program, document, directory (folder), URL, new email, Control Panel item etc.
            The returned <see cref="T:Au.Types.RResult"/> variable contains some process info - process id etc.
            </summary>
            <param name="file">
            Examples:
            - <c>@"C:\file.txt"</c>
            - <c>folders.Documents</c>
            - <c>folders.System + "notepad.exe"</c>
            - <c>@"%folders.System%\notepad.exe"</c>
            - <c>@"%TMP%\file.txt"</c>
            - <c>"notepad.exe"</c>
            - <c>@"..\folder\x.exe"</c>
            - <c>"http://a.b.c/d"</c>
            - <c>"file:///path"</c>
            - <c>"mailto:a@b.c"</c>
            - <c>":: ITEMIDLIST"</c>
            - <c>@"::{CLSID}"</c>
            - <c>@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"</c>.
            More info in Remarks.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with <c>"%"</c> or <c>"\"%"</c>.
            </param>
            <param name="flags"></param>
            <param name="dirEtc">
            Allows to specify more parameters: current directory, verb, etc.
            If string, it sets initial current directory for the new process. If "", gets it from <i>file</i>. More info: <see cref="F:Au.Types.ROptions.CurrentDirectory"/>.
            </param>
            <exception cref="T:System.ArgumentException">Used both <b>ROptions.Verb</b> and <b>RFlags.Admin</b> and this process isn't admin.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, the file does not exist.</exception>
            <remarks>
            It works like when you double-click a file icon. It may start new process or not. For example it may just activate window if the program is already running.
            Uses API <msdn>ShellExecuteEx</msdn>.
            Similar to <see cref="M:System.Diagnostics.Process.Start(System.String,System.String)"/>.
            
            The <i>file</i> parameter can be:
            - Full path of a file or directory. Examples: <c>@"C:\file.txt"</c>, <c>folders.Documents</c>, <c>folders.System + "notepad.exe"</c>, <c>@"%folders.System%\notepad.exe"</c>.
            - Filename of a file or directory, like <c>"notepad.exe"</c>. The function calls <see cref="M:Au.filesystem.searchPath(System.String,System.String[])"/>.
            - Path relative to <see cref="P:Au.folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            - URL. Examples: <c>"http://a.b.c/d"</c>, <c>"file:///path"</c>.
            - Email, like <c>"mailto:a@b.c"</c>. Subject, body etc also can be specified, and Google knows how.
            - Shell object's ITEMIDLIST like <c>":: ITEMIDLIST"</c>. See <see cref="M:Au.Types.Pidl.ToHexString"/>, <see cref="T:Au.folders.shell"/>. Can be used to open virtual folders and items like Control Panel.
            - Shell object's parsing name, like <c>@"::{CLSID}"</c>. See <see cref="M:Au.Types.Pidl.ToShellString(Au.Types.SIGDN,System.Boolean)"/>. Can be used to open virtual folders and items like Control Panel.
            - To run a Windows Store App, use <c>@"shell:AppsFolder\WinStoreAppId"</c> format. Examples: <c>@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"</c>, <c>@"shell:AppsFolder\windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel"</c>. To discover the string use <see cref="M:Au.wnd.more.getWindowsStoreAppId(Au.wnd,System.Boolean,System.Boolean)"/> or Google.
            
            Supports environment variables, like <c>@"%TMP%\file.txt"</c>. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </remarks>
            <seealso cref="M:Au.wnd.findOrRun(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains,System.Action,System.Double,System.Boolean)"/>
            <example>
            Run notepad and wait for its window.
            <code><![CDATA[
            run.it("notepad.exe");
            wnd w = wnd.wait(10, true, "*- Notepad", "Notepad");
            ]]></code>
            Run notepad or activate its window.
            <code><![CDATA[
            wnd w = wnd.findOrRun("*- Notepad", run: () => run.it("notepad.exe"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.run.itSafe(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)">
            <summary>
            Calls <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/> and handles exceptions. All parameters are the same.
            If <b>Run</b> throws exception, writes it to the output as warning and returns null.
            </summary>
            <remarks>
            This is useful when you don't care whether <b>Run</b> succeeded and don't want to use try/catch.
            Handles only exception of type <see cref="T:Au.Types.AuException"/>. It is thrown when fails, usually when the file does not exist.
            </remarks>
            <seealso cref="M:Au.print.warning(System.String,System.Int32,System.String)"/>
            <seealso cref="M:Au.Types.OWarnings.Disable(System.String[])"/>
            <seealso cref="M:Au.wnd.findOrRun(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains,System.Action,System.Double,System.Boolean)"/>
        </member>
        <member name="M:Au.run.console(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            This overload writes text lines to the output in real time.
            </summary>
            <param name="exe">
            Path or name of an .exe or .bat file. Can be:
            - Full path. Examples: <c>@"C:\folder\x.exe"</c>, <c>folders.System + "x.exe"</c>, <c>@"%folders.System%\x.exe"</c>.
            - Filename, like <c>"x.exe"</c>. This function calls <see cref="M:Au.filesystem.searchPath(System.String,System.String[])"/>.
            - Path relative to <see cref="P:Au.folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\folder\x.exe"</c>.
            
            Supports environment variables, like <c>@"%TMP%\x.bat"</c>. See <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
            <param name="args">null or command line arguments.</param>
            <param name="curDir">
            Initial current directory of the new process.
            - If null, uses <c>Directory.GetCurrentDirectory()</c>.
            - Else if "", calls <c>pathname.getDirectory(exe)</c>.
            - Else calls <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>.
            </param>
            <param name="encoding">
            Console's text encoding.
            If null (default), uses the default console text encoding (API <msdn>GetOEMCP</msdn>); it is not Unicode. Programs that display Unicode text use <see cref="P:System.Text.Encoding.UTF8"/>.
            </param>
            <returns>The process exit code. Usually a non-0 value means error.</returns>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
            <remarks>
            The console window is hidden. The text that would be displayed in it is redirected to this function.
            
            Console programs have two output text streams - standard output and standard error. This function gets both.
            Alternatively use <see cref="M:System.Diagnostics.Process.Start"/>. It gets the output and error streams separately, and some lines may be received in incorrect order in time.
            </remarks>
            <example>
            <code><![CDATA[
            string v = "example";
            int r1 = run.console(@"Q:\Test\console1.exe", $@"/an ""{v}"" /etc");
            
            int r2 = run.console(s => print.it(s), @"Q:\Test\console2.exe");
            
            int r3 = run.console(out var text, @"Q:\Test\console3.exe", encoding: Encoding.UTF8);
            print.it(text);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.run.console(System.Action{System.String},System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            This overload uses a callback function that receives text lines in real time.
            </summary>
            <param name="output">A callback function that receives the output text. It receives single full line at a time, without line break characters.</param>
            <param name="exe"></param>
            <param name="args"></param>
            <param name="curDir"></param>
            <param name="encoding"></param>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
        </member>
        <member name="M:Au.run.console(System.String@,System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text when it ends.
            </summary>
            <param name="output">A variable that receives the output text.</param>
            <param name="exe"></param>
            <param name="args"></param>
            <param name="curDir"></param>
            <param name="encoding"></param>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
        </member>
        <member name="M:Au.run.selectInExplorer(System.String)">
            <summary>
            Opens parent folder in Explorer and selects the file.
            Returns null if fails, for example if the file does not exist.
            </summary>
            <param name="path">
            Full path of a file or directory or other shell object.
            Supports <c>@"%environmentVariable%\..."</c> (see <see cref="M:Au.pathname.expand(System.String,System.Nullable{System.Boolean})"/>) and <c>"::..."</c> (see <see cref="M:Au.Types.Pidl.ToHexString"/>).
            </param>
        </member>
        <member name="M:Au.run.thread(System.Action,System.Boolean,System.Boolean)">
            <summary>
            Starts new thread: creates new <see cref="T:System.Threading.Thread"/> object, sets some properties and calls <see cref="M:System.Threading.Thread.Start"/>.
            Returns the <b>Thread</b> variable.
            </summary>
            <param name="threadProc">Thread procedure. Parameter <i>start</i> of <b>Thread</b> constructor.</param>
            <param name="background">
            If true (default), sets <see cref="P:System.Threading.Thread.IsBackground"/> = true.
            The process ends when the main thread and all foreground threads end; background threads then are terminated.
            </param>
            <param name="sta">If true (default), sets <see cref="F:System.Threading.ApartmentState.STA"/>.</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="T:Au.uacInfo">
            <summary>
            Holds an access token (security info) of a process and provides various security info, eg [](xref:uac) integrity level.
            </summary>
        </member>
        <member name="M:Au.uacInfo.Finalize">
            
        </member>
        <member name="M:Au.uacInfo.Dispose">
            
        </member>
        <member name="P:Au.uacInfo.UnsafeTokenHandle">
            <summary>
            The access token handle.
            </summary>
            <remarks>
            The handle is managed by this variable and will be closed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.uacInfo.Failed">
            <summary>
            Returns true if the last called property function failed.
            Normally it should never fail. Only <see cref="M:Au.uacInfo.ofProcess(System.Int32)"/> can fail (then it returns null).
            </summary>
        </member>
        <member name="P:Au.uacInfo.Elevation">
            <summary>
            Gets the [](xref:uac) elevation type of the process.
            </summary>
        </member>
        <member name="P:Au.uacInfo.IsUIAccess">
            <summary>
            Returns true if the process has [](xref:uac) uiAccess property.
            A uiAccess process can access/automate all windows of processes running in the same user session.
            </summary>
            <remarks>
            Most processes don't have this property. They cannot access/automate windows of higher integrity level (High, System, uiAccess) processes and Windows 8 store apps. For example, cannot send keys and Windows messages.
            Note: High IL (admin) processes also can have this property, therefore <c>IsUIAccess</c> is not the same as <c>IntegrityLevel==IL.UIAccess</c> (<see cref="P:Au.uacInfo.IntegrityLevel"/> returns <b>UIAccess</b> only for Medium+uiAccess processes; for High+uiAccess processes it returns <b>High</b>). Some Windows API work slightly differently with uiAccess and non-uiAccess admin processes.
            This property is rarely useful. Instead use other properties of this class.
            </remarks>
        </member>
        <member name="P:Au.uacInfo.IntegrityLevel">
            <summary>
            Gets the [](xref:uac) integrity level (IL) of the process.
            </summary>
            <remarks>
            IL from lowest to highest value: Untrusted, Low, Medium, UIAccess, High, System, Protected, Unknown.
            The IL enum member values can be used like <c>if(x.IntegrityLevel > IL.Medium) ...</c> .
            If UAC is turned off, most non-service processes on administrator account have High IL; on non-administrator - Medium.
            </remarks>
        </member>
        <member name="M:Au.uacInfo.ofProcess(System.Int32)">
            <summary>
            Opens process access token and creates/returns new <see cref="T:Au.uacInfo"/> variable that holds it. Then you can use its properties.
            Returns null if failed. For example fails for services and some other processes if current process is not administrator.
            </summary>
            <param name="processId">Process id. If you have a window, use <see cref="P:Au.wnd.ProcessId"/>.</param>
            <remarks>
            To get <b>uacInfo</b> of this process, use <see cref="P:Au.uacInfo.ofThisProcess"/>.
            </remarks>
        </member>
        <member name="P:Au.uacInfo.ofThisProcess">
            <summary>
            Gets <see cref="T:Au.uacInfo"/> variable for this process.
            </summary>
        </member>
        <member name="P:Au.uacInfo.isAdmin">
            <summary>
            Returns true if this process is running as administrator.
            </summary>
        </member>
        <member name="P:Au.uacInfo.isUacDisabled">
            <summary>
            Returns true if [](xref:uac) is disabled (turned off) completely (not just disabled UAC consent screeen/dialog).
            </summary>
        </member>
        <member name="T:Au.script">
            <summary>
            Contains static functions to work with script tasks: run, get properties.
            A script task is a running script, except if role editorExtension. Each script task is a separate process.
            </summary>
            <seealso cref="T:Au.process"/>
        </member>
        <member name="P:Au.script.name">
            <summary>
            In a process of a script with role miniProgram (defaut) returns script file name without extension.
            In other processes returns <see cref="P:System.AppDomain.FriendlyName"/>, like "MainAssemblyName".
            </summary>
        </member>
        <member name="P:Au.script.role">
            <summary>
            If this script task has been started from editor, returns script's role property. Else returns <b>ExeProgram</b>.
            </summary>
        </member>
        <member name="M:Au.script.run(System.String,System.String[])">
            <summary>
            Starts executing a script. Does not wait.
            </summary>
            <returns>
            Native process id of the task process.
            Returns 0 if task start is deferred because a task is running (see meta option ifRunning).
            Returns 0 if role editorExtension; then waits until the task ends.
            Returns -1 if failed, for example if the script contains errors or cannot run because a task is running.
            </returns>
            <param name="script">Script name like "Script5.cs", or path like @"\Folder\Script5.cs".</param>
            <param name="args">Command line arguments. In script it will be variable <i>args</i>. Should not contain '\0' characters.</param>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
        </member>
        <member name="M:Au.script.runWait(System.String,System.String[])">
            <summary>
            Starts executing a script and waits until the task ends.
            More info: <see cref="M:Au.script.run(System.String,System.String[])"/>.
            </summary>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="M:Au.script.runWait(System.String@,System.String,System.String[])">
            <summary>
            Starts executing a script, waits until the task ends and then gets <see cref="M:Au.script.writeResult(System.String)"/> text.
            More info: <see cref="M:Au.script.run(System.String,System.String[])"/>.
            </summary>
            <param name="results">Receives <see cref="M:Au.script.writeResult(System.String)"/> text.</param>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="M:Au.script.runWait(System.Action{System.String},System.String,System.String[])">
            <summary>
            Starts executing a script, waits until the task ends and gets <see cref="M:Au.script.writeResult(System.String)"/> text in real time.
            More info: <see cref="M:Au.script.run(System.String,System.String[])"/>.
            </summary>
            <param name="results">Receives <see cref="M:Au.script.writeResult(System.String)"/> output whenever the task calls it.</param>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="P:Au.script.WndMsg_">
            <summary>
            Finds editor's message-only window used with WM_COPYDATA etc.
            </summary>
        </member>
        <member name="M:Au.script.writeResult(System.String)">
            <summary>
            Writes a string result for the task that called <see cref="M:Au.script.runWait(System.String@,System.String,System.String[])"/> or <see cref="M:Au.script.runWait(System.Action{System.String},System.String,System.String[])"/> to run this task, or for the program that executed "Au.CL.exe" to run this task with command line like "Au.CL.exe **Script5.cs".
            Returns false if this task was not started in such a way. Returns null if failed to write, except when s is null/"".
            </summary>
            <param name="s">A string. This function does not append newline characters.</param>
            <remarks>
            The <b>RunWait</b>(Action) overload can read the string in real time.
            The <b>RunWait</b>(out string) overload gets all strings joined when the task ends.
            The program that executed "Au.CL.exe" to run this task with command line like "Au.CL.exe **Script5.cs" can read the string from the redirected standard output in real time, or the string is written to its console in real time. The string encoding is UTF8; if you use a bat file or cmd.exe and want to get correct Unicode text, execute this before, to change console code page to UTF-8: <c>chcp 65001</c>.
            </remarks>
        </member>
        <member name="M:Au.script.setup(System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Boolean,Au.Types.UExcept,System.String)">
            <summary>
            Adds various useful features to this script task (running script): tray icon, exit on Ctrl+Alt+Delete, etc.
            </summary>
            <param name="trayIcon">Add standard tray icon. See <see cref="M:Au.script.trayIcon(System.Int32,System.Action{Au.trayIcon},System.Action{Au.trayIcon,Au.popupMenu},System.String)"/>.</param>
            <param name="sleepExit">
            End this process when computer is going to sleep or hibernate.
            If null (default), same as runSingle property of the script.
            </param>
            <param name="lockExit">
            End this process when the active desktop has been switched (PC locked, Ctrl+Alt+Delete, screen saver, etc, except UAC consent).
            Then to end this process you can use hotkeys Win+L (lock computer) and Ctrl+Alt+Delete.
            Most mouse, keyboard, clipboard and window functions don't work when other desktop is active. Many of them then throw exception, and the script would end anyway.
            If null (default), same as runSingle property of the script.
            </param>
            <param name="debug">Call <see cref="M:Au.More.DebugTraceListener.Setup(System.Boolean)"/>(usePrint: true).</param>
            <param name="exception">What to do on unhandled exception (event <see cref="E:System.AppDomain.UnhandledException"/>).</param>
            <param name="f_">[](xref:caller_info). Don't use. Or set = null to disable script editing via the tray icon.</param>
            <exception cref="T:System.InvalidOperationException">Already called.</exception>
            <remarks>
            Calling this function is optional. However it should be called if compiling the script with a non-default compiler (eg Visual Studio) if you want the task behave the same (invariant culture, STAThread, unhandled exception action).
            
            Does nothing if role editorExtension.
            </remarks>
        </member>
        <member name="M:Au.script.AppModuleInit_">
            <summary>
            If role miniProgram or exeProgram, default compiler adds module initializer that calls this. If using other compiler, called from <b>Setup</b>.
            </summary>
        </member>
        <member name="P:Au.script.isRunSingle">
            <summary>
            Returns true if runSingle true.
            </summary>
            <remarks>
            If script properties contain runSingle true, the default compiler adds <see cref="T:Au.Types.RunSingleAttribute"/> to the main assembly. Then at run time this property returns true.
            </remarks>
        </member>
        <member name="P:Au.script.isDebug">
            <summary>
            Returns true if the build configuration of the main assembly is Debug. Returns false if Release (optimize true).
            </summary>
        </member>
        <member name="M:Au.script.trayIcon(System.Int32,System.Action{Au.trayIcon},System.Action{Au.trayIcon,Au.popupMenu},System.String)">
            <summary>
            Adds standard tray icon.
            </summary>
            <param name="delay">Delay, milliseconds.</param>
            <param name="init">Called before showing the tray icon. Can set its properties and event handlers.</param>
            <param name="menu">Called before showing context menu. Can add menu items. Menu item actions must not block messages etc for long time; if need, run in other thread or process (<see cref="M:Au.script.run(System.String,System.String[])"/>).</param>
            <param name="f_">[](xref:caller_info). Don't use. Or set = null to disable script editing via the tray icon.</param>
            <remarks>
            Uses other thread. The <i>init</i> and <i>menu</i> actions run in that thread too. It dispatches messages, therefore they also can set timers (<see cref="T:Au.timerm"/>), create hidden windows, etc. Current thread does not have to dispatch messages.
            
            Does nothing if role editorExtension.
            </remarks>
            <example>
            Shows how to change icon and tooltip.
            <code><![CDATA[
            script.trayIcon(init: t => { t.Icon = icon.stock(StockIcon.HELP); t.Tooltip = "Example"; });
            ]]></code>
            Shows how to add menu items.
            <code><![CDATA[
            script.trayIcon(menu: (t, m) => {
            	m["Example"] = o => { dialog.show("Example"); };
            	m["Run other script"] = o => { script.run("Example"); };
            });
            ]]></code>
            </example>
            <seealso cref="T:Au.trayIcon"/>
        </member>
        <member name="T:Au.script.editor">
            <summary>
            Contains static functions to interact with the script editor, if available.
            </summary>
        </member>
        <member name="P:Au.script.editor.Available">
            <summary>
            Returns true if editor is running.
            </summary>
        </member>
        <member name="M:Au.script.editor.OpenAndGoToLine(System.String,System.Int32)">
            <summary>
            Opens the specified source file (script etc) and sets code editor's current position at the start of the specified line.
            Does nothing if editor isn't running.
            </summary>
            <param name="file">Source file. Can be full path, or relative path in workspace, or file name with ".cs".</param>
            <param name="line">1-based line index. If 0, just opens file.</param>
        </member>
        <member name="M:Au.script.editor.GetCustomIcon(System.String,Au.Types.EGetIcon)">
            <summary>
            Gets custom icon string in specified format.
            Returns null if no custom icon or if editor isn't running.
            </summary>
            <param name="file">File/folder path etc, or icon name. See <see cref="T:Au.Types.EGetIcon"/>.</param>
            <param name="what">The format of input and output strings.</param>
        </member>
        <member name="F:Au.script.editor.IconNameToXaml_">
            <summary>
            Editor sets this. Library uses it to avoid sendmessage.
            </summary>
        </member>
        <member name="T:Au.perf">
            <summary>
            Code execution time measurement with high precision (API <msdn>QueryPerformanceCounter</msdn>).
            Like <see cref="T:System.Diagnostics.Stopwatch"/>, but easier to use.
            </summary>
        </member>
        <member name="P:Au.perf.mcs">
            <summary>
            Gets the number of microseconds elapsed since Windows startup. Uses the high-resolution system timer (API <msdn>QueryPerformanceCounter</msdn>).
            </summary>
            <remarks>
            This function is used to measure time differences with 1 microsecond precision, like <c>var t1=perf.mcs; ... var t2=perf.mcs; var diff=t2-t1;</c>.
            Independent of computer clock time changes.
            MSDN article: <msdn>Acquiring high-resolution time stamps</msdn>.
            </remarks>
            <seealso cref="T:Au.perf"/>
        </member>
        <member name="P:Au.perf.ms">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup. Uses the high-resolution system timer (API <msdn>QueryPerformanceCounter</msdn>).
            </summary>
            <remarks>
            This function is used to measure time differences with 1 ms precision, like <c>var t1=perf.ms; ... var t2=perf.ms; var diff=t2-t1;</c>.
            The return value equals <see cref="P:Au.perf.mcs"/>/1000 but is slightly different than of <see cref="P:System.Environment.TickCount64"/> and most Windows API. Never compare times returned by different functions.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="T:Au.perf.Instance">
            <summary>
            Performs time measurements and stores measurement data.
            </summary>
            <remarks>
            Static functions of <see cref="T:Au.perf"/> class use a single static variable of this type to perform measurements.
            Use a variable of this type instead when you want to have multiple independent measurements. See <see cref="M:Au.perf.local"/>.
            Variables of this type usually are used as local (in single function), but also can be used anywhere (class fields, unmanaged memory).
            This type is a struct (value type), and not small (184 bytes). Don't use it as a function parameter without ref. To share a variable between functions use a field in your class.
            Don't need to dispose variables of this type. The <see cref="M:Au.perf.Instance.Dispose"/> function just calls <see cref="M:Au.perf.Instance.NW(System.Char)"/>.
            </remarks>
        </member>
        <member name="P:Au.perf.Instance.Incremental">
            <summary>See <see cref="P:Au.perf.incremental"/>.</summary>
            <example>
            <code><![CDATA[
            var p1 = new perf.Instance { Incremental = true };
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	p1.First();
            	Thread.Sleep(30); //will make sum ~150000
            	p1.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	p1.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            p1.Write(); //speed:  154317  51060  (205377)
            p1.Incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.perf.Instance.First">
            <summary><see cref="M:Au.perf.first"/></summary>
        </member>
        <member name="M:Au.perf.Instance.Next(System.Char)">
            <summary><see cref="M:Au.perf.next(System.Char)"/></summary>
        </member>
        <member name="M:Au.perf.Instance.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.perf.Instance.Next(System.Char)"/> and <see cref="M:Au.perf.Instance.Write"/>.
            </summary>
            <param name="cMark">A character to add to the results string like "A=150".</param>
        </member>
        <member name="M:Au.perf.Instance.Dispose">
            <summary>
            Calls <see cref="M:Au.perf.Instance.NW(System.Char)"/>, which calls <see cref="M:Au.perf.Instance.Next(System.Char)"/> and <see cref="M:Au.perf.Instance.Write"/>.
            </summary>
            <remarks>
            Don't need to dispose variables of this type. This function just allows to use the 'using' pattern instead of <b>NW</b>. See example.
            </remarks>
            <example>
            <code><![CDATA[
            using(var p1 = perf.local()) { //p1.First();
            	1.ms();
            	p1.Next();
            	1.ms();
            } //p1.NW();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.perf.Instance.Write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.perf.Instance.First"/> and <see cref="M:Au.perf.Instance.Next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.perf.Instance.ToString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.perf.Instance.First"/> and <see cref="M:Au.perf.Instance.Next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.perf.Instance.ToArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.perf.Instance.First"/> and <see cref="M:Au.perf.Instance.Next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.perf.Instance.TimeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.perf.Instance.First"/> and the last <see cref="M:Au.perf.Instance.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="F:Au.perf.s_static">
            <summary>
            This static variable is used by the static functions.
            </summary>
        </member>
        <member name="M:Au.perf.local">
            <summary>
            Creates and returns new <see cref="T:Au.perf.Instance"/> variable and calls its <see cref="M:Au.perf.Instance.First"/>.
            </summary>
        </member>
        <member name="P:Au.perf.incremental">
            <summary>
            If true, times of each new First/Next/Next... measurement are added to previous measurement times.
            Finally you can call <see cref="M:Au.perf.write"/> or <see cref="M:Au.perf.toString"/> to get the sums.
            Usually used to measure code in loops. See example.
            </summary>
            <example>
            <code><![CDATA[
            perf.incremental = true;
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	perf.first();
            	Thread.Sleep(30); //will make sum ~150000
            	perf.next();
            	Thread.Sleep(10); //will make sum ~50000
            	perf.next();
            	Thread.Sleep(100); //not included in the measurement
            }
            perf.write(); //speed:  154317  51060  (205377)
            perf.incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.perf.first">
            <summary>
            Stores current time in the first element of an internal array.
            </summary>
        </member>
        <member name="M:Au.perf.next(System.Char)">
            <summary>
            Stores current time in next element of an internal array.
            </summary>
            <remarks>
            Don't call <b>Next</b> more than 16 times after <b>First</b>, because the array has fixed size.
            </remarks>
            <param name="cMark">A character to mark this time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.perf.nw(System.Char)">
            <summary>
            Calls <see cref="M:Au.perf.next(System.Char)"/> and <see cref="M:Au.perf.write"/>.
            </summary>
            <param name="cMark">A character to add to the results string like "A=150".</param>
        </member>
        <member name="M:Au.perf.write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.perf.first"/> and <see cref="M:Au.perf.next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
            <example>
            <code><![CDATA[
            perf.first(100);
            CODE1;
            perf.next();
            CODE2;
            perf.next();
            perf.write(); //speed:  timeOfCODE1  timeOfCODE2  (totalTime)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.perf.toString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.perf.first"/> and <see cref="M:Au.perf.next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.perf.toArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.perf.first"/> and <see cref="M:Au.perf.next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.perf.timeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.perf.first"/> and the last <see cref="M:Au.perf.next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.perf.cpu(System.Int32)">
            <summary>
            Executes some code in loop for the specified amount of time. It should make CPU to run at full speed.
            </summary>
            <param name="timeMilliseconds">How long to speed up CPU, milliseconds. The minimal required time probably is about 100 ms, but depends on CPU.</param>
            <remarks>
            Code speed measurements often are misleading because of variable CPU speed. Most CPU don't run at full speed when not actively used.
            
            You can make CPU speed constant in Control Panel -> Power Options -> ... Advanced -> Processor power management -> Minimum or maximum power state.
            There are programs that show current CPU speed. For example HWMonitor.
            </remarks>
        </member>
        <member name="P:Au.perf.shared">
            <summary>
            Gets a reference to a <see cref="T:Au.perf.Instance"/> variable in shared memory.
            </summary>
            <remarks>
            The variable can be used by multiple processes, for example to measure process startup time.
            Note: slow first time in process, eg 3 ms. It's because need to JIT-compile functions and open shared memory.
            </remarks>
            <example>
            <code><![CDATA[
            ref var p = ref perf.shared;
            p.First();
            //or
            perf.shared.First();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.timerm">
            <summary>
            Timer that calls callback function in same thread, which must have a message loop.
            </summary>
            <remarks>
            Uses API <msdn>SetTimer</msdn> and <msdn>WM_TIMER</msdn>.
            Works only in threads that have a message loop which retrieves/dispatches posted messages. For example threads with windows (except console).
            Timer action delegates are protected from GC.
            </remarks>
            <example>
            This example sets 3 timers.
            <code><![CDATA[
            timerm.after(500, _ => print.it("after 500 ms"));
            timerm.every(1000, _ => print.it("every 1000 ms"));
            var t3 = new timerm(_ => print.it("after 3000 ms")); t3.After(3000); //the same as timerm.after
            dialog.show("timer"); //shows a window and waits until closed. While waiting, retrieves/dispatches messages in its own message loop.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.timerm.#ctor(System.Action{Au.timerm})">
            <summary>
            Sets callback function.
            </summary>
        </member>
        <member name="P:Au.timerm.Tag">
            <summary>
            Something to attach to this variable.
            </summary>
        </member>
        <member name="P:Au.timerm.IsRunning">
            <summary>
            true if the timer is started and not stopped.
            Note: single-period timer is automatically stopped before calling the callback function.
            </summary>
        </member>
        <member name="M:Au.timerm.After(System.Int32)">
            <summary>
            Starts one-time timer. If already started, resets and changes its period.
            </summary>
            <param name="milliseconds">Time interval after which to call the callback function. The actual minimal interval is 10-20 ms.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as previous <b>Start</b>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The timer will be stopped before calling the callback function. The callback function can start it again.
            If already started, this function must be called in the same thread as when started.
            </remarks>
        </member>
        <member name="M:Au.timerm.Every(System.Int32)">
            <summary>
            Starts periodic timer. If already started, resets and changes its period.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function. The actual minimal period is 10-20 ms.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as previous <b>Start</b>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function can stop the timer or restart with different period.
            If already started, this function must be called in the same thread as when started.
            </remarks>
        </member>
        <member name="M:Au.timerm.Stop">
            <summary>
            Stops the timer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as <b>Start</b>.</exception>
            <remarks>
            The callback function will not be called after this.
            Later you can start the timer again (call <see cref="M:Au.timerm.After(System.Int32)"/> or <see cref="M:Au.timerm.Every(System.Int32)"/>).
            Don't need to call this function for single-period timers. For periodic timers it is optional; the timer stops when the thread ends.
            This function must be called in the same thread as <b>Start</b>.
            </remarks>
        </member>
        <member name="M:Au.timerm.Now">
            <summary>
            Execute the timer action now.
            </summary>
            <remarks>
            Does not change any properties. Just calls the callback function. Does not handle exceptions.
            </remarks>
        </member>
        <member name="M:Au.timerm.after(System.Int32,System.Action{Au.timerm},System.Object)">
            <summary>
            Creates and starts new one-time timer.
            Returns new <see cref="T:Au.timerm"/> object. Usually you don't need it.
            </summary>
            <param name="milliseconds">Time interval after which to call the callback function. The actual minimal interval is 10-20 ms.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.timerm.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The timer will be stopped before calling the callback function. The callback function can start it again.
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or dialog.show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="M:Au.timerm.every(System.Int32,System.Action{Au.timerm},System.Object)">
            <summary>
            Creates and starts new periodic timer.
            Returns new <see cref="T:Au.timerm"/> object that can be used to modify timer properties if you want to do it not in the callback function; usually don't need it.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function. The actual minimal period is 10-20 ms.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.timerm.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function can stop the timer or restart with different period.
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or dialog.show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="T:Au.timert">
            <summary>
            Timer that calls callback function in other thread (thread pool) and can be used in any thread.
            </summary>
            <remarks>
            Uses <see cref="T:System.Threading.Timer"/>.
            Unlike <see cref="T:Au.timerm"/>, the thread that sets the timer does not have to retrieve/dispatch messages.
            The callback function is called in a random thread of the thread pool, therefore its code is not thread-safe (may need to lock etc).
            The actual minimal time interval/period is 10-20 ms, because the system timer period usually is 15.25 ms.
            Timer action delegates are protected from GC.
            </remarks>
            <example>
            This example sets 3 timers.
            <code><![CDATA[
            timert.after(500, _ => print.it("after 500 ms"));
            timert.every(1000, _ => print.it("every 1000 ms"));
            var t3 = new timert(_ => print.it("after 3000 ms")); t3.After(3000); //the same as timert.after
            5.s();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.timert.#ctor(System.Action{Au.timert})">
            <summary>
            Sets callback function.
            </summary>
        </member>
        <member name="M:Au.timert.Stop(System.Boolean)">
            <summary>
            Stops the timer, and by default disposes.
            </summary>
            <param name="canReuse">Just stop but don't dispose. If false (default), can't use the timer again.</param>
        </member>
        <member name="M:Au.timert.After(System.Int64)">
            <summary>
            Starts one-time timer or changes timeout/period.
            </summary>
            <param name="milliseconds">Time interval after which to call the callback function. Valid values are 0 - uint.MaxValue-2. If -1, stops without disposing.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ObjectDisposedException">Called <see cref="M:Au.timert.Stop(System.Boolean)"/> (unless <i>canReuse</i> true).</exception>
            <remarks>
            Calls <see cref="M:System.Threading.Timer.Change(System.Int64,System.Int64)"/>.
            </remarks>
        </member>
        <member name="M:Au.timert.Every(System.Int64,System.Nullable{System.Int64})">
            <summary>
            Starts periodic timer or changes timeout/period.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function. Valid values are 0 - uint.MaxValue-2.</param>
            <param name="firstAfter">null (default) or time interval after which to call the callback function first time. Valid values are 0 - uint.MaxValue-2.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ObjectDisposedException">Called <see cref="M:Au.timert.Stop(System.Boolean)"/> (unless <i>canReuse</i> true).</exception>
            <remarks>
            Calls <see cref="M:System.Threading.Timer.Change(System.Int64,System.Int64)"/>.
            </remarks>
        </member>
        <member name="P:Au.timert.Tag">
            <summary>
            Something to attach to this variable.
            </summary>
        </member>
        <member name="M:Au.timert.after(System.Int64,System.Action{Au.timert},System.Object)">
            <summary>
            Creates and starts new one-time timer.
            </summary>
            <param name="milliseconds">Time interval after which to call the callback function. Valid values are 0 - uint.MaxValue-2. If -1, stops without disposing.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.timert.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Calls <see cref="M:System.Threading.Timer.Change(System.Int64,System.Int64)"/>.
            </remarks>
        </member>
        <member name="M:Au.timert.every(System.Int64,System.Action{Au.timert},System.Object,System.Nullable{System.Int64})">
            <summary>
            Creates and starts new periodic timer.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function. Valid values are 0 - uint.MaxValue-2.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.timert.Tag"/>.</param>
            <param name="firstAfter">null (default) or time interval after which to call the callback function first time. Valid values are 0 - uint.MaxValue-2.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Calls <see cref="M:System.Threading.Timer.Change(System.Int64,System.Int64)"/>.
            </remarks>
        </member>
        <member name="T:Au.wait">
            <summary>
            Contains functions to wait for a condition/variable/etc or simply wait (sleep).
            </summary>
            <remarks>
            Specialized 'wait for' functions are in other classes, for example <see cref="M:Au.wnd.wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            
            All 'wait for' functions have a <i>secondsTimeout</i> parameter. It is the maximal time to wait, seconds. If it is 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, then stops waiting and returns default value of that type (false, etc).
            
            While waiting, most functions by default don't dispatch Windows messages, events, hooks, timers, COM/RPC, etc. For example, if used in a Form/Control event handler, the form would stop responding. Use another thread, for example async/await/Task, like in the example. Or option <see cref="P:Au.Types.OWait.DoEvents"/>.
            </remarks>
            <example>
            <code><![CDATA[
            wait.forCondition(0, () => keys.isScrollLock);
            print.it("ScrollLock now is toggled");
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (_, _) =>
              {
            	  print.it("waiting...");
            	  var result = await Task.Run(() => wait.forCondition(-10, () => keys.isScrollLock));
            	  if(w.Is0) print.it("timeout"); else print.it(result);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.ms(System.Int32)">
            <summary>
            Waits <i>timeMilliseconds</i> milliseconds.
            </summary>
            <param name="timeMilliseconds">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <remarks>
            Calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            Does not process Windows messages and other events, therefore should not be used in threads with windows, timers, hooks, events or COM, unless <i>timeMilliseconds</i> is small. Supports APC.
            If the computer goes to sleep or hibernate during that time, the real time is the specified time + the sleep/hibernate time.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMilliseconds</i> is negative and not Timeout.Infinite (-1).</exception>
            <example>
            <code><![CDATA[
            wait.ms(500);
            500.ms(); //the same (ms is an extension method for int)
            wait.s(0.5); //the same
            0.5.s(); //the same (s is an extension method for double)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.s(System.Int32)">
            <summary>
            Waits <i>timeSeconds</i> seconds.
            The same as <see cref="M:Au.wait.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeSeconds</i> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <example>
            <code><![CDATA[
            wait.ms(5000);
            5000.ms(); //the same
            5.s(); //the same (s is an extension method for int)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.s(System.Double)">
            <summary>
            Waits <i>timeSeconds</i> seconds.
            The same as <see cref="M:Au.wait.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds. The smallest value is 0.001 (1 ms).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeSeconds</i> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <example>
            <code><![CDATA[
            wait.ms(2500);
            2500.ms(); //the same
            2.5.s(); //the same (s is an extension method for double)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.doEvents(System.Int32)">
            <summary>
            Waits <i>timeMS</i> milliseconds. While waiting, retrieves and dispatches Windows messages and other events.
            </summary>
            <param name="timeMS">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <remarks>
            Unlike <see cref="M:Au.wait.ms(System.Int32)"/>, this function retrieves and dispatches Windows messages, calls .NET event handlers, hook procedures, timer functions, COM/RPC, etc. Supports APC.
            This function can be used in threads with windows. However usually there are better ways, for example timer, other thread, async/await/Task. In some places this function does not work as expected, for example in Form/Control mouse event handlers .NET blocks other mouse events.
            Be careful, this function is as dangerous as <see cref="M:System.Windows.Forms.Application.DoEvents"/>.
            Calls API <msdn>MsgWaitForMultipleObjectsEx</msdn> and <see cref="M:Au.wait.doEvents"/>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMS</i> is negative and not Timeout.Infinite.</exception>
            <seealso cref="M:Au.wait.forMessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
            <seealso cref="M:Au.wait.forPostedMessage(System.Double,Au.Types.WPMCallback)"/>
        </member>
        <member name="M:Au.wait.SleepDoEvents_(System.Int32,System.Boolean)">
            <summary>
            Same as <b>doEvents(int)</b> but with parameter <i>noSetPrecision</i>.
            </summary>
        </member>
        <member name="M:Au.wait.doEvents">
            <summary>
            Retrieves and dispatches events and Windows messages from the message queue of this thread.
            </summary>
            <remarks>
            Similar to <see cref="M:System.Windows.Forms.Application.DoEvents"/>, but more lightweight. Uses API functions <msdn>PeekMessage</msdn>, <msdn>TranslateMessage</msdn> and <msdn>DispatchMessage</msdn>.
            Be careful, this function is as dangerous as <b>Application.DoEvents</b>.
            </remarks>
        </member>
        <member name="T:Au.wait.SleepPrecision_">
            <summary>
            Temporarily changes the time resolution/precision of Thread.Sleep and some other functions.
            </summary>
            <remarks>
            Uses API <msdn>timeBeginPeriod</msdn>, which requests a time resolution for various system timers and wait functions. Actually it is the system thread scheduling timer period.
            Normal resolution on Windows 7-10 is 15.625 ms. It means that, for example, <c>Thread.Sleep(1);</c> sleeps not 1 but 1-15 ms. If you set resolution 1, it sleeps 1-2 ms.
            The new resolution is revoked (<msdn>timeEndPeriod</msdn>) when disposing the SleepPrecision_ variable or when this process ends. See example. See also <see cref="M:Au.wait.SleepPrecision_.TempSet1(System.Int32)"/>.
            The resolution is applied to all threads and processes. Other applications can change it too. For example, often web browsers temporarily set resolution 1 ms when opening a web page.
            The system uses the smallest period (best resolution) that currently is set by any application. You cannot make it bigger than current value.
            <note>It is not recommended to keep small period (high resolution) for a long time. It can be bad for power saving.</note>
            Don't need this for wait.SleepX and functions that use them (mouse.click etc). They call <see cref="M:Au.wait.SleepPrecision_.TempSet1(System.Int32)"/> when the sleep time is 1-99 ms.
            This does not change the minimal period of <see cref="T:Au.timerm"/> and System.Windows.Forms.Timer.
            </remarks>
            <example>
            <code><![CDATA[
            _Test("before");
            using(new wait.SleepPrecision_(2)) {
            	_Test("in");
            }
            _Test("after");
            
            void _Test(string name)
            {
            	print.it(name);
            	perf.first();
            	for(int i = 0; i < 8; i++) { Thread.Sleep(1); perf.next(); }
            	perf.write();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.SleepPrecision_.#ctor(System.Int32)">
            <summary>
            Calls API <msdn>timeBeginPeriod</msdn>.
            </summary>
            <param name="periodMS">
            New system timer period, milliseconds.
            Should be 1. Other values may stuck and later cannot be made smaller due to bugs in OS or some applications; this bug would impact many functions of this library.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">periodMS &lt;= 0.</exception>
        </member>
        <member name="M:Au.wait.SleepPrecision_.Dispose">
            <summary>
            Calls API <msdn>timeEndPeriod</msdn>.
            </summary>
        </member>
        <member name="M:Au.wait.SleepPrecision_.Finalize">
            
        </member>
        <member name="P:Au.wait.SleepPrecision_.Current">
            <summary>
            Gets current actual system time resolution (period).
            The return value usually is between 0.5 and 15.625 milliseconds. Returns 0 if fails.
            </summary>
        </member>
        <member name="M:Au.wait.SleepPrecision_.TempSet1(System.Int32)">
            <summary>
            Temporarily sets the system wait precision to 1 ms. It will be revoked after the specified time or when this process ends.
            If already set, just updates the revoking time.
            </summary>
            <param name="endAfterMS">Revoke after this time, milliseconds.</param>
            <example>
            <code><![CDATA[
            print.it(wait.SleepPrecision_.Current); //probably 15.625
            wait.SleepPrecision_.TempSet1(500);
            print.it(wait.SleepPrecision_.Current); //1
            Thread.Sleep(600);
            print.it(wait.SleepPrecision_.Current); //probably 15.625 again
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.SleepPrecision_.TempSet1_(System.Int32)">
            <summary>
            Calls TempSet1 if sleepTimeMS is 1-99.
            </summary>
            <param name="sleepTimeMS">milliseconds of the caller 'sleep' function.</param>
        </member>
        <member name="T:Au.wait.Loop">
            <summary>
            Can be used to easily implement 'wait for' functions with a timeout.
            </summary>
            <remarks>
            See examples. The code works like most 'wait for' functions of this library: on timeout throws exception, unless secondsTimeout is negative.
            Similar code is used by most 'wait for' functions of this library.
            See also <see cref="M:Au.wait.forCondition(System.Double,System.Func{System.Boolean},Au.Types.OWait)"/>; usually it's easier; internally it uses similar code too.
            </remarks>
            <example>
            <code><![CDATA[
            public static bool WaitForMouseLeftButtonDown(double secondsTimeout)
            {
            	var x = new wait.Loop(secondsTimeout);
            	for(; ; ) {
            		if(mouse.isPressed(MButtons.Left)) return true;
            		if(!x.Sleep()) return false;
            	}
            }
            ]]></code>
            The same with wait.forCondition.
            <code><![CDATA[
            static bool WaitForMouseLeftButtonDown2(double secondsTimeout)
            {
            	return wait.forCondition(secondsTimeout, () => mouse.isPressed(MButtons.Left));
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.wait.Loop.Period">
            <summary>
            Current period (<see cref="M:Au.wait.Loop.Sleep"/> sleep time), milliseconds.
            Initially it is <see cref="P:Au.Types.OWait.Period"/>, optionally multiplied by constructor's <i>options.Period</i>/10. Default 10 ms. Then each <see cref="M:Au.wait.Loop.Sleep"/> increments it until <see cref="P:Au.wait.Loop.MaxPeriod"/>.
            </summary>
        </member>
        <member name="P:Au.wait.Loop.MaxPeriod">
            <summary>
            Maximal period (<see cref="M:Au.wait.Loop.Sleep"/> sleep time), milliseconds.
            It is <see cref="P:Au.wait.Loop.Period"/>*50 (default 500).
            </summary>
        </member>
        <member name="P:Au.wait.Loop.TimeRemaining">
            <summary>
            Gets or sets the remaining time, milliseconds.
            </summary>
        </member>
        <member name="M:Au.wait.Loop.#ctor(System.Double,Au.Types.OWait)">
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval <see cref="M:Au.wait.Loop.Sleep"/> throws <see cref="T:System.TimeoutException"/>. If &lt;0, then <see cref="M:Au.wait.Loop.Sleep"/> returns false.
            </param>
            <param name="options">Options. If null, uses <see cref="P:Au.opt.wait"/>, else combines with it.</param>
        </member>
        <member name="M:Au.wait.Loop.Sleep">
            <summary>
            Calls <see cref="M:Au.wait.Loop.IsTimeout"/>. If it returns true, returns false.
            Else sleeps for <see cref="P:Au.wait.Loop.Period"/> milliseconds, increments <b>Period</b> if it is less than <see cref="P:Au.wait.Loop.MaxPeriod"/>, and returns true.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.wait.Loop.IsTimeout">
            <summary>
            If the <i>secondsTimeout</i> time is not expired, returns false.
            Else if <i>secondsTimeout</i> is negative, returns true.
            Else throws <see cref="T:System.TimeoutException"/>.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.wait.forCondition(System.Double,System.Func{System.Boolean},Au.Types.OWait)">
            <summary>
            Waits for a user-defined condition.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true. The calling period depends on <i>options</i>.</param>
            <param name="options">Options. If null, uses <see cref="P:Au.opt.wait"/>, else combines with it.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>More info: <see cref="T:Au.wait"/>.</remarks>
            <example>See <see cref="T:Au.wait"/>.</example>
        </member>
        <member name="M:Au.wait.forHandle(System.Double,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a kernel object (event, mutex, etc).
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="flags"></param>
            <param name="handles">One or more handles of kernel objects. Max 63.</param>
            <returns>
            Returns 1-based index of the first signaled handle. Negative if abandoned mutex.
            On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.
            </returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example a handle is invalid.</exception>
            <remarks>
            Uses API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn>. Alertable.
            Does not use <see cref="P:Au.opt.wait"/>.
            </remarks>
        </member>
        <member name="M:Au.wait.Wait_(System.Int64,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a signaled kernel handle. Or just sleeps, if handles is null/empty.
            If flag DoEvents, dispatches received messages, hook notifications, etc.
            Calls API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn> with QS_ALLINPUT. Alertable.
            When a handle becomes signaled, returns its 0-based index. If abandoned mutex, returns 0-based index + Api.WAIT_ABANDONED_0 (0x80).
            If timeMS>0, waits max timeMS and on timeout returns Api.WAIT_TIMEOUT.
            If failed, returns -1. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wait.Wait_(System.Int64,Au.Types.WHFlags,System.Object,Au.Types.WaitVariable_,System.IntPtr[])">
            <summary>
            The same as <see cref="M:Au.wait.Wait_(System.Int64,Au.Types.WHFlags,System.IntPtr[])"/> + can wait for message and variable.
            If msgCallback is not null, calls it when dispatching messages. If returns true, stops waiting and returns handles?.Length.
            	If it is WPMCallback, calls it before dispatching a posted message.
            	If it is Func{bool}, calls it after dispatching one or more messages.
            If stopVar is not null, when it becomes true stops waiting and returns handles?.Length + 1.
            </summary>
        </member>
        <member name="M:Au.wait.forPostedMessage(System.Double,Au.Types.WPMCallback)">
            <summary>
            Waits for a posted message received by this thread.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="callback">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.wait.doEvents(System.Int32)"/>. Before dispatching a posted message, calls the callback function. Stops waiting when it returns true. Does not dispatch the message if the function sets the message field = 0.
            Does not use <see cref="P:Au.opt.wait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            timerm.after(2000, t => { print.it("timer"); });
            wait.forPostedMessage(5, (ref MSG m) => { print.it(m); return m.message == 0x113; }); //WM_TIMER
            print.it("finished");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.forMessagesAndCondition(System.Double,System.Func{System.Boolean})">
            <summary>
            Waits for a variable or other condition that is changed while processing messages or other events received by this thread.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.wait.doEvents(System.Int32)"/>. After dispatching one or more messages or other events (posted messages, messages sent by other threads, hooks, etc), calls the callback function. Stops waiting when it returns true.
            Similar to <see cref="M:Au.wait.forCondition(System.Double,System.Func{System.Boolean},Au.Types.OWait)"/>. Differences: 1. Always dispatches messages etc. 2. Does not call the callback function when there are no messages etc.
            Does not use <see cref="P:Au.opt.wait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            timerm.after(2000, t => { print.it("timer"); stop = true; });
            wait.forMessagesAndCondition(5, () => stop);
            print.it(stop);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wait.forVariable(System.Double,System.Boolean@,Au.Types.OWait)">
            <summary>
            Waits until a variable is set = true.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="variable">Stop waiting when this variable is set to true.</param>
            <param name="options">Options. If null, uses <see cref="P:Au.opt.wait"/>, else combines with it.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            This function is useful when the variable can be changed by any thread. To wait for a variable changed while processing messages etc in this thread, it's better to use <see cref="M:Au.wait.forMessagesAndCondition(System.Double,System.Func{System.Boolean})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            Task.Run(() => { 2.s(); print.it("task"); stop = true; });
            wait.forVariable(5, stop);
            print.it(stop);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Triggers.ActionTrigger">
            <summary>
            Base of classes of all action trigger types.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.Run(Au.Triggers.TriggerArgs)">
            <summary>
            Called through <see cref="M:Au.Triggers.TriggerActionThreads.Run(Au.Triggers.ActionTrigger,Au.Triggers.TriggerArgs,System.Int32)"/> in action thread.
            Possibly runs later.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.RunT``1(``0)">
            <summary>
            Makes simpler to implement <see cref="M:Au.Triggers.ActionTrigger.Run(Au.Triggers.TriggerArgs)"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.TypeString">
            <summary>
            Returns a trigger type string, like "Hotkey", "Mouse", "Window.ActiveNew".
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.ToString">
            <summary>
            Returns TypeString + " " + ParamsString.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.Disabled">
            <summary>
            Gets or sets whether this trigger is disabled.
            Does not depend on <see cref="P:Au.Triggers.ActionTriggers.Disabled"/>, <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>, <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.DisabledThisOrAll">
            <summary>
            Returns true if <see cref="P:Au.Triggers.ActionTrigger.Disabled"/>; also if <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> or <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>, unless <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.EnabledAlways">
            <summary>
            Gets or sets whether this trigger ignores <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> and <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            </summary>
            <remarks>
            When adding the trigger, this property is set to the value of <see cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/> at that time.
            </remarks>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.RunAction(Au.Triggers.TriggerArgs)">
            <summary>
            Starts the action like when its trigger is activated.
            </summary>
            <param name="args"></param>
            <exception cref="T:System.InvalidOperationException">Called in a wrong place or from a wrong thread. More info in Ramarks.</exception>
            <remarks>
            Call while <see cref="M:Au.Triggers.ActionTriggers.Run"/> is running, from the same thread.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TriggerArgs">
            <summary>
            Base of trigger action argument classes of all trigger types.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerArgs.TriggerBase">
            <summary>
            Gets the trigger as <see cref="T:Au.Triggers.ActionTrigger"/> (the base class of all trigger type classes).
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerArgs.DisableTriggerUntilClosed(Au.toolbar)">
            <summary>
            Disables the trigger. Enables later when the toolbar is closed.
            Use to implement single-instance toolbars.
            </summary>
        </member>
        <member name="T:Au.Triggers.TriggerScopes">
            <summary>
            Allows to specify working windows for multiple triggers of these types: hotkey, autotext, mouse.
            </summary>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+K"] = o => print.it("this trigger works with all windows");
            Triggers.Of.Window("* Notepad"); //specifies a working window for triggers added afterwards
            Triggers.Hotkey["Ctrl+F11"] = o => print.it("this trigger works only when a Notepad window is active");
            Triggers.Hotkey["Ctrl+F12"] = o => print.it("this trigger works only when a Notepad window is active");
            var wordpad = Triggers.Of.Window("* WordPad"); //specifies another working window for triggers added afterwards
            Triggers.Hotkey["Ctrl+F11"] = o => print.it("this trigger works only when a WordPad window is active");
            Triggers.Hotkey["Ctrl+F12"] = o => print.it("this trigger works only when a WordPad window is active");
            Triggers.Of.AllWindows(); //let triggers added afterwards work with all windows
            Triggers.Mouse[TMEdge.RightInTop25] = o => print.it("this trigger works with all windows");
            Triggers.Of.Again(wordpad); //sets a previously specified working window for triggers added afterwards
            Triggers.Mouse[TMEdge.RightInBottom25] = o => print.it("this trigger works only when a WordPad window is active");
            Triggers.Mouse[TMMove.DownUp] = o => print.it("this trigger works only when a WordPad window is active");
            Triggers.Mouse[TMClick.Middle] = o => print.it("this trigger works only when the mouse is in a WordPad window");
            Triggers.Mouse[TMWheel.Forward] = o => print.it("this trigger works only when the mouse is in a WordPad window");
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.AllWindows">
            <summary>
            Sets scope "all windows" again. Hotkey, autotext and mouse triggers added afterwards will work with all windows.
            </summary>
            <remarks>
            Example in class help.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)">
            <summary>
            Sets (reuses) a previously specified scope.
            </summary>
            <remarks>
            Example in class help.
            </remarks>
            <param name="scope">The return value of function <b>Window</b>, <b>NotWindow</b>, <b>Windows</b> or <b>NotWindows</b>.</param>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Window(System.String,System.String,Au.Types.WOwner,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Sets scope "only this window". Hotkey, autotext and mouse triggers added afterwards will work only when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <remarks>
            Parameters are like with <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            Example in class help.
            </remarks>
            <exception cref="T:System.ArgumentException">Exceptions of <see cref="T:Au.wndFinder"/> constructor.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindow(System.String,System.String,Au.Types.WOwner,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Sets scope "not this window". Hotkey, autotext and mouse triggers added afterwards will not work when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <remarks>
            Parameters are like with <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            Example in class help.
            </remarks>
            <exception cref="T:System.ArgumentException">Exceptions of <see cref="T:Au.wndFinder"/> constructor.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Window(Au.wndFinder)">
            <summary>
            Sets scope "only this window". Hotkey, autotext and mouse triggers added afterwards will work only when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindow(Au.wndFinder)">
            <summary>
            Sets scope "not this window". Hotkey, autotext and mouse triggers added afterwards will not work when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Windows(Au.wndFinder[])">
            <summary>
            Sets scope "only these windows". Hotkey, autotext and mouse triggers added afterwards will work only when one of the specified windows is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <param name="any">
            Specifies one or more windows.
            Tip: <b>wndFinder</b> has implicit conversion from string. See <see cref="M:Au.wndFinder.op_Implicit(System.String)~Au.wndFinder"/>.
            Examples: <c>"Name"</c>, <c>"Name,Class"</c>, <c>",,Program.exe"</c>.
            The easiest way to specify "all windows of program X.exe": <c>Triggers.Of.Windows(",,X.exe")</c>.
            </param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wndFinder.op_Implicit(System.String)~Au.wndFinder"/>. This function itself does not throw exceptions.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindows(Au.wndFinder[])">
            <summary>
            Sets scope "not these windows". Hotkey, autotext and mouse triggers added afterwards will not work when one of the specified windows is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <param name="any">See <see cref="M:Au.Triggers.TriggerScopes.Windows(Au.wndFinder[])"/>.</param>
            <exception cref="T:System.Exception">See <see cref="M:Au.Triggers.TriggerScopes.Windows(Au.wndFinder[])"/>.</exception>
        </member>
        <member name="T:Au.Triggers.TriggerScope">
            <summary>
            A trigger scope returned by functions like <see cref="M:Au.Triggers.TriggerScopes.Window(System.String,System.String,Au.Types.WOwner,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> and used with <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/>.
            </summary>
            <example>See <see cref="T:Au.Triggers.TriggerScopes"/>.</example>
        </member>
        <member name="M:Au.Triggers.TriggerScope.Match(Au.Triggers.TriggerHookContext)">
            <summary>
            Returns true if window matches.
            </summary>
            <param name="thc">This func uses the window handle (gets on demand) and WFCache.</param>
        </member>
        <member name="T:Au.Triggers.TriggerFuncs">
             <summary>
             Allows to define custom scopes/contexts/conditions for triggers.
             </summary>
             <remarks>
             Similar to <see cref="T:Au.Triggers.TriggerScopes"/> (code like <c>Triggers.Of.Window(...);</c>), but allows to define any scope/condition/etc, not just the active window.
             
             To define a scope, you create a callback function (CF) that checks some conditions and returns true to allow the trigger action to run or false to not allow. Assign the CF to some property of this class and then add the trigger, like in the examples below. The CF will be assigned to the trigger and called when need.
             
             You may ask: why to use CF when the trigger action (TA) can do the same?
             1. CF runs synchronously; if it returns false, the trigger key or mouse button message is passed to other triggers, hooks and apps. TA cannot do it reliably; it runs asynchronously, and the message is already stealed from other apps/triggers/hooks.
             2. CF is faster to call. It is simply called in the same thread that processes trigger messages. TA usually runs in another thread.
             3. A CF can be assigned to multiple triggers with a single line of code. Don't need to add the same code in all trigger actions.
             
             A trigger can have up to 4 CF delegates and a window scope (<c>Triggers.Of...</c>). They are called in this order: CF assigned through <see cref="P:Au.Triggers.TriggerFuncs.FollowingTriggersBeforeWindow"/>, <see cref="P:Au.Triggers.TriggerFuncs.NextTriggerBeforeWindow"/>, window scope, <see cref="P:Au.Triggers.TriggerFuncs.NextTrigger"/>, <see cref="P:Au.Triggers.TriggerFuncs.FollowingTriggers"/>. The <b>NextX</b> properties assign the CF to the next single trigger. The <b>FollowingX</b> properties assign the CF to all following triggers until you assign another CF or null. If several are assigned, the trigger action runs only if all CF return true and the window scope matches. The <b>XBeforeWindow</b> properties are used only with hotkey, autotext and mouse triggers.
             
             All CF must be as fast as possible. Slow CF can make triggers slower (or even all keyboard/mouse input); also may cause warnings and trigger failures. A big problem is the low-level hooks timeout that Windows applies to trigger hooks; see <see cref="P:Au.More.WindowsHook.LowLevelHooksTimeout"/>. A related problem - slow JIT and loading of assemblies, which can make the CF too slow the first time; in some rare cases may even need to preload assemblies or pre-JIT functions to avoid the timeout warning.
            
             In CF never use functions that generate keyboard or mouse events or activate windows.
             </remarks>
             <example>
             Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
             <code><![CDATA[
             //examples of assigning a callback function (CF) to a single trigger
             Triggers.FuncOf.NextTrigger = o => keys.isCapsLock; //o => keys.isCapsLock is the callback function (lambda)
             Triggers.Hotkey["Ctrl+K"] = o => print.it("action: Ctrl+K while CapsLock is on");
             Triggers.FuncOf.NextTrigger = o => { var v = o as HotkeyTriggerArgs; print.it($"func: mod={v.Mod}"); return mouse.isPressed(MButtons.Left); };
             Triggers.Hotkey["Ctrl+Shift?+B"] = o => print.it("action: mouse left button + Ctrl+B or Ctrl+Shift+B");
             
             //examples of assigning a CF to multiple triggers
             Triggers.FuncOf.FollowingTriggers = o => { var v = o as HotkeyTriggerArgs; print.it("func", v.Trigger); return true; };
             Triggers.Hotkey["Ctrl+F8"] = o => print.it("action: " + o.Trigger);
             Triggers.Hotkey["Ctrl+F9"] = o => print.it("action: " + o.Trigger);
             Triggers.FuncOf.FollowingTriggers = null; //stop assigning the CF to triggers added afterwards
             
             //sometimes all work can be done in CF and you don't need the trigger action
             Triggers.FuncOf.NextTrigger = o => { var v = o as HotkeyTriggerArgs; print.it("func: " + v.Trigger); return true; };
             Triggers.Hotkey["Ctrl+F12"] = null;
             
             Triggers.Run();
             ]]></code>
             </example>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.NextTrigger">
            <summary>
            Sets callback function for the next added trigger.
            If the trigger has a window scope, the callback function is called after evaluating the window.
            This function is used with triggers of all types.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.NextTriggerBeforeWindow">
            <summary>
            Sets callback function for the next added trigger.
            If the trigger has a window scope, the callback function is called before evaluating the window.
            This function is used with triggers of these types: hotkey, autotext, mouse.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.FollowingTriggers">
            <summary>
            Sets callback function for multiple triggers added afterwards.
            If the trigger has a window scope, the callback function is called after evaluating the window.
            This function is used with triggers of all types.
            The value can be null.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.FollowingTriggersBeforeWindow">
            <summary>
            Sets callback function for multiple triggers added afterwards.
            If the trigger has a window scope, the callback function is called before evaluating the window.
            This function is used with triggers of these types: hotkey, autotext, mouse.
            The value can be null.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerFuncs.Reset">
            <summary>
            Clears all properties (sets = null).
            </summary>
        </member>
        <member name="T:Au.Triggers.TFunc">
            <summary>
            Type of functions used with class <see cref="T:Au.Triggers.TriggerFuncs"/> to define custom scope for triggers.
            </summary>
            <param name="args">Trigger action arguments. Example: <see cref="T:Au.Triggers.TriggerFuncs"/>.</param>
            <returns>Return true to run the trigger action, or false to not run.</returns>
        </member>
        <member name="T:Au.Triggers.ActionTriggers">
            <summary>
            The main class of action triggers.
            </summary>
            <remarks>
            This class manages action triggers. Action triggers are used to call functions (aka <i>trigger actions</i>) in a running script in response to events such as hotkey, typed text, mouse action, activated window. To launch scripts are used other ways: manually, at startup, command line, <see cref="M:Au.script.run(System.String,System.String[])"/>, output link.
            
            If your script class has a field or property like <c>readonly ActionTriggers Triggers = new();</c>, through it you can access all trigger types (hotkey, window, etc) and add triggers to them.
            
            Code syntax to add an action trigger:
            <code>Triggers.TriggerType[parameters] = action;</code>
            Examples:
            <code>
            Triggers.Hotkey["Ctrl+K"] = o => print.it(o.Trigger);
            Triggers.Hotkey["Ctrl+Shift+K"] = o => {
            	print.it("This is a trigger action (lambda function).");
            	print.it($"It runs when you press {o.Trigger}.");
            };
            Triggers.Run();
            </code>
            
            Also you can set options (<see cref="T:Au.Triggers.TriggerOptions"/>), window scopes (<see cref="T:Au.Triggers.TriggerScopes"/>) and custom scopes (<see cref="T:Au.Triggers.TriggerFuncs"/>) for triggers added afterwards.
            
            Finally call <see cref="M:Au.Triggers.ActionTriggers.Run"/>. It runs all the time (like <b>Application.Run</b>) and launches trigger actions (functions) when need. Actions run in other thread(s) by default.
            
            Recommended properties for scripts containing triggers:
            - <c>ifRunning warn_restart</c> - to quickly restart the script when editing. Just click the Run button.
            
            Avoid multiple scripts with triggers. Each running instance uses some CPU. All triggers should be in single script, if possible. It's OK to run additional scripts temporarily, for example to test new triggers without restarting the main script. From trigger actions you can call <see cref="M:Au.script.run(System.String,System.String[])"/> to run other scripts in new process; see example.
            
            Trigger actions don't inherit <b>opt</b> options that are set before adding triggers. The example shows two ways how to set <b>opt</b> options for multiple actions. Also you can set them in action code. Next action running in the same thread will not inherit <b>opt</b> options set by previous action.
            </remarks>
            <example>
            This is a single script with many action triggers.
            <code><![CDATA[
            using Au.Triggers; //add this above or below other 'using' directives
            
            readonly ActionTriggers Triggers = new(); //add this field in your script class
            
            //you can set options for triggers added afterwards
            Triggers.Options.Thread(0, 500);
            
            //you can use variables if don't want to type "Triggers.Hotkey" etc for each trigger
            var hk = Triggers.Hotkey;
            var mouse = Triggers.Mouse;
            var win = Triggers.Window;
            var tt = Triggers.Autotext;
            
            //hotkey triggers
            
            hk["Ctrl+K"] = o => print.it(o.Trigger); //it means: execute code "o => print.it(o.Trigger)" when I press Ctrl+K
            hk["Ctrl+Shift+F11"] = o => {
            	print.it(o.Trigger);
            	var w1 = wnd.findOrRun("* Notepad", run: () => run.it(folders.System + "notepad.exe"));
            	keys.sendt("text");
            	w1.Close();
            };
            hk["Win+Alt+K"] = o => script.run("other script.cs"); //run other script in new process
            
            //triggers that work only with some windows
            
            Triggers.Of.Window("* WordPad", "WordPadClass"); //let the following triggers work only when a WordPad window is active
            hk["Ctrl+F5"] = o => print.it(o.Trigger, o.Window);
            hk["Ctrl+F6"] = o => print.it(o.Trigger, o.Window);
            
            var notepad = Triggers.Of.Window("* Notepad"); //let the following triggers work only when a Notepad window is active
            hk["Ctrl+F5"] = o => print.it(o.Trigger, o.Window);
            hk["Ctrl+F6"] = o => print.it(o.Trigger, o.Window);
            
            Triggers.Of.AllWindows(); //let the following triggers work with all windows
            
            //mouse triggers
            
            mouse[TMClick.Right, "Ctrl+Shift", TMFlags.ButtonModUp] = o => print.it(o.Trigger);
            mouse[TMEdge.RightInCenter50] = o => { print.it(o.Trigger); dialog.show("Bang!", x: Coord.Max); };
            mouse[TMMove.LeftRightInCenter50] = o => wnd.switchActiveWindow();
            
            Triggers.FuncOf.NextTrigger = o => keys.isScrollLock; //example of a custom scope (aka context, condition)
            mouse[TMWheel.Forward] = o => print.it($"{o.Trigger} while ScrollLock is on");
            
            Triggers.Of.Again(notepad); //let the following triggers work only when a Notepad window is active
            mouse[TMMove.LeftRightInBottom25] = o => { print.it(o.Trigger); o.Window.Close(); };
            Triggers.Of.AllWindows();
            
            //window triggers. Note: window triggers don't depend on Triggers.Of.
            
            win[TWEvent.ActiveNew, "* Notepad", "Notepad"] = o => print.it("opened Notepad window");
            win[TWEvent.ActiveNew, "Notepad", "#32770", contains: "Do you want to save *"] = o => {
            	print.it("opened Notepad's 'Do you want to save' dialog");
            	//keys.send("Alt+S"); //click the Save button
            };
            
            //autotext triggers
            
            tt["los"] = o => o.Replace("Los Angeles");
            tt["WIndows", TAFlags.MatchCase] = o => o.Replace("Windows");
            tt.DefaultPostfixType = TAPostfix.None;
            tt["<b>"] = o => o.Replace("<b>[[|]]</b>");
            tt["#file"] = o => {
            	o.Replace("");
            	var fd = new OpenFileDialog();
            	if(fd.ShowDialog() == DialogResult.OK) keys.sendt(fd.FileName);
            };
            tt.DefaultPostfixType = default;
            
            //shorter auto-replace code
            
            var ts = Triggers.Autotext.SimpleReplace;
            ts["#so"] = "Some text"; //the same as tt["#so"] = o => o.Replace("Some text");
            ts["#mo"] = "More text";
            
            //how to set opt options for trigger actions
            
            //opt.key.TextHow = OKeyText.Paste; //no, it won't work. It sets opt for this thread, not for trigger actions.
            Triggers.Options.BeforeAction = o => { opt.key.TextHow = OKeyText.Paste; }; //the correct way. Sets opt before executing an action.
            ts["#p1"] = "text 1";
            ts["#p2"] = "text 2";
            Triggers.Options.BeforeAction = null;
            
            //another way to set opt options - use opt.init. It sets options for all actions in the script, not just for triggers added afterwards.
            
            opt.init.key.PasteLength = 50;
            opt.init.key.Hook = h => { var w1 = h.w.Window; print.it(w1); if(w1.Name.Like("* Word")) h.optk.PasteWorkaround = true; };
            ts["#p3"] = "/* " + new string('*', 60) + " */\r\n";
            
            //how to stop and disable/enable triggers
            
            hk["Ctrl+Alt+Q"] = o => Triggers.Stop(); //let Triggers.Run() end its work and return
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+Alt+D"] = o => Triggers.Disabled ^= true; //disable/enable triggers here
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+Alt+Win+D"] = o => ActionTriggers.DisabledEverywhere ^= true; //disable/enable triggers in all processes
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+F7"] = o => print.it("This trigger can be disabled/enabled with Ctrl+F8.");
            var t1 = hk.Last;
            hk["Ctrl+F8"] = o => t1.Disabled ^= true; //disable/enable a trigger
            
            //finally call Triggers.Run(). Without it the triggers won't work.
            Triggers.Run();
            //Triggers.Run returns when is called Triggers.Stop (see the "Ctrl+Alt+Q" trigger above).
            print.it("called Triggers.Stop");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.#ctor">
            <summary>
            Initializes a new instance of this class.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Of">
            <summary>
            Allows to set window scopes (working windows) for triggers.
            </summary>
            <remarks>Examples: <see cref="T:Au.Triggers.TriggerScopes"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.FuncOf">
            <summary>
            Allows to set custom scopes/contexts/conditions for triggers.
            </summary>
            <remarks>More info and examples: <see cref="T:Au.Triggers.TriggerFuncs"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Options">
            <summary>
            Allows to set some options for multiple triggers and their actions.
            </summary>
            <remarks>More info and examples: <see cref="T:Au.Triggers.TriggerOptions"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.ResetOptions">
            <summary>
            Clears all options (of <see cref="P:Au.Triggers.ActionTriggers.Options"/>, <see cref="P:Au.Triggers.ActionTriggers.Of"/>, <see cref="P:Au.Triggers.ActionTriggers.FuncOf"/>, <see cref="P:Au.Triggers.ActionTriggers.Autotext"/>).
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Hotkey">
            <summary>
            Hotkey triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Autotext">
            <summary>
            Autotext triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Mouse">
            <summary>
            Mouse triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Window">
            <summary>
            Window triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.Run">
            <summary>
            Makes triggers alive.
            </summary>
            <remarks>
            This function monitors hotkeys, activated windows and other events. When an event matches an added trigger, launches the thrigger's action, which runs in other thread by default.
            Does not return immediately. Runs until this process is terminated or <see cref="M:Au.Triggers.ActionTriggers.Stop"/> called.
            </remarks>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
            <exception cref="T:System.InvalidOperationException">Already running.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.Stop">
            <summary>
            Stops trigger engines and causes <see cref="M:Au.Triggers.ActionTriggers.Run"/> to return.
            </summary>
            <remarks>
            Does not abort threads of trigger actions that are still running.
            </remarks>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+T"] = o => print.it("Ctrl+T");
            Triggers.Hotkey["Ctrl+Q"] = o => { print.it("Ctrl+Q (stop)"); Triggers.Stop(); };
            Triggers.Hotkey.Last.EnabledAlways = true;
            Triggers.Run();
            print.it("stopped");
            ]]></code>
            </example>
        </member>
        <member name="E:Au.Triggers.ActionTriggers.Stopping">
            <summary>
            Occurs before <see cref="M:Au.Triggers.ActionTriggers.Run"/> stops trigger engines and returns.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Running_">
            <summary>
            True if executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.ThrowIfRunning_">
            <summary>
            Throws InvalidOperationException if executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.ThrowIfNotRunning_">
            <summary>
            Throws InvalidOperationException if not executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.ThrowIfNotMainThread_">
            <summary>
            Throws InvalidOperationException if not thread of <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Disabled">
            <summary>
            Gets or sets whether triggers of this <see cref="T:Au.Triggers.ActionTriggers"/> instance are disabled.
            </summary>
            <remarks>
            Does not depend on <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            Does not end/pause threads of trigger actions.
            </remarks>
            <seealso cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>
            <seealso cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+T"] = o => print.it("Ctrl+T");
            Triggers.Hotkey["Ctrl+D"] = o => { print.it("Ctrl+D (disable/enable)"); Triggers.Disabled ^= true; }; //toggle
            Triggers.Hotkey.Last.EnabledAlways = true;
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.DisabledEverywhere">
            <summary>
            Gets or sets whether triggers are disabled in all processes that use this library in this user session.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
            <seealso cref="P:Au.Triggers.ActionTriggers.Disabled"/>
            <seealso cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/>
        </member>
        <member name="P:Au.Triggers.ITriggers.HasTriggers">
            <summary>
            Return true if added triggers of this type.
            </summary>
        </member>
        <member name="M:Au.Triggers.ITriggers.StartStop(System.Boolean)">
            <summary>
            Optionally start/stop trigger engine (hooks etc).
            </summary>
            <param name="start"></param>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.trigger">
            <summary>
            Trigger/action to run. Set by a hook proc of a trigger engine.
            </summary>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.args">
            <summary>
            Used with <see cref="F:Au.Triggers.TriggerHookContext.trigger"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.muteMod">
            <summary>
            Used with <see cref="F:Au.Triggers.TriggerHookContext.trigger"/>.
            Can be 0 or one of TriggerActionThreads.c_ constants.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.InitContext">
            <summary>
            Called before processing each hook event. Clears most properties and fields.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.UseWndFromPoint(Au.Types.POINT)">
            <summary>
            Tells to get window (for scope) from the specified point. If not called, will use the active window. In any case, gets window on demand.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.Mod">
            <summary>
            Currently pressed modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModL">
            <summary>
            Currently pressed left-side modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModR">
            <summary>
            Currently pressed right-side modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModThis">
            <summary>
            Not 0 if this key event is a modifier key. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.InitMod(Au.Types.HookData.Keyboard)">
            <summary>
            Called before processing each keyboard hook event.
            Updates Mod, ModL, ModR, IsThisKeyMod. They are used by hotkey and autotext triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TriggerOptions">
            <summary>
            Allows to set some options for multiple triggers and their actions.
            </summary>
            <remarks>
            You set options through a thread-static property <see cref="P:Au.Triggers.ActionTriggers.Options"/>.
            Changed options are applied to all triggers/actions added afterwards in this thread.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Options.ThreadNew();
            Triggers.Options.BeforeAction = o => { opt.key.KeySpeed = 10; };
            Triggers.Hotkey["Ctrl+K"] = o => print.it(opt.key.KeySpeed); //10
            Triggers.Hotkey["Ctrl+Shift+K"] = o => print.it(opt.key.KeySpeed); //10
            Triggers.Options.BeforeAction = o => { opt.key.KeySpeed = 20; };
            Triggers.Hotkey["Ctrl+L"] = o => print.it(opt.key.KeySpeed); //20
            Triggers.Hotkey["Ctrl+Shift+L"] = o => print.it(opt.key.KeySpeed); //20
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.Thread(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Run actions always in the same dedicated thread that does not end when actions end.
            </summary>
            <param name="thread">A number that you want to use to identify the thread. Can be 0-127. Default 0.</param>
            <param name="ifRunningWaitMS">Defines when to start an action if an action (other or same) is currently running in this thread. If 0 (default), don't run. If -1 (<b>Timeout.Infinite</b>), run when that action ends (and possibly other queed actions). If &gt; 0, run when that action ends, if it ends within this time from now; the time is in milliseconds.</param>
            <param name="noWarning">No warning when cannot start an action because an action is running and ifRunningWaitMS==0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Multiple actions in same thread cannot run simultaneously. Actions in different threads can run simultaneously.
            There is no "end old running action" feature. If need it, use other script. Example: <c>Triggers.Hotkey["Ctrl+M"] = o => script.runWait("Other Script");</c>.
            There is no "temporarily pause old running action to run new action" feature. As well as for scripts.
            The thread has <see cref="F:System.Threading.ApartmentState.STA"/>.
            There are several <b>ThreadX</b> functions. Only the last called function is active. If none called, it is the same as called this function without arguments.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.ThreadMain">
            <summary>
            Run trigger actions in same thread as <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
            <remarks>
            The action must be as fast as possible, else it will block triggers etc. Use to create and show toolbars (<see cref="T:Au.toolbar"/>). Rarely used for other purposes.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.ThreadNew(System.Boolean,System.Boolean)">
            <summary>
            Run trigger actions in new threads.
            </summary>
            <param name="single">Don't run if this action is already running. If false, multiple action instances can run paralelly in multiple threads.</param>
            <param name="mta">Don't set <see cref="F:System.Threading.ApartmentState.STA"/>.</param>
            <remarks>
            The action can run simultaneously with other actions.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.ThreadPool(System.Boolean)">
            <summary>
            Run trigger actions in thread pool threads.
            </summary>
            <param name="single">Don't run if this action is already running. If false, multiple action instances can run paralelly in multiple threads.</param>
            <remarks>
            The action can run simultaneously with other actions. May start later if the pool is busy.
            You should know how to use thread pool correctly. The action runs in the .NET thread pool through <see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>.
            </remarks>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.BeforeAction">
            <summary>
            A function to run before the trigger action.
            For example, it can set <see cref="T:Au.opt"/> options.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Options.BeforeAction = o => { opt.key.KeySpeed = 20; opt.key.TextSpeed = 5; };
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.AfterAction">
            <summary>
            A function to run after the trigger action.
            For example, it can log exceptions.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Options.AfterAction = o => { if(o.Exception!=null) print.it(o.Exception.Message); else print.it("completed successfully"); };
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.EnabledAlways">
            <summary>
            If true, triggers added afterwards don't depend on <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> and <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            This property sets the <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/> property of triggers added afterwards.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.Reset">
            <summary>
            Clears all options.
            </summary>
        </member>
        <member name="T:Au.Triggers.TOBAArgs">
            <summary>
            Arguments for <see cref="P:Au.Triggers.TriggerOptions.BeforeAction"/> and <see cref="P:Au.Triggers.TriggerOptions.AfterAction"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.TOBAArgs.ActionArgs">
            <summary>
            Trigger event info. The same variable as passed to the trigger action.
            To access the info, cast to <b>HotkeyTriggerArgs</b> etc, depending on trigger type.
            </summary>
        </member>
        <member name="P:Au.Triggers.TOBAArgs.Exception">
            <summary>
            If action ended with an exception, the exception. Else null.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerActionThreads._Thread.RunAction(System.Action,Au.Triggers.ActionTrigger)">
            <summary>
            Adds the action to the queue and notifies the thread to execute it.
            If the thread is busy, returns false; if ifRunning!=0, the action possibly will run later.
            </summary>
        </member>
        <member name="T:Au.Triggers.HooksThread">
            <summary>
            Thread containing low-level keyboard and mouse hooks.
            </summary>
        </member>
        <member name="M:Au.Triggers.HooksThread._Send(Au.Triggers.HooksThread.UsedEvents)">
            <summary>
            Sends key/mouse event data (copied to _keyData etc) to the main thread.
            Returns true to eat (block, discard) the event.
            On 1100 ms timeout returns false.
            </summary>
        </member>
        <member name="M:Au.Triggers.HooksThread.Return(System.Int32,System.Boolean)">
            <summary>
            Called by the main thread to resume the hooks thread (_Send) and pass the return value (eat).
            Returns false on timeout.
            </summary>
        </member>
        <member name="M:Au.Triggers.HooksThread.GetKeyData(System.Int32,Au.Types.Api.KBDLLHOOKSTRUCT@)">
            <summary>
            Called by the main thread to get key event data sent by _Send.
            Returns false on timeout.
            </summary>
        </member>
        <member name="M:Au.Triggers.HooksThread.GetClickWheelData(System.Int32,Au.Types.Api.MSLLHOOKSTRUCT@,System.Int32@)">
            <summary>
            Called by the main thread to get mouse click/wheel event data sent by _Send.
            Returns false on timeout.
            </summary>
        </member>
        <member name="M:Au.Triggers.HooksThread.GetEdgeMoveData(System.Int32,Au.Triggers.MouseTriggers.EdgeMoveDetector_.Result@)">
            <summary>
            Called by the main thread to get mouse edge/move event data sent by _Send.
            Returns false on timeout.
            </summary>
        </member>
        <member name="M:Au.Triggers.TrigUtil.GetModLR(Au.Types.KMod@,Au.Types.KMod@)">
            <summary>
            Gets left and right modifiers. Uses keys.isPressed.
            Returns modL | modR.
            </summary>
        </member>
        <member name="T:Au.Triggers.TAFlags">
            <summary>
            Flags of autotext triggers.
            </summary>
            <remarks>
            To avoid passing flags to each trigger as the <i>flags</i> parameter, use <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>; its initial value is 0, which means: case-insensitive, erase the typed text with Backspace, modify the replacement text depending on the case of the typed text.
            </remarks>
        </member>
        <member name="F:Au.Triggers.TAFlags.MatchCase">
            <summary>
            Case-sensitive.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.DontErase">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> don't erase the user-typed text.
            Without this flag it erases text with the Backspace key or selects with Shift+Left. If <b>Replace</b> not called, text is not erased/selected regardless of this flag.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.ReplaceRaw">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> don't modify the replacement text. Without this flag it:
            - If the first character of the typed text is uppercase, makes the first character of the replacement text uppercase.
            - If all typed text is uppercase, makes the replacement text uppercase.
            
            Also does not modify if used flag <b>MatchCase</b> or HTML.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.RemovePostfix">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> remove the postfix delimiter character.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.Confirm">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> call <see cref="M:Au.Triggers.AutotextTriggerArgs.Confirm(System.String)"/> and do nothing if it returns false.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.ShiftLeft">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> select text with Shift+Left instead of erasing with Backspace. Except in console windows.
            See also <see cref="P:Au.Triggers.AutotextTriggerArgs.ShiftLeft"/>.
            </summary>
        </member>
        <member name="T:Au.Triggers.TAPostfix">
            <summary>
            Postfix type of autotext triggers.
            The trigger action runs only when the user ends the autotext with a postfix character or key, unless postfix type is <b>None</b>.
            Default: <b>CharOrKey</b>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.CharOrKey">
            <summary>A postfix character (see <b>Char</b>) or key (see <b>Key</b>).</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.Char">
            <summary>A postfix character specified in the <i>postfixChars</i> parameter or <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars"/> property. If not specified - any non-word character.</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.Key">
            <summary>The Ctrl or Shift key. Default is Ctrl. You can change it with <see cref="P:Au.Triggers.AutotextTriggers.PostfixKey"/>.</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.None">
            <summary>Don't need a postfix. The action runs immediately when the user types the autotext.</summary>
        </member>
        <member name="T:Au.Triggers.AutotextTrigger">
            <summary>
            Represents an autotext trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTrigger.TypeString">
            <summary>
            Returns "Autotext".
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="T:Au.Triggers.AutotextTriggers">
            <summary>
            Autotext triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String,System.String,System.Int32)">
            <summary>
            Adds an autotext trigger.
            </summary>
            <param name="text">The action runs when the user types this text and a postfix character or key. By default case-insensitive.</param>
            <param name="flags">Options. If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>. Some flags are used by <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/>.</param>
            <param name="postfixType">Postfix type (character, key, any or none). If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixType"/>; default - a non-word character or the Ctrl key.</param>
            <param name="postfixChars">Postfix characters used when postfix type is <b>Char</b> or <b>CharOrKey</b> (default). If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars"/>; default - non-word characters.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">
            - Text is empty or too long. Can be 1 - 100 characters.
            - Postfix characters contains letters or digits.
            </exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.SimpleReplace">
            <summary>
            Allows to add triggers in a more concise way - assign a string, not a function. The string will replace the user-typed text.
            </summary>
            <example>
            <code><![CDATA[
            var ts = Triggers.Autotext.SimpleReplace;
            ts["#su"] = "Sunday"; //the same as Triggers.Autotext["#su"] = o => o.Replace("Sunday");
            ts["#mo"] = "Monday";
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultFlags">
            <summary>
            Default value for the <i>flags</i> parameter used for triggers added afterwards.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultPostfixType">
            <summary>
            Default value for the <i>postfixType</i> parameter used for triggers added afterwards.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars">
            <summary>
            Default value for the <i>postfixChars</i> parameter used for triggers added afterwards.
            Default: null.
            </summary>
            <remarks>
            If null (default), postfix characters are all except alpha-numeric (see <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/>).
            The value cannot contain alpha-numeric characters (exception) and <see cref="P:Au.Triggers.AutotextTriggers.WordCharsPlus"/> characters (triggers will not work).
            For Enter use \r.
            </remarks>
            <exception cref="T:System.ArgumentException">The value contains letters or digits.</exception>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.PostfixKey">
            <summary>
            The postfix key for all triggers where postfix type is <see cref="F:Au.Triggers.TAPostfix.Key"/> or <see cref="F:Au.Triggers.TAPostfix.CharOrKey"/> (default).
            Can be Ctrl (default), Shift, LCtrl, RCtrl, LShift or RShift.
            </summary>
            <exception cref="T:System.ArgumentException">The value is not Ctrl or Shift.</exception>
            <remarks>
            This property is applied to all triggers, not just to those added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.WordCharsPlus">
            <summary>
            Additional word characters (non-delimiters).
            Default: null.
            </summary>
            <remarks>
            By default, only alpha-numeric characters (<see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns true) are considered word characters. You can use this property to add more word characters, for example "_#".
            This is used to avoid activating triggers when a trigger text found inside a word.
            This property is applied to all triggers, not just to those added afterwards.
            </remarks>
        </member>
        <member name="M:Au.Triggers.AutotextTriggers.ResetOptions">
            <summary>
            Clears all options.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.AutotextTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.AutotextTriggerArgs">
            <summary>
            Arguments for actions of autotext triggers.
            Use function <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> to replace user-typed text.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.TriggerBase">
            
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Window">
            <summary>
            The active window.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Text">
            <summary>
            The user-typed text. If <see cref="P:Au.Triggers.AutotextTriggerArgs.HasPostfixChar"/>==true, the last character is the postfix delimiter character.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.HasPostfixChar">
            <summary>
            true if the autotext activated when the user typed a postfix delimiter character. Then it is the last character in <see cref="P:Au.Triggers.AutotextTriggerArgs.Text"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.ShiftLeft">
            <summary>
            If true, <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> will select text with Shift+Left instead of erasing with Backspace. Except in console windows.
            Initially true if flag <see cref="F:Au.Triggers.TAFlags.ShiftLeft"/> is set. Can be changed by a callback function, for example to use or not use Shift+Left only with some windows.
            </summary>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.#ctor(Au.Triggers.AutotextTrigger,Au.wnd,System.String,System.Boolean)">
            
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)">
            <summary>
            Replaces the user-typed text with the specified text or/and HTML.
            </summary>
            <param name="text">The replacement text. Can be null.</param>
            <param name="html">
            The replacement HTML. Can be full HTML or fragment. See <see cref="M:Au.clipboardData.AddHtml(System.String)"/>.
            Can be specified only <i>text</i> or only <i>html</i> or both. If both, will paste <i>html</i> in apps that support it, elsewhere <i>text</i>. If only <i>html</i>, in apps that don't support HTML will paste <i>html</i> as text.
            </param>
            <remarks>
            Options for this function can be specified when adding triggers, in the <i>flags</i> parameter. Or before adding triggers, with <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>.
            
            If the replacement text contains substring "[[|]]", removes it and moves the text cursor (caret) there with the Left key. See example. Not if <i>html</i> specified.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Autotext["#exa"] = o => o.Replace("<example>[[|]]</example>");
            ]]></code>
            More examples: <see cref="T:Au.Triggers.ActionTriggers"/>.
            </example>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.Replace2(Au.Types.KKeysEtc[])">
            <summary>
            Replaces the user-typed text with the specified text, keys, cliboard data, etc.
            </summary>
            <param name="keysEtc">The same as with <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/>.</param>
            <remarks>
            Options for this function can be specified when adding triggers, in the <i>flags</i> parameter. Or before adding triggers, with <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>. This function uses <see cref="F:Au.Triggers.TAFlags.Confirm"/>, <see cref="F:Au.Triggers.TAFlags.DontErase"/>, <see cref="F:Au.Triggers.TAFlags.ShiftLeft"/>, <see cref="F:Au.Triggers.TAFlags.RemovePostfix"/>.
            
            If used flag <see cref="F:Au.Triggers.TAFlags.Confirm"/>, for label can be used first argument with prefix "!!"; else displays all string arguments.
            </remarks>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.SendPostfix">
            <summary>
            If <see cref="P:Au.Triggers.AutotextTriggerArgs.HasPostfixChar"/>==true, sends the postfix character (last character of <see cref="P:Au.Triggers.AutotextTriggerArgs.Text"/>) to the active window.
            </summary>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.Confirm(System.String)">
            <summary>
            Shows a 1-item menu below the text cursor (caret) or mouse cursor.
            Returns true if the user clicked the item or pressed Enter or Tab. Other keys close the menu.
            </summary>
            <param name="text">Menu item text. This function limits it to 300 characters. If null, uses "Autotext".</param>
            <remarks>
            This function is used by <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/> when used flag <see cref="F:Au.Triggers.TAFlags.Confirm"/>.
            </remarks>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            var tt = Triggers.Autotext;
            tt["con1", TAFlags.Confirm] = o => o.Replace("Flag Confirm");
            tt["con2"] = o => { if(o.Confirm("Example")) o.Replace("Function Confirm"); };
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Triggers.TASimpleReplace">
            <remarks>Infrastructure.</remarks>
        </member>
        <member name="P:Au.Triggers.TASimpleReplace.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String,System.String,System.Int32)">
            <summary>
            Adds an autotext trigger. Its action calls <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.String)"/>.
            More info: <see cref="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String,System.String,System.Int32)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="T:Au.Triggers.TKFlags">
            <summary>
            Flags of hotkey triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.ShareEvent">
            <summary>
            Allow other apps to receive the key down message too.
            Without this flag, other apps usually receive only modifier keys. Also, OS always receives Ctrl+Alt+Delete and some other hotkeys.
            To receive and block key messages is used a low-level hook. Other hooks may receive blocked messages or not, depending on when they were set. 
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.KeyModUp">
            <summary>
            Run the action when the key and modifier keys are released.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.LeftMod">
            <summary>
            The trigger works only with left-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.RightMod">
            <summary>
            The trigger works only with right-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.NoModOff">
            <summary>
            Don't release modifier keys.
            Without this flag, for example if trigger is ["Ctrl+K"], when the user presses Ctrl and K down, the trigger sends Ctrl key-up event, making the key logically released, although it is still physically pressed. Then modifier keys don't interfer with the action. However functions like <see cref="M:Au.keys.getMod(Au.Types.KMod)"/> and <see cref="M:Au.keys.waitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)"/> (and any such functions in any app) will not know that the key is physically pressed; there is no API to get physical key state.
            <note>Unreleased modifier keys will interfere with mouse functions like <see cref="M:Au.mouse.click(Au.wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. Will not interfere with keyboard and clipboard functions of this library, because they release modifier keys, unless <b>opt.key.NoModOff</b> is true. Will not interfere with functions that send text, unless <b>opt.key.NoModOff</b> is true and <b>opt.key.TextHow</b> is <b>OKeyText.KeysX</b>.</note>.
            Other flags that prevent releasing modifier keys: <b>KeyUp</b>, <b>ShareEvent</b>. Then don't need this flag.
            </summary>
        </member>
        <member name="T:Au.Triggers.HotkeyTrigger">
            <summary>
            Represents a hotkey trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.TypeString">
            <summary>
            Returns "Hotkey".
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.Flags">
            
        </member>
        <member name="T:Au.Triggers.HotkeyTriggers">
            <summary>
            Hotkey triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Item(System.String,Au.Triggers.TKFlags,System.String,System.Int32)">
            <summary>
            Adds a hotkey trigger.
            </summary>
            <param name="hotkey">
            A hotkey, like with the <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> function.
            Can contain 0 to 4 modifier keys (Ctrl, Shift, Alt, Win) and 1 non-modifier key.
            Examples: "F11", "Ctrl+K", "Ctrl+Shift+Alt+Win+A".
            To ignore modifiers: "?+K". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?+K". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?+K", "Ctrl+Shift?+K".
            </param>
            <param name="flags"></param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid hotkey string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Item(Au.Types.KKey,System.String,Au.Triggers.TKFlags,System.String,System.Int32)">
            <summary>
            Adds a hotkey trigger.
            </summary>
            <param name="key"></param>
            <param name="modKeys">
            Modifier keys, like with the <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> function.
            Examples: "Ctrl", "Ctrl+Shift+Alt+Win".
            To ignore modifiers: "?". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?", "Ctrl+Shift?".
            </param>
            <param name="flags"></param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.HotkeyTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.HotkeyTriggerArgs">
            <summary>
            Arguments for actions of hotkey triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.TriggerBase">
            
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Window">
            <summary>
            The active window.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Key">
            <summary>
            The pressed key.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Mod">
            <summary>
            The pressed modifier keys.
            </summary>
            <remarks>
            Can be useful when the trigger ignores modifiers. For example "?+F11" or "Shift?+A".
            </remarks>
        </member>
        <member name="M:Au.Triggers.HotkeyTriggerArgs.#ctor(Au.Triggers.HotkeyTrigger,Au.wnd,Au.Types.KKey,Au.Types.KMod)">
            
        </member>
        <member name="T:Au.Triggers.TMFlags">
            <summary>
            Flags of mouse triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.ShareEvent">
            <summary>
            Allow other apps to receive the mouse button or wheel message too.
            Used only with the click and wheel triggers.
            To receive and block mouse messages is used a low-level hook. Other hooks may receive blocked messages or not, depending on when they were set. 
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.ButtonModUp">
            <summary>
            Run the action when the mouse button and modifier keys are released.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.LeftMod">
            <summary>
            The trigger works only with left-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.RightMod">
            <summary>
            The trigger works only with right-side modifier keys.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTrigger">
            <summary>
            Represents a mouse trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.TypeString">
            <summary>
            Returns "Mouse".
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Kind">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Button">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Wheel">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Edge">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Move">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.ScreenIndex">
            
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Flags">
            
        </member>
        <member name="T:Au.Triggers.MouseTriggers">
            <summary>
            Mouse triggers.
            </summary>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags,System.String,System.Int32)">
            <summary>
            Adds a mouse click trigger.
            </summary>
            <param name="button"></param>
            <param name="modKeys">
            Modifier keys, like with the <see cref="M:Au.keys.send(Au.Types.KKeysEtc[])"/> function.
            Examples: "Ctrl", "Ctrl+Shift+Alt+Win".
            To ignore modifiers: "?". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?", "Ctrl+Shift?".
            </param>
            <param name="flags"></param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMWheel,System.String,Au.Triggers.TMFlags,System.String,System.Int32)">
            <summary>
            Adds a mouse wheel trigger.
            </summary>
            <param name="direction"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags,System.String,System.Int32)"/>.</param>
            <param name="flags"></param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMEdge,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen,System.String,System.Int32)">
            <summary>
            Adds a mouse screen edge trigger.
            </summary>
            <param name="edge"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags,System.String,System.Int32)"/>.</param>
            <param name="flags"></param>
            <param name="screen">
            Let the trigger work only in this screen (display monitor). Also you can specify <b>All</b>.
            Default: <b>Primary</b>.
            Uses <see cref="P:Au.screen.all"/> to get screen indices. They are different than in Windows Settings.
            </param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMMove,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen,System.String,System.Int32)">
            <summary>
            Adds a mouse move trigger.
            </summary>
            <param name="move"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags,System.String,System.Int32)"/>.</param>
            <param name="flags"></param>
            <param name="screen">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMEdge,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen,System.String,System.Int32)"/>.</param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTriggers.EdgeMoveDetector_">
            <summary>
            Detects trigger events of types Edge and Move.
            </summary>
            <remarks>
            Used in the hook server, to avoid sending all mouse move events to clients, which would use 2 or more times more CPU, eg 0.9% instead of 0.45%. Tested: raw input uses slightly less CPU.
            </remarks>
        </member>
        <member name="T:Au.Triggers.MouseTriggers.EdgeMoveDetector_._State">
            <summary>
            State data set by previous events.
            </summary>
        </member>
        <member name="M:Au.Triggers.MouseTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTriggerArgs">
            <summary>
            Arguments for actions of mouse triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.TriggerBase">
            
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Window">
            <summary>
            The active window (Edge and Move triggers) or the mouse window (Click and Wheel triggers).
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Mod">
            <summary>
            The pressed modifier keys.
            </summary>
            <remarks>
            Can be useful when the trigger ignores modifiers. For example <i>modKeys</i> is "?" or "Shift?".
            </remarks>
        </member>
        <member name="M:Au.Triggers.MouseTriggerArgs.#ctor(Au.Triggers.MouseTrigger,Au.wnd,Au.Types.KMod)">
            
        </member>
        <member name="T:Au.Triggers.TMKind">
            <summary>
            What kind of mouse triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TMClick">
            <summary>
            Button for mouse click triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TMWheel">
            <summary>
            Mouse wheel direction for mouse wheel triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TMEdge">
            <summary>
            Screen edge for mouse edge triggers.
            </summary>
            <remarks>
            To activate a screen edge trigger, the user touches a screen edge with the mouse pointer.
            Each screen edge is divided into 3 parts: 1 - center 50%; 2 - left or top 25%; 3 - right or bottom 25%. Constants like <b>TopInCenter50</b> specify an edge and part; the trigger works only in that part of that edge. Constants like <b>Top</b> specify just an edge; the trigger works in all parts of that edge.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TMMove">
            <summary>
            Mouse movement directions for mouse move triggers.
            </summary>
            <remarks>
            To activate a mouse move trigger, the user quickly moves the mouse pointer to the specified direction and back.
            The screen is divided into 3 parts: 1 - center 50%; 2 - left or top 25%; 3 - right or bottom 25%. Constants like <b>UpDownInCenter50</b> specify a direction and screen part; the trigger works only in that screen part. Constants like <b>UpDown</b> specify just a direction; the trigger works in whole screen.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TMScreen">
            <summary>
            Screen index for mouse triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWFlags">
            <summary>
            Flags of window triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWFlags.RunAtStartup">
            <summary>
            Run the action when <see cref="M:Au.Triggers.ActionTriggers.Run"/> called, if the window then is active (for <b>ActiveOnce</b> etc triggers) or visible (for <b>VisibleOnce</b> etc triggers).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWFlags.LaterCallFunc">
            <summary>
            When using the <i>later</i> parameter, call the currently active <b>Triggers.FuncOf</b> functions on "later" events too.
            If the function returns false, the action will not run.
            The function runs synchronously in the same thread that called <see cref="M:Au.Triggers.ActionTriggers.Run"/>. The action runs asynchronously in another thread, which is slower to start.
            As always, <b>Triggers.FuncOf</b> functions must not contain slow code; should take less than 10 ms.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWEvent">
            <summary>
            Events for window triggers.
            </summary>
            <remarks>
            Cloaked windows are considered invisible. See <see cref="P:Au.wnd.IsCloaked"/>.
            </remarks>
        </member>
        <member name="F:Au.Triggers.TWEvent.Active">
            <summary>
            When the specified window becomes active (each time).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.ActiveOnce">
            <summary>
            When the specified window becomes active the first time in the trigger's life.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.ActiveNew">
            <summary>
            When the specified window is created and then becomes active.
            The same as <see cref="F:Au.Triggers.TWEvent.ActiveOnce"/>, but windows created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/> are ignored.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.Visible">
            <summary>
            When the specified window becomes visible (each time).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.VisibleOnce">
            <summary>
            When the specified window becomes visible the first time in the trigger's life.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.VisibleNew">
            <summary>
            When the specified window is created and then becomes visible.
            The same as <see cref="F:Au.Triggers.TWEvent.VisibleOnce"/>, but windows created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/> are ignored.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWLater">
            <summary>
            Window events for the <i>later</i> parameter of window triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Name">
            <summary>
            Name changed.
            This event occurs only when the window is active. If name changed while inactive - when activated.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Destroyed">
            <summary>
            Destroyed (closed).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Active">
            <summary>
            Activated (became the foreground window).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Inactive">
            <summary>
            Deactivated (lose the foreground window status).
            This event also occurs when closing the window, if it was active; then the window possibly is already destroyed, and the handle is invalid.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Visible">
            <summary>
            Became visible.
            The window can be new or was temporarily hidden.
            This event occurs when changed the <see cref="P:Au.wnd.IsVisible"/> property, and not when changed the <see cref="P:Au.wnd.IsCloaked"/> property, therefore the window is not actually visible if cloaked.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Invisible">
            <summary>
            Became invisible.
            This event also occurs when closing the window, if it was visible; then the window possibly is already destroyed, and the handle is invalid.
            This event occurs when changed the <see cref="P:Au.wnd.IsVisible"/> property, and not when changed the <see cref="P:Au.wnd.IsCloaked"/> property.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Cloaked">
            <summary>
            The window has been cloaked. See <see cref="P:Au.wnd.IsCloaked"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Uncloaked">
            <summary>
            The window has been uncloaked. See <see cref="P:Au.wnd.IsCloaked"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Minimized">
            <summary>
            The window has been minimized.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Unminimized">
            <summary>
            The window has been restored from the minimized state.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTrigger">
            <summary>
            Represents a window trigger.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Window[TWEvent.ActiveNew, "Window name"] = o => print.it(o.Window);
            var v = Triggers.Window.Last; //v is the new WindowTrigger. Rarely used.
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.WindowTrigger.TypeString">
            <summary>
            Returns a trigger type string, like "Window.ActiveNew".
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggers">
            <summary>
            Window triggers.
            </summary>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            var wt = Triggers.Window; //wt is a WindowTriggers instance
            wt[TWEvent.ActiveNew, "Window name"] = o => print.it(o.Window);
            wt[TWEvent.Visible, "Window2 name"] = o => print.it(o.Window);
            Triggers.Run();
            ]]></code>
            More examples: <see cref="T:Au.Triggers.ActionTriggers"/>.
            </example>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Item(Au.Triggers.TWEvent,System.String,System.String,Au.Types.WOwner,System.Func{Au.wnd,System.Boolean},Au.Types.WContains,Au.Triggers.TWFlags,Au.Triggers.TWLater,System.String,System.Int32)">
            <summary>
            Adds a window trigger and its action.
            </summary>
            <param name="winEvent">Trigger event.</param>
            <param name="name">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="cn">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="of">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="also">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="contains">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="flags">Trigger flags.</param>
            <param name="later">
            Can optionally specify one or more additional events.
            This starts to work when the primary trigger is activated, and works only for that window.
            For example, to be notified when the window is closed or renamed, specify <c>later: TWLater.Destroyed | TWLater.Name</c>.
            When a "later" event occurs, the trigger action is executed. The <see cref="P:Au.Triggers.WindowTriggerArgs.Later"/> property then is that event; it is 0 when it is the primary trigger.
            The "later" trigers are not disabled when primary triggers are disabled.
            </param>
            <param name="f_">[](xref:caller_info)</param>
            <param name="l_">[](xref:caller_info)</param>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <seealso cref="P:Au.Triggers.WindowTriggers.Last"/>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Item(Au.Triggers.TWEvent,Au.wndFinder,Au.Triggers.TWFlags,Au.Triggers.TWLater,System.String,System.Int32)">
            <summary>
            Adds a window trigger and its action.
            </summary>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <see cref="M:Au.Triggers.ActionTriggers.Run"/> was called, until it returns.</exception>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.Timer_">
            <summary>
            Called from the message loop every 250 or less ms.
            </summary>
        </member>
        <member name="F:Au.Triggers.WindowTriggers._enumWinProc">
            <summary>
            Callback of EnumWindows used by Timer_ to get visible windows.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._VisibleAddedRemoved">
            <summary>
            Called by Timer_ when it swaps _aVisible with _aVisibleOld and calls EnumWindows to populate _aVisible with visible windows.
            Finds what windows became visible or invisible and runs Visible/Invisible triggers for them.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._HookProc(Au.Types.HookData.WinEvent)">
            <summary>
            WinEventHook hook procedure.
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._Proc(Au.Triggers.TWLater,Au.wnd,Au.Triggers.WindowTriggers._ProcCaller,System.String)">
            <summary>
            Processes events for main triggers (active, visible) and most "later" triggers.
            Called from hook (_HookProc), timer (Timer_), at startup (StartStop) and SimulateActiveNew/SimulateVisibleNew.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._ProcLater(Au.Triggers.TWLater,Au.wnd,System.Int32,System.String)">
            <summary>
            Called to process "later" events from _Proc and timer.
            iTriggered is w index in _aTriggered, or -1 if not found, or -2 (default) to let this func find.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.SimulateActiveNew(Au.wnd)">
            <summary>
            Simulates event "activated new window" as if the the specified window is that window.
            </summary>
            <exception cref="T:System.InvalidOperationException">Cannot be before or after <see cref="M:Au.Triggers.ActionTriggers.Run"/>.</exception>
            <remarks>
            This function usually is used to run <b>ActiveNew</b> triggers for a window created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/>. Here "run triggers" means "compare window properties etc with those specified in triggers and run actions of triggers that match". Normally such triggers don't run because the window is considered old. This function runs triggers as it was a new window. Triggers like <b>ActiveNew</b> and <b>ActiveOnce</b> will run once, as usually.
            This function must be called while the main triggers thread is in <see cref="M:Au.Triggers.ActionTriggers.Run"/>, for example from another trigger action. It is asynchronous (does not wait).
            If you call this function from another trigger action (hotkey etc), make sure the window trigger action runs in another thread or can be queed. Else both actions cannot run simultaneously. See example.
            </remarks>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            Triggers.Options.ThreadNew(true);
            Triggers.Window[TWEvent.ActiveNew, "* Notepad"] = o => o.Window.Resize(500, 200);
            Triggers.Hotkey["Ctrl+T"] = o => Triggers.Window.SimulateActiveNew(wnd.active);
            Triggers.Hotkey["Ctrl+Alt+T"] = o => Triggers.Stop();
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.SimulateVisibleNew(Au.wnd)">
            <summary>
            Simulates event "visible new window" as if the specified window is that window.
            Similar to <see cref="M:Au.Triggers.WindowTriggers.SimulateActiveNew(Au.wnd)"/>.
            </summary>
            <param name="w"></param>
            <exception cref="T:System.InvalidOperationException">Cannot be before or after <see cref="M:Au.Triggers.ActionTriggers.Run"/>.</exception>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.LogEvents(System.Boolean,System.Func{Au.wnd,System.Boolean})">
            <summary>
            Starts or stops to log (write in output) window events that can help to create or debug window triggers.
            </summary>
            <param name="on">Start (true) or stop.</param>
            <param name="skip">An optional callback function that can be used to reduce noise, eg skip tooltip windows. Return true to skip that window.</param>
            <remarks>
            For primary trigger events is logged this info:
            <ol>
            <li>Time milliseconds. Shows only the remainder of dividing by 10 seconds, therefore it starts from 0 again when reached 9999 (9 seconds and 999 milliseconds).</li>
            <li>Event (see <see cref="T:Au.Triggers.TWLater"/>).</li>
            <li>Letters for window state etc:
            <ul>
            <li>A - the window is active.</li>
            <li>H - the window is invisible (!<see cref="P:Au.wnd.IsVisible"/>).</li>
            <li>C - the window is cloaked (<see cref="P:Au.wnd.IsCloaked"/>).</li>
            <li>O - the window is considered old, ie created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/>.</li>
            <li>T - the even has been detected using a timer, which means slower response time. Else detected using a hook.</li>
            </ul>
            </li>
            <li>Window (handle, class, name, program, rectangle).</li>
            </ol>
            
            Colors are used for window event types used for primary triggers: blue if activated; green if became visible; yellow if name changed.
            For "later" events is logged time, event and window. Black, tab-indented. Only events that are specified in triggers.
            When a trigger is activated, the event type is red.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Window.LogEvents(true, o => 0 != o.ClassNameIs("*tooltip*", "SysShadow", "#32774", "TaskList*"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._LogEvent(Au.Triggers.TWLater,Au.wnd,Au.Triggers.WindowTriggers._ProcCaller,System.Boolean)">
            <summary>
            Called by _Proc.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggers._WndArray">
            <summary>
            For _aTriggered, _aVisible and _aVisibleOld we use resizable array, not List.
            We access elements by index in time-critical code. With List it is much slower.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggerArgs">
            <summary>
            Arguments for actions of window triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Trigger">
            <summary>
            The trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.TriggerBase">
            
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Window">
            <summary>
            The window.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Later">
            <summary>
            The "later" event, or 0 if it is the primary trigger (ActiveNew etc). See example.
            </summary>
            <example>
            Note: the Triggers in examples is a field or property like <c>readonly ActionTriggers Triggers = new();</c>.
            <code><![CDATA[
            Triggers.Window[TWEvent.ActiveOnce, "*- Notepad", later: TWLater.Active | TWLater.Inactive] = o => print.it(o.Later, o.Window);
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggerArgs.#ctor(Au.Triggers.WindowTrigger,Au.wnd,Au.Triggers.TWLater)">
            
        </member>
        <member name="T:Au.elm">
            <summary>
            UI element.
            Finds UI elements in windows and web pages. Clicks, gets properties, etc.
            </summary>
            <remarks>
            UI elements are user interface (UI) parts that are accessible through programming interfaces (API). For example buttons, links, list items. This class can find them, get properties, click, etc. Web pages and many other windows don't use controls but support UI elements. But not all UI objects are accessible.
            
            An <b>elm</b> variable contains a COM interface pointer (<msdn>IAccessible</msdn> or other) and uses methods of that interface or/and related API.
            
            <b>elm</b> functions that get properties don't throw exception when the COM etc method failed (returned an error code of <b>HRESULT</b> type). Then they return "" (string properties), 0, false, null or empty collection, depending on return type. Applications implement UI elements differently, often with bugs, and their COM interface functions return a variety of error codes. It's impossible to reliably detect whether the error code means a serious error or the property is merely unavailable. These <b>elm</b> functions also set the last error code of this thread = the return value (<b>HRESULT</b>) of the COM function, and callers can use <see cref="T:Au.lastError"/> to get it. If <b>lastError.code</b> returns 1 (<b>S_FALSE</b>), in most cases it's not an error, just the property is unavailable. On error it will probably be a negative error code.
            
            You can dispose <b>elm</b> variables to release the COM object, but it is not necessary (GC will do it later).
            
            An <b>elm</b> variable cannot be used in multiple threads. Only <b>Dispose</b> can be called in any thread.
            
            UI elements are implemented and live in their applications. This class just communicates with them.
            
            Many applications have various problems with their UI elements: bugs, incorrect/nonstandard/partial implementation, or initially disabled. This class implements workarounds for known problems, where possible.
            
            <a data-toggle="collapse" data-target="#collapse1" aria-expanded="false" aria-controls="collapse1">Known problematic applications</a>
            <div class="collapse" id="collapse1">
            <table>
            <tr>
            <th>Application</th>
            <th>Problems</th>
            </tr>
            <tr>
             <td>Chrome web browser. Also Opera and other apps that use Chrome code. Window class name is like "Chrome_WidgetWin_1".</td>
             <td>
              <ol>
               <li>Web page UI elements initially are disabled(missing). Workarounds:
                <ul>
                 <li>Functions Find, Wait and FindAll enable it if used role prefix "web:" or "chrome:". Functions FromXY, FromMouse and Focused enable it if window class name starts with "Chrome". However Chrome does it lazily, therefore first time the functions often get wrong UI element. Note: this auto-enabing may fail with future Chrome versions.</li>
                 <li>Start Chrome with command line --force-renderer-accessibility.</li>
                 <li>In the future the script editor will have an option to enable Chrome UI elements when it starts.</li>
                </ul>
               </li>
               <li>Some new web browser versions add new features or bugs that break something.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Firefox web browser.</td>
             <td>
              <ol>
               <li>By default, the Find function is about 50 times slower than it could be. Also for this reason the Wait function consumes much CPU. And HTML attributes may be unavailable. See <see cref="F:Au.Types.EFFlags.NotInProc"/>. Workaround: disable the Firefox multiprocess feature: set system environment variable MOZ_FORCE_DISABLE_E10S=1 and restart Firefox. Note: Firefox may remove this option in the future. If this does not work, google how to disable Firefox multiprocess. Or use Chrome instead.</li>
               <li>When Firefox starts, its web page UI elements are unavailable. It creates them only when somebody asks (eg function Find), but does it lazily, and Find at first fails. Workaround: use Wait, not Find.</li>
               <li>Ocassionally Firefox briefly turns off its web page UI elements. Workaround: use Wait, not Find. With other web browsers also it's better to use Wait.</li>
               <li>Some new web browser versions add new features or bugs that break something.</li>
              </ol>
             </td>
            </tr>
            <tr>
            <td>JavaFX and other applications that don't have accessible objects but have UI Automation elements.</td>
             <td>
              <ol>
               <li>To find UI elements in these applications, need flag <see cref="F:Au.Types.EFFlags.UIA"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Java applications that use AWT/Swing. Window class name starts with "SunAwt".</td>
             <td>
              <ol>
               <li>Not supported on 32-bit OS.</li>
               <li>Must be enabled Java Access Bridge (JAB).<br/>If JAB is disabled or does not work, the "Find UI element" tool shows an "enable" link when you try to capture something in a Java window. Or you can enable JAB in Control Panel -> Ease of Access Center -> Use the computer without a display. Or use jabswitch.exe. Then restart Java apps. Also may need to restart apps that tried to use Java UI elements.</li>
               <li>Your process must have the same 32/64 bitness as the installed Java. To remove this limitation, install Java 32-bit and 64-bit (they coexist).</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>OpenOffice.</td>
             <td>
              <ol>
               <li>Often crashes after using UI elements, usually when closing. Noticed in OpenOffice 4.1.4; may be fixed in newer versions.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>LibreOffice.</td>
             <td>
              <ol>
               <li>UI elements are unavailable unless this process is 32-bit (when LibreOffice is 64-bit). Also need flag <see cref="F:Au.Types.EFFlags.NotInProc"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Some controls.</td>
             <td>
              <ol>
               <li>UI elements of some controls are not connected to the UI element of the parent control. Then Find cannot find them if searches in whole window.<br/>Workaround: search only in that control. For example, use <i>prop</i> <c>"class"</c> or <c>"id"</c>. If it's a web browser control, use role prefix <c>"web:"</c>. Or find the control with <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/> and search in it. Or use <see cref="M:Au.elmFinder.Find(Au.wnd,Au.wndChildFinder)"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Some controls with flag <see cref="F:Au.Types.EFFlags.NotInProc"/>.</td>
             <td>
              UI elements of many standard Windows controls have bugs when they are retrieved without loading dll into the target process (see <see cref="F:Au.Types.EFFlags.NotInProc"/>). Known bugs:
              <ol>
               <li>Toolbar buttons don't have Name in some cases.</li>
               <li><see cref="M:Au.elm.Focus(System.Boolean)"/> and <see cref="M:Au.elm.Select(Au.Types.ESelect)"/> often don't work properly.</li>
              </ol>
              Workarounds: Don't use <see cref="F:Au.Types.EFFlags.NotInProc"/>. Or use <see cref="F:Au.Types.EFFlags.UIA"/>.
             </td>
            </tr>
            <tr>
             <td>When cannot load dll into the target process. For example Windows Store apps.</td>
             <td>
              <ol>
               <li>Function Find is much slower. Function Wait then consumes much more CPU. More info: <see cref="F:Au.Types.EFFlags.NotInProc"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Processes of a different 32/64 bitness than this process.</td>
             <td>
              <ol>
               <li>To load the dll is used rundll32.exe, which makes slower by about 50 ms first time.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>DPI-scaled windows.</td>
             <td>
              <ol>
               <li>Currently this library does not support auto-scaled windows when using high DPI (text size 125%, 150% or more). If the target process is auto-scaled and this process isn't (or vice versa, or they have a different scaling factor), most coordinate-related functions don't work properly. For example, they get wrong UI element rectangles.</li>
              </ol>
             </td>
            </tr>
            </table>
            </div>
            </remarks>
            <example>
            Click link "Example" in Chrome.
            <code><![CDATA[
            var w = +wnd.find("* Chrome");
            var e = +elm.find(w, "web:LINK", "Example");
            e.DoAction();
            ]]></code>
            Click a link, wait for new web page, click a link in it.
            <code><![CDATA[
            var w = +wnd.find("* Chrome");
            var e = elm.wait(1, w, "web:LINK", "Link 1");
            e.DoActionAndWaitForNewWebPage();
            e = elm.wait(10, w, "web:LINK", "Link 2");
            e.DoActionAndWaitForNewWebPage();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.#ctor(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates elm from IAccessible and child id.
            By default does not AddRef.
            iacc must not be 0.
            </summary>
        </member>
        <member name="M:Au.elm.#ctor(Au.Types.Cpp.Cpp_Acc,System.Boolean)">
            <summary>
            Creates elm from Cpp_Acc.
            By default does not AddRef.
            x.acc must not be 0.
            </summary>
        </member>
        <member name="M:Au.elm._Set(System.IntPtr,System.Int32,Au.elm.Misc_,System.Boolean)">
            <summary>
            Sets fields.
            _iacc must be 0, iacc not 0.
            </summary>
        </member>
        <member name="M:Au.elm.Dispose">
            <summary>
            Releases COM object and clears this variable.
            </summary>
        </member>
        <member name="M:Au.elm.Finalize">
            
        </member>
        <member name="P:Au.elm.SimpleElementId">
            <summary>
            Gets or changes simple element id, also known as child id.
            </summary>
            <remarks>
            Most UI elements are not simple elements. Then this property is 0.
            Often (but not always) this property is the 1-based item index in parent. For example LISTITEM in LIST.
            The 'set' function sometimes can be used as a fast alternative to <see cref="M:Au.elm.Navigate(System.String,System.Double)"/>. It modifies only this variable. It does not check whether the value is valid.
            Simple elements cannot have child elements.
            </remarks>
        </member>
        <member name="P:Au.elm.MiscFlags">
            <summary>
            Returns some additional info about this variable, such as how the UI element was retrieved (inproc, UIA, Java).
            </summary>
        </member>
        <member name="P:Au.elm.Level">
            <summary>
            Gets or sets indentation level for <see cref="M:Au.elm.ToString"/>.
            </summary>
            <remarks>
            When <b>find</b> or similar function finds a UI element, it sets this property of the <b>elm</b> variable. If <b>fromXY</b> etc, it is 0 (unknown).
            When searching in a window, at level 0 are direct children of the WINDOW. When searching in controls (specified class or id), at level 0 is the control; however if used path, at level 0 are direct children. When searching in <b>elm</b>, at level 0 are its direct children. When searching in web page (role prefix <c>"web:"</c> etc), at level 0 is the web page (role DOCUMENT or PANE).
            </remarks>
        </member>
        <member name="P:Au.elm._Disposed">
            <summary>
            Returns true if this variable is disposed.
            </summary>
        </member>
        <member name="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)">
            <summary>
            Gets UI element of window or control. Or some its standard part - client area, titlebar etc.
            </summary>
            <param name="w">Window or control.</param>
            <param name="objid">Window part id. Default EObjid.WINDOW. Also can be a custom id supported by that window, cast int to EObjid.</param>
            <param name="flags">Flags.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <exception cref="T:System.ArgumentException"><i>objid</i> is QUERYCLASSNAMEIDX or NATIVEOM.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromWindow</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.fromXY(Au.Types.POINT,Au.Types.EXYFlags)">
            <summary>
            Gets UI element from point.
            </summary>
            <param name="p">
            Coordinates.
            Tip: To specify coordinates relative to the right, bottom, work area or a non-primary screen, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen,System.Boolean,System.Boolean)"/>, like in the example.
            </param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </remarks>
            <example>
            Find object at 100 200.
            <code><![CDATA[
            var e = elm.FromXY((100, 200));
            print.it(e);
            ]]></code>
            
            Find object at 50 from left and 100 from bottom of the work area.
            <code><![CDATA[
            var e = elm.FromXY(Coord.Normalize(50, Coord.Reverse(100), true));
            print.it(e);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.fromMouse(Au.Types.EXYFlags)">
            <summary>
            Gets UI element from mouse cursor (pointer) position.
            </summary>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.focused(System.Boolean)">
            <summary>
            Gets the keyboard-focused UI element.
            Returns null if fails.
            </summary>
            <param name="useUIAutomation">
            Use UI Automation API.
            Need this with windows that don't support accessible objects but support UI Automation elements. Can be used with most other windows too.
            More info: <see cref="F:Au.Types.EFFlags.UIA"/>.
            </param>
        </member>
        <member name="M:Au.elm.fromEvent(Au.wnd,Au.Types.EObjid,System.Int32)">
            <summary>
            Gets the UI element that generated the event that is currently being processed by the callback function used with API <msdn>SetWinEventHook</msdn> or <see cref="T:Au.More.WinEventHook"/>.
            Returns null if failed. Suports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="w"></param>
            <param name="idObject"></param>
            <param name="idChild"></param>
            <remarks>
            The parameters are of the callback function.
            Uses API <msdn>AccessibleObjectFromEvent</msdn>.
            Often fails because the object already does not exist, because the callback function is called asynchronously, especially when the event is OBJECT_DESTROY, OBJECT_HIDE, SYSTEM_*END.
            Returns null if failed. Always check the return value, to avoid NullReferenceException. An exception in the callback function kills this process.
            </remarks>
        </member>
        <member name="T:Au.elm._FuncId">
            <summary>
            Used only for debug.
            </summary>
        </member>
        <member name="M:Au.elm._Hresult(Au.elm._FuncId,System.Int32)">
            <summary>
            Calls SetLastError and returns hr.
            In Debug config also outputs error in red.
            If hr looks like not an error but just the property or action is unavailable, changes it to S_FALSE and does not show error. These are: S_FALSE, DISP_E_MEMBERNOTFOUND, E_NOTIMPL.
            _FuncId also can be char, like (_FuncId)'n' for name.
            </summary>
        </member>
        <member name="M:Au.elm.ToString">
            <summary>
            Formats string from main properties of this UI element.
            </summary>
            <remarks>
            The string starts with role. Other properties have format like <c>x="value"</c>, where x is a property character like with <see cref="M:Au.elm.GetProperties(System.String,Au.Types.EProperties@)"/>; character e is <see cref="P:Au.elm.SimpleElementId"/>. HTML attributes have format <c>@name="value"</c>. In string values are used C# escape sequences, for example \r\n for new line.
            Indentation depends on <see cref="P:Au.elm.Level"/>.
            </remarks>
            <seealso cref="M:Au.elm.printAll(Au.wnd,System.String,Au.Types.EFFlags,System.String)"/>
        </member>
        <member name="M:Au.elm.printAll(Au.wnd,System.String,Au.Types.EFFlags,System.String)">
            <summary>
            Displays properties of all found UI elements of window w.
            </summary>
            <remarks>
            Uses <see cref="M:Au.elm.ToString"/>.
            Catches exceptions. On exception writes to the output: <c>$"!exception! exceptionType exceptionMessage"</c>.
            Parameters are of <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            By default skips invisible objects and objects in menus. Use flags to include them.
            Chrome web page UI elements normally are disabled (missing) when it starts. Use role prefix <c>"web:"</c> or <c>"chrome:"</c> to enable. See example.
            </remarks>
            <example>
            Displays visible UI elements in Chrome web page.
            <code><![CDATA[
            print.clear();
            var w = +wnd.find("* Chrome");
            print.it("---- all ----");
            elm.printAll(w, "web:");
            print.it("---- links ----");
            elm.printAll(w, "web:LINK");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)">
            <summary>
            Finds a UI element in window.
            Returns the found UI element. Returns null if not found.
            </summary>
            <param name="w">Window or control that contains the UI element.</param>
            <param name="role">
            UI element role, like <c>"LINK"</c>. Or path, like <c>"ROLE/ROLE/ROLE"</c>.
            Can have prefix <c>"web:"</c>, <c>"firefox:"</c> or <c>"chrome:"</c> which means "search only in web page" and enables Chrome UI elements.
            Case-sensitive. Not wildcard. null means 'can be any'. Cannot be "".
            More info in Remarks.
            </param>
            <param name="name">
            UI element name (<see cref="P:Au.elm.Name"/>).
            String format: [](xref:wildcard_expression).
            null means 'any'. "" means 'empty or unavailable'.
            </param>
            <param name="prop">
            Other UI element properties and search settings.
            Example: <c>"description=xxx\0 @href=yyy"</c>.
            More info in Remarks.
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching UI element. Let it return true if this is the wanted UI element.
            Example: the UI element must contain point x y: <c>o => o.GetRect(out var r, o.WndTopLevel) &amp;&amp; r.Contains(266, 33)</c>
            </param>
            <param name="skip">
            0-based index of matching UI element.
            For example, if 1, the function skips the first matching UI element and returns the second.
            </param>
            <param name="navig">If not null, the specified object is an intermediate object. After finding it, call <see cref="M:Au.elm.Navigate(System.String,System.Double)"/> with this string and return its result.</param>
            <param name="controls">
            Defines child controls where to search.
            This is an alternative for class/id in <i>prop</i>. Allows to specify more control properties. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </param>
            
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid.
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - <i>navig</i> string is invalid.
            - <i>flags</i> has <see cref="F:Au.Types.EFFlags.UIA"/> when searching in web page (role prefix <c>"web:"</c> etc).
            </exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            
            <remarks>
            To create code for this function, use dialog "Find UI element".
            
            Walks the tree of UI elements, until finds a matching UI element.
            
            Uses <see cref="T:Au.elmFinder"/>. You can use it directly. See example.
            
            In wildcard expressions supports PCRE regular expressions (prefix <c>"**r "</c>) but not .NET regular expressions (prefix <c>"**R "</c>). They are similar.
            
            To find web page UI elements usually it's better to use <see cref="M:Au.elm.wait(System.Double,Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)"/> instead, it's more reliable.
            
            More info in <see cref="T:Au.elm"/> topic.
            
            ##### About the <i>role</i> parameter
            
            Can be standard role (see <see cref="T:Au.Types.ERole"/>) like <c>"LINK"</c> or custom role like <c>"div"</c>. More info: <see cref="P:Au.elm.Role"/>.
            
            Can have a prefix:
            - <c>"web:"</c> - search only in the visible web page, not in whole window. Examples: <c>"web:LINK"</c>, <c>"web:/LIST/LISTITEM/LINK"</c>.\
              Supports Firefox, Chrome, Internet Explorer (IE) and apps that use their code. With other windows, searches in the first found visible UI element that has DOCUMENT role.\
              Tip: To search only NOT in web pages, use <i>prop</i> <c>"notin=DOCUMENT"</c> (Chrome, Firefox) or <c>"notin=PANE"</c> (IE).
            - <c>"firefox:"</c> - search only in the visible web page of Firefox or Firefox-based web browser. If w window class name starts with "Mozilla", can be used <c>"web:"</c> instead.
            - <c>"chrome:"</c> - search only in the visible web page of Chrome or Chrome-based web browser. If w window class name starts with "Chrome", can be used <c>"web:"</c> instead.
            
            <note>Chrome web page UI elements normally are disabled (don't exist). Use prefix <c>"web:"</c> or <c>"chrome:"</c> to enable.</note>
            
            Prefix cannot be used:
            - if <i>prop</i> contains <c>"id"</c> or <c>"class"</c>;
            - with flag <see cref="F:Au.Types.EFFlags.UIA"/>;
            - with the non-static <b>Find</b> overload (searching in a UI element).
            
            Can be path consisting of roles separated by "/". Examples:
            - <c>"web:DOCUMENT/div/LIST/LISTITEM/LINK"</c> - find LINK using its full path in web page.
            - <c>"web:/div/LIST//LINK"</c> - the empty parts mean 'any role'. For example don't need to specify DOCUMENT because in web pages the first part is always DOCUMENT (Firefox, Chrome) or PANE (IE).
            - <c>"web:/div/LIST[4]/LISTITEM[-1]/LINK"</c> - the 4 is 1-based index of div child from which to start searching (4-th, then 3-th, 5-th and so on). It can make faster. Negative means 'index from end', for example use -1 to search in reverse order. Flag <see cref="F:Au.Types.EFFlags.Reverse"/> is not applied to path parts with an index. If index is invalid, will use the nearest valid index.
            - <c>"web:/div/LIST[4!]/LISTITEM[-1!]/LINK"</c> - like the above, but the LIST must be exactly 4-th child (don't search 3-th, 5-th etc) and the LISTITEM must be the last child. This can be useful when waiting (uses less CPU), however useless if UI element indices in the window or web page change often.
            - <c>"web://[4]/[-1!]/[2]"</c> - index without role.
            - <c>"CLIENT/WINDOW/TREE/TREEITEM[-1]"</c> - path in window or control. The first path part is a direct child UI element of the WINDOW UI element of the window/control. The WINDOW UI element itself is not included in the search; if you need it, instead use <see cref="M:Au.elm.fromWindow(Au.wnd,Au.Types.EObjid,Au.Types.EWFlags)"/>.
            
            ##### About the <i>prop</i> parameter
            
            Format: one or more <c>"name=value"</c>, separated with <c>"\0"</c> or <c>"\0 "</c>, like <c>"description=xxx\0 @href=yyy"</c>. Names must match case. Values of string properties are wildcard expressions.
            
            - <c>"class"</c> - search only in child controls that have this class name (see <see cref="P:Au.wnd.ClassName"/>).
            Cannot be used when searching in a UI element.
            - <c>"id"</c> - search only in child controls that have this id (see <see cref="P:Au.wnd.ControlId"/>). If the value is not a number - Windows Forms control name (see <see cref="P:Au.wnd.NameWinforms"/>); case-sensitive, not wildcard.
            Cannot be used when searching in a UI element.
            - <c>"value"</c> - <see cref="P:Au.elm.Value"/>.
            - <c>"description"</c> - <see cref="P:Au.elm.Description"/>.
            - <c>"state"</c> - <see cref="P:Au.elm.State"/>. List of states the UI element must have and/or not have.
            Example: <c>"state=CHECKED, FOCUSABLE, !DISABLED"</c>.
            Example: <c>"state=0x100010, !0x1"</c>.
            Will find UI element that has all states without <c>"!"</c> prefix and does not have any of states with <c>"!"</c> prefix.
            - <c>"rect"</c> - <see cref="P:Au.elm.Rect"/>. Can be specified left, top, width and/or height, using <see cref="M:Au.Types.RECT.ToString"/> format.
            Example: <c>"rect={L=1155 T=1182 W=132 H=13}"</c>.
            Example: <c>"rect={W=132 T=1182}"</c>.
            The L T coordinates are relative to the primary screen.
            - <c>"level"</c> - level (see <see cref="P:Au.elm.Level"/>) at which the UI element can be found. Can be exact level, or minimal and maximal level separated by space.
            The default value is 0 1000.
            Alternatively you can use path in role, like <c>"////LINK"</c>.
            - <c>"elem"</c> - <see cref="P:Au.elm.SimpleElementId"/>.
            - <c>"action"</c> - <see cref="P:Au.elm.DefaultAction"/>.
            - <c>"key"</c> - <see cref="P:Au.elm.KeyboardShortcut"/>.
            - <c>"help"</c> - <see cref="P:Au.elm.Help"/>.
            - <c>"uiaid"</c> - <see cref="P:Au.elm.UiaId"/>.
            - <c>"maxcc"</c> - when searching, skip children of UI elements that have more than this number of direct children. It can make faster.
            The default value is 10000. It also prevents hanging or crashing when a UI element in the object tree has large number of children. For example OpenOffice Calc TABLE has one billion children.
            - <c>"notin"</c> - when searching, skip children of UI elements that have these roles. It can make faster.
            Example: <c>"notin=TREE,LIST,TOOLBAR"</c>.
            Roles in the list must be separated with <c>","</c> or <c>", "</c>. Case-sensitive, not wildcard. See also: <see cref="F:Au.Types.EFFlags.MenuToo"/>.
            - <c>"@attr"</c> - <see cref="M:Au.elm.HtmlAttribute(System.String)"/>. Here "attr" is any attribute name. Example: <c>"@id=example"</c>.
            </remarks>
            <example>
            Find link "Example" in web page, and click. Throw <b>NotFoundException</b> if not found.
            <code><![CDATA[
            var w = +wnd.find("* Chrome");
            var e = +elm.find(w, "web:LINK", "Example");
            e.DoAction();
            ]]></code>
            Try to find link "Example" in web page. Return if not found.
            <code><![CDATA[
            var w = +wnd.find("* Chrome");
            var e = elm.find(w, "web:LINK", "Example");
            if(e == null) { print.it("not found"); return; }
            e.DoAction();
            ]]></code>
            Use <see cref="T:Au.elmFinder"/>.
            <code><![CDATA[
            var w = +wnd.find("* Chrome");
            var f = new elmFinder("BUTTON", "Example");
            if(!f.Find(w)) { print.it("not found"); return; }
            elm e = f.Result;
            e.DoAction();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.Find(System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds and returns a descendant UI element of this UI element.
            Returns null if not found.
            More info: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">Exceptions of other overload, plus:
            - <i>flags</i> has <see cref="F:Au.Types.EFFlags.UIA"/>.
            - <see cref="P:Au.elm.SimpleElementId"/> is not 0.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.elm.wait(System.Double,Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds UI element (UI element) in window. Waits until the UI element is found or the given time expires.
            More info: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns the found UI element. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="M:Au.elm.Wait(System.Double,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds a descendant UI element of this UI element. Waits until the UI element is found or the given time expires.
            More info: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns the found UI element. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"/>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="M:Au.elm.findAll(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean})">
            <summary>
            Finds all matching UI elements in window.
            More info: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
            <returns>Array of 0 or more elements.</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:Au.Types.AuException"/>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = +wnd.find(null, "Shell_TrayWnd");
            foreach(var e in elm.findAll(w, "BUTTON", prop: "level=7")) print.it(e);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.FindAll(System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean})">
            <summary>
            Finds all matching descendant UI elements of this UI element.
            More info: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
            <returns>Array of 0 or more elements.</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuException"/>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = +wnd.find(null, "Shell_TrayWnd");
            var etb = +elm.find(w, "TOOLBAR", "Running applications");
            foreach(var e in etb.FindAll("BUTTON", prop: "level=0")) print.it(e);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.op_UnaryPlus(Au.elm)">
            <summary>
            Returns the same value if it is not null. Else throws <see cref="T:Au.Types.NotFoundException"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = +wnd.find("Example");
            var e1 = +elm.find(w, "web:LINK", "Example");
            var e2 = +elm.find(w, ...)?.Find(...);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.elm.WndContainer">
            <summary>
            Gets the container window or control of this UI element.
            </summary>
            <remarks>
            Returns default(wnd) if failed. Supports <see cref="T:Au.lastError"/>.
            All objects must support this property, but some have bugs and can fail or return a wrong window.
            Uses API <msdn>WindowFromAccessibleObject</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.WndTopLevel">
            <summary>
            Gets the top-level window that contains this UI element.
            </summary>
            <remarks>
            Returns default(wnd) if failed. Supports <see cref="T:Au.lastError"/>.
            All objects must support this property, but some have bugs and can return default(wnd).
            Uses API <msdn>WindowFromAccessibleObject</msdn> and API <msdn>GetAncestor</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.Rect">
            <summary>
            Gets location of this UI element in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.elm.GetRect(Au.Types.RECT@)"/>.
            Returns empty rectangle if failed or this property is unavailable. Supports <see cref="T:Au.lastError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.elm.GetRect(Au.Types.RECT@)">
            <summary>
            Gets location of this UI element in screen.
            </summary>
            <param name="r">Receives object rectangle in screen coordinates.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="T:Au.lastError"/>.
            Most but not all objects support this property.
            Uses <msdn>IAccessible.accLocation</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.GetRect(Au.Types.RECT@,Au.wnd)">
            <summary>
            Gets location of this UI element in the client area of window w.
            </summary>
            <param name="r">Receives object rectangle in w client area coordinates.</param>
            <param name="w">Window or control.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="T:Au.lastError"/>.
            Most but not all objects support this property.
            Uses <msdn>IAccessible.accLocation</msdn> and <see cref="M:Au.wnd.MapScreenToClient(Au.Types.RECT@)"/>.
            </remarks>
        </member>
        <member name="P:Au.elm.RoleInt">
            <summary>
            Gets standard non-string role, as enum ERole.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.ERole"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            Returns 0 if role is string or if failed. Supports <see cref="T:Au.lastError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.Role">
            <summary>
            Gets standard or custom role, as string.
            </summary>
            <remarks>
            Most objects have a standard role, defined in enum <see cref="T:Au.Types.ERole"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            For standard roles this function returns enum <see cref="T:Au.Types.ERole"/> member name. For string roles - the string. For unknown non-string roles - the int value like "0" or "500".
            Returns "" if failed. Supports <see cref="T:Au.lastError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.State">
            <summary>
            Gets object state (flags).
            </summary>
            <remarks>
            Returns 0 if failed. Supports <see cref="T:Au.lastError"/>.
            Uses <msdn>IAccessible.get_accState</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            if(a.State.Has(EState.INVISIBLE)) print.it("has state INVISIBLE");
            if(a.IsInvisible) print.it("invisible");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.elm.IsChecked">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state CHECKED. </summary>
        </member>
        <member name="P:Au.elm.IsDisabled">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state UNAVAILABLE. </summary>
            <remarks>Does not check whether this object is in a disabled parent/ancestor object.</remarks>
        </member>
        <member name="P:Au.elm.IsFocused">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state FOCUSED. </summary>
        </member>
        <member name="P:Au.elm.IsInvisible">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state INVISIBLE and does not have state OFFSCREEN. </summary>
            <remarks>
            If the object has both INVISIBLE and OFFSCREEN states, it is either invisible or just offscreen, depending on application etc. Then this function works like Find and similar functions: for most objects returns false (is visible), but for objects that have these roles returns true (invisible): WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Does not check whether this object is in an invisible parent/ancestor object.
            </remarks>
        </member>
        <member name="P:Au.elm.IsOffscreen">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state OFFSCREEN. </summary>
        </member>
        <member name="P:Au.elm.IsPassword">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state PROTECTED. </summary>
            <remarks>This state is used for password fields.</remarks>
        </member>
        <member name="P:Au.elm.IsPressed">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state PRESSED. </summary>
        </member>
        <member name="P:Au.elm.IsReadonly">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state READONLY. </summary>
        </member>
        <member name="P:Au.elm.IsSelected">
            <summary> Calls <see cref="P:Au.elm.State"/> and returns true if has state SELECTED. </summary>
        </member>
        <member name="M:Au.elm._BstrToString(System.Int32,Au.Types.BSTR)">
            <summary>
            Converts BSTR to string and disposes the BSTR.
            If hr is not 0, returns "" (never null).
            </summary>
        </member>
        <member name="P:Au.elm.Name">
            <summary>
            Gets name.
            </summary>
            <remarks>
            Object name usually is its read-only text (eg button text, link text), or its adjacent read-only text (eg text label by this edit box). It usually does not change, therefore can be used to find or identify the object.
            Returns "" if name is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            Uses <msdn>IAccessible.get_accName</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.NameOfWindow_(Au.wnd)">
            <summary>
            Gets <see cref="P:Au.elm.Name"/> of window/control w.
            Returns null if w invalid. Returns "" if failed to get name.
            </summary>
        </member>
        <member name="P:Au.elm.Value">
            <summary>
            Gets or sets value.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to set value.</exception>
            <remarks>
            Usually it is editable text or some other value that can be changed at run time, therefore in most cases it cannot be used to find or identify the object reliably.
            The 'get' function returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            Most objects don't support 'set'.
            Uses <msdn>IAccessible.get_accValue</msdn> or <msdn>IAccessible.put_accValue</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.Description">
            <summary>
            Gets description.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            Uses <msdn>IAccessible.get_accDescription</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.Help">
            <summary>
            Gets help text.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            Uses <msdn>IAccessible.get_accHelp</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.UiaId">
            <summary>
            Gets UI Automation element AutomationId property.
            </summary>
            <remarks>
            Only objects found with flag <see cref="F:Au.Types.EFFlags.UIA"/> can have this property.
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.elm.KeyboardShortcut">
            <summary>
            Gets keyboard shortcut.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            Uses <msdn>IAccessible.get_accKeyboardShortcut</msdn>.
            </remarks>
        </member>
        <member name="P:Au.elm.DefaultAction">
            <summary>
            Gets default action.
            See <see cref="M:Au.elm.DoAction"/>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.lastError"/>.
            If this is a Java UI element, returns all actions that can be used with <see cref="M:Au.elm.DoJavaAction(System.String)"/>, like "action1, action2, action3", from which the first is considered default and is used by <see cref="M:Au.elm.DoAction"/>.
            Uses <msdn>IAccessible.get_accDefaultAction</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.DoAction">
            <summary>
            Performs the object's default action (see <see cref="P:Au.elm.DefaultAction"/>). Usually it is 'click', 'press' or similar.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Fails if the object does not have a default action. Then you can use <see cref="M:Au.Types.ExtAu.MouseClick(Au.elm,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)"/>, or try <see cref="M:Au.elm.VirtualClick"/>, <see cref="M:Au.elm.Select(Au.Types.ESelect)"/>, <see cref="M:Au.elm.Focus(System.Boolean)"/> and keyboard functions.
            The action can take long time, for example show a dialog. This function normally does not wait. It allows the caller to automate the dialog. If it waits, try <see cref="M:Au.elm.DoJavaAction(System.String)"/> or one of the above functions (MouseClick etc).
            Uses <msdn>IAccessible.accDoDefaultAction</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.VirtualClick">
            <summary>
            Posts mouse-left-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects.
            Use (try) this function when the object does not support <see cref="M:Au.elm.DoAction"/>. When both don't work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.elm.VirtualRightClick">
            <summary>
            Posts mouse-right-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects. When does not work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.elm.DoJavaAction(System.String)">
            <summary>
            Performs one of actions supported by this Java UI element.
            </summary>
            <param name="action">
            Action name. See <see cref="P:Au.elm.DefaultAction"/>.
            If null (default), performs default action (like <see cref="M:Au.elm.DoAction"/>) or posts Space key message. More info in Remarks.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Read more about Java UI elements in <see cref="T:Au.elm"/> topic.
            
            Problem: if the action opens a dialog, DoAction/DoJavaAction do not return until the dialog is closed (or fail after some time). The caller then waits and cannot automate the dialog. Also then this process cannot exit until the dialog is closed. If the action parameter is null and the object is focusable, this function tries a workaround: it makes the object (button etc) focused and posts Space key message, which should press the button; then this function does not wait.
            </remarks>
        </member>
        <member name="M:Au.elm.DoActionAndWaitForNewWebPage(System.Double,System.Action{Au.elm})">
            <summary>
            Calls <see cref="M:Au.elm.DoAction"/> or <i>action</i> and waits until window name changes and web page name changes.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).
            Default 60 seconds.
            </param>
            <param name="action">If used, calls it instead of <see cref="M:Au.elm.DoAction"/>.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, when this object is invalid, or its top-level window does not contain a web page.</exception>
            <exception cref="T:Au.Types.AuWndException">The window was closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.elm.DoAction"/> or by the <i>action</i> function.</exception>
            <remarks>
            This function is used to click a link in a web page and wait until current web page is gone. It prevents a following 'wait for object' function from finding a matching object in the old page, which would be bad.
            This function does not wait until the new page is completely loaded. There is no reliable/universal way for it. Instead, after calling it you can call a 'wait for object' function which waits for a known object that must be in the new page.
            This function cannot be used when the new page has the same title as current page. Then it waits until <i>secondsTimeout</i> time or forever. The same if the action does not open a web page.
            </remarks>
        </member>
        <member name="M:Au.elm.Select(Au.Types.ESelect)">
            <summary>
            Selects or deselects.
            </summary>
            <param name="how">Specifies whether to select, focus, add to selection etc. Can be two flags, for example <c>ESelect.TAKEFOCUS | ESelect.TAKESELECTION</c>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:Au.Types.AuWndException">Failed to activate the window (<see cref="M:Au.wnd.Activate"/>) or focus the control (<see cref="M:Au.wnd.Focus"/>).</exception>
            <remarks>
            Uses <msdn>IAccessible.accSelect</msdn>.
            Not all objects support it. Most objects support not all flags. It depends on <see cref="T:Au.Types.EState"/> FOCUSABLE, SELECTABLE, MULTISELECTABLE, EXTSELECTABLE, DISABLED.
            Many object have bugs, especially with flag TAKEFOCUS. More bugs when the object found with flag <see cref="F:Au.Types.EFFlags.NotInProc"/>.
            </remarks>
        </member>
        <member name="M:Au.elm.Focus(System.Boolean)">
            <summary>
            Makes this object focused for keyboard input.
            </summary>
            <param name="andSelect">Add flag TAKESELECTION. Note: it is for selecting a list item, not for selecting text in a text box.</param>
            <remarks>
            Calls <see cref="M:Au.elm.Select(Au.Types.ESelect)"/> with flag TAKEFOCUS and optionally TAKESELECTION.
            Not all objects support this action and not all work correctly. More info in Select documentation.
            </remarks>
        </member>
        <member name="P:Au.elm.SelectedChildren">
            <summary>
            Gets selected direct child items.
            Returns empty array if there are no selected items of if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="P:Au.elm.ChildCount">
            <summary>
            Gets the number of direct child objects.
            </summary>
            <remarks>
            Uses <msdn>IAccessible.get_accChildCount</msdn>.
            </remarks>
        </member>
        <member name="M:Au.elm.GetProperties(System.String,Au.Types.EProperties@)">
            <summary>
            Gets multiple properties.
            </summary>
            <param name="props">
            String that specifies properties to get, for example "nv" for name and value.
            - R - <see cref="P:Au.elm.Role"/>.
            - n - <see cref="P:Au.elm.Name"/>.
            - v - <see cref="P:Au.elm.Value"/>.
            - d - <see cref="P:Au.elm.Description"/>.
            - h - <see cref="P:Au.elm.Help"/>.
            - a - <see cref="P:Au.elm.DefaultAction"/>.
            - k - <see cref="P:Au.elm.KeyboardShortcut"/>.
            - u - <see cref="P:Au.elm.UiaId"/>.
            - s - <see cref="P:Au.elm.State"/>.
            - r - <see cref="P:Au.elm.Rect"/>.
            - w - <see cref="P:Au.elm.WndContainer"/>.
            - o - <see cref="M:Au.elm.Html(System.Boolean)"/> outer.
            - i - <see cref="M:Au.elm.Html(System.Boolean)"/> inner.
            - @ - <see cref="M:Au.elm.HtmlAttributes"/>.
            </param>
            <param name="result">Receives results.</param>
            <exception cref="T:System.ArgumentException">Unknown property character.</exception>
            <remarks>
            The returned variable contains values of properties specified in <i>props</i>. When a property is empty or failed to get, the member variable is "", empty dictionary or default value of that type; never null.
            
            Normally this function is faster than calling multiple property functions, because it makes single remote procedure call. But not if this UI element was found with flag <see cref="F:Au.Types.EFFlags.NotInProc"/> etc.
            
            Returns false if fails, for example when the object's window is closed. Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.elm.Navigate(System.String,System.Double)">
            <summary>
            Gets an adjacent or related UI element - next, child, parent, etc.
            Returns null if not found.
            </summary>
            <param name="navig">
            String consisting of one or more navigation direction strings separated by space, like <c>"parent next child4 first"</c>.
            - <c>"next"</c> - next sibling UI element in the same parent UI element.
            - <c>"previous"</c> - previous sibling UI element in the same parent UI element.
            - <c>"first"</c> - first child UI element.
            - <c>"last"</c> - last child UI element.
            - <c>"parent"</c> - parent (container) UI element.
            - <c>"child"</c> - child UI element by 1-based index. Example: <c>"child3"</c> (3-th child). Negative index means from end, for example -1 is the last child.
            - <c>"#N"</c> - custom. More info in Remarks.
            </param>
            <param name="secondsToWait">Wait for the wanted UI element max this number of seconds. If negative, waits forever.</param>
            <exception cref="T:System.ArgumentException">Invalid <i>navig</i> string.</exception>
            <remarks>
            Can be only 2 letters, like <c>"pr"</c> for <c>"previous"</c>.
            A string like <c>"next3"</c> or <c>"next,3"</c> is the same as <c>"next next next"</c>. Except for <c>"child"</c>.
            Use string like <c>"#1000"</c> to specify a custom <i>navDir</i> value to pass to <msdn>IAccessible.accNavigate</msdn>. Can be any standard or custom value supported by the UI element.
            
            For <c>"next"</c>, <c>"previous"</c>, <c>"firstchild"</c>, <c>"lastchild"</c> and <c>"#N"</c> is used <msdn>IAccessible.accNavigate</msdn>. Not all UI elements support it. Some UI elements skip invisible siblings. Instead you can use <c>"parent childN"</c> or <c>"childN"</c>.
            For <c>"parent"</c> is used <msdn>IAccessible.get_accParent</msdn>. Few UI elements don't support. Some UI elements return a different parent than in the tree of UI elements.
            For <c>"child"</c> is used API <msdn>AccessibleChildren</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            a = a.Navigate("parent next ch3", true);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.elm.Html(System.Boolean)">
            <summary>
            Gets HTML.
            </summary>
            <param name="outer">If true, gets outer HTML (with tag and attributes), else inner HTML.</param>
            <remarks>
            Returns "" if this is not a HTML element or if failed. Supports <see cref="T:Au.lastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            If this is the root of web page (role DOCUMENT or PANE), gets web page body HTML.
            </remarks>
        </member>
        <member name="M:Au.elm.HtmlAttribute(System.String)">
            <summary>
            Gets a HTML attribute.
            </summary>
            <param name="name">Attribute name, for example <c>"href"</c>, <c>"id"</c>, <c>"class"</c>. Full, case-sensitive.</param>
            <remarks>
            Returns "" if this is not a HTML element or does not have the specified attribute or failed. Supports <see cref="T:Au.lastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
            <exception cref="T:System.ArgumentException">name is null/""/invalid.</exception>
        </member>
        <member name="M:Au.elm.HtmlAttributes">
            <summary>
            Gets all HTML attributes.
            </summary>
            <remarks>
            Returns empty dictionary if this is not a HTML element or does not have attributes or failed. Supports <see cref="T:Au.lastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
        </member>
        <member name="M:Au.elm.ScrollTo">
            <summary>
            Scrolls this UI element into view.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to scroll, or the object does not support scrolling.</exception>
            <remarks>
            This function works with these objects:
            - Web page objects in Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, Edge, web browser controls...). With Find use role prefix "web:", "firefox:" or "chrome:", and don't use flag <see cref="F:Au.Types.EFFlags.NotInProc"/>.
            - Objects standard treeview and listview controls, some other. With <b>Find</b> use flag <see cref="F:Au.Types.EFFlags.UIA"/>.
            </remarks>
        </member>
        <member name="T:Au.elmFinder">
            <summary>
            Contains UI element properties and is used to find it.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </remarks>
            <example>
            Find window that contains certain UI element, and get the UI element too.
            <code><![CDATA[
            var f = new elmFinder("BUTTON", "Apply");
            wnd w = wnd.find(cn: "#32770", also: t => f.Find(t));
            print.it(w);
            print.it(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.elmFinder.Result">
            <summary>
            The found UI element.
            null if not found. null if used <see cref="P:Au.elmFinder.ResultGetProperty"/>.
            </summary>
        </member>
        <member name="P:Au.elmFinder.ResultProperty">
            <summary>
            The requested propery of the found UI element, depending on <see cref="P:Au.elmFinder.ResultGetProperty"/>.
            null if: 1. Object not found. 2. <b>ResultGetProperty</b> not used or is '-'. 3. Failed to get the property.
            </summary>
            <remarks>
            The type depends on the property. Most properties are String. Others: <see cref="P:Au.elm.Rect"/>, <see cref="P:Au.elm.State"/>, <see cref="P:Au.elm.WndContainer"/>, <see cref="M:Au.elm.HtmlAttributes"/>.
            </remarks>
        </member>
        <member name="P:Au.elmFinder.ResultGetProperty">
            <summary>
            Set this when you need only some property of the UI element (name, etc) and not the object itself.
            The value is a character, the same as with <see cref="M:Au.elm.GetProperties(System.String,Au.Types.EProperties@)"/>, for example 'n' for Name. Use '-' if you don't need any property.
            </summary>
            <exception cref="T:System.ArgumentException">Used parameter <i>also</i> or <i>navig</i>.</exception>
        </member>
        <member name="P:Au.elmFinder.NavigFailed">
            <summary>
            true if used parameter <i>navig</i> and the intermediate object was found but the navigation did not find the final object.
            </summary>
        </member>
        <member name="M:Au.elmFinder.#ctor(System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)">
            <summary>
            Stores the specified UI element properties in this object. Reference: <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            </summary>
        </member>
        <member name="M:Au.elmFinder.Find(Au.wnd,Au.wndChildFinder)">
            <summary>
            Finds UI element in the specified control of window w.
            Returns true if found. The <see cref="P:Au.elmFinder.Result"/> property will be the found UI element.
            </summary>
            <param name="w">Window that contains the control.</param>
            <param name="controls">Control properties. This functions searches in all matching controls.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.elmFinder.Find(Au.wnd)"/>.</exception>
            <remarks>
            Alternatively you can specify control class name or id in role. How this function is different: 1. Allows to specify more control properties. 2. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </remarks>
        </member>
        <member name="M:Au.elmFinder.Find(Au.wnd)">
            <summary>
            Finds UI element in window w, like <see cref="M:Au.elm.find(Au.wnd,System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String,Au.wndChildFinder)"/>.
            Returns true if found. The <see cref="P:Au.elmFinder.Result"/> property will be the found UI element.
            </summary>
            <param name="w">Window or control that contains the UI element.</param>
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid.
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - flag <see cref="F:Au.Types.EFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
            </exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
        </member>
        <member name="M:Au.elmFinder.Find(Au.elm)">
            <summary>
            Finds UI element in UI element, like <see cref="M:Au.elm.Find(System.String,System.String,System.String,Au.Types.EFFlags,System.Func{Au.elm,System.Boolean},System.Int32,System.String)"/>.
            Returns true if found. The <see cref="P:Au.elmFinder.Result"/> property will be the found UI element.
            </summary>
            <param name="e">Direct or indirect parent UI element.</param>
            <exception cref="T:System.ArgumentNullException"><i>e</i> is null.</exception>
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid or has a prefix ("web:" etc).
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - flag <see cref="F:Au.Types.EFFlags.UIA"/>.
            - <see cref="P:Au.elm.SimpleElementId"/> is not 0.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
        </member>
        <member name="M:Au.elmFinder.Wait(System.Double,Au.wnd)">
            <summary>
            Finds UI element in window w.
            The same as <see cref="M:Au.elmFinder.Find(Au.wnd)"/>, but waits until the UI element is found or the given time expires.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="w">Window or control that contains the UI element.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.elmFinder.Find(Au.wnd)"/>.</exception>
        </member>
        <member name="M:Au.elmFinder.Wait(System.Double,Au.elm)">
            <summary>
            Finds UI element in UI element.
            The same as <see cref="M:Au.elmFinder.Find(Au.elm)"/>, but waits until the UI element is found or the given time expires.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="e">Direct or indirect parent UI element.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.elmFinder.Find(Au.elm)"/>.</exception>
        </member>
        <member name="T:Au.uiimage">
            <summary>
            Captures, finds and clicks images and colors in windows.
            </summary>
            <remarks>
            An image is any visible rectangular part of a window. A color is any visible pixel (the same as image of size 1x1).
            A <b>uiimage</b> variable holds results of <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/> and similar functions (rectangle etc).
            </remarks>
        </member>
        <member name="P:Au.uiimage.Rect">
            <summary>
            Gets location of the found image, relative to the search area.
            </summary>
            <remarks>
            Relative to the window/control client area (if area type is <b>wnd</b>), UI element (if <b>elm</b>), image (if <b>Bitmap</b>) or screen (if <b>RECT</b>).
            More info: <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </remarks>
        </member>
        <member name="P:Au.uiimage.RectInScreen">
            <summary>
            Gets location of the found image in screen coordinates.
            </summary>
            <remarks>
            Slower than <see cref="P:Au.uiimage.Rect"/>.
            </remarks>
        </member>
        <member name="P:Au.uiimage.MatchIndex">
            <summary>
            Gets 0-based index of current matching image instance.
            </summary>
            <remarks>
            Can be useful in <i>also</i> callback functions.
            When the <i>image</i> argument is a list of images, <b>MatchIndex</b> starts from 0 for each list image.
            </remarks>
        </member>
        <member name="P:Au.uiimage.ListIndex">
            <summary>
            When the <i>image</i> argument is a list of images, gets 0-based index of the list image.
            </summary>
        </member>
        <member name="M:Au.uiimage.Skip(System.Int32)">
            <summary>
            Can be used in <i>also</i> callback function to skip n matching images. Example: <c>also: o => o.Skip(n)</c>.
            </summary>
            <param name="n">How many matching images to skip.</param>
        </member>
        <member name="M:Au.uiimage.op_UnaryPlus(Au.uiimage)">
            <summary>
            Returns the same value if it is not null. Else throws <see cref="T:Au.Types.NotFoundException"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = +wnd.find("Example");
            var wi = +uiimage.find(w, ...);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.uiimage.ToString">
            
        </member>
        <member name="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})">
            <summary>
            Finds image(s) or color(s) displayed in a window or other area.
            </summary>
            <returns>
            Returns an <see cref="T:Au.uiimage"/> object that contains the rectangle of the found image and can click it etc.
            Returns null if not found. See example.
            </returns>
            <param name="area">
            Where to search:
            - <see cref="T:Au.wnd"/> - window or control. The search area is its client area.
            - <see cref="T:Au.elm"/> - UI element.
            - <see cref="T:System.Drawing.Bitmap"/> - another image.
            - <see cref="T:Au.Types.RECT"/> - a rectangle area in screen.
            - <see cref="T:Au.Types.IFArea"/> - can contain wnd, elm or Bitmap. Also allows to specify a rectangle in it, which makes the search area smaller and the function faster. Example: <c>uiimage.find((w, (left, top, width, height)), "image.png");</c>.
            </param>
            <param name="image">Image or color to find. Or array of them. More info: <see cref="T:Au.Types.IFImage"/>.</param>
            <param name="flags"></param>
            <param name="colorDiff">Maximal allowed color difference. Use to to find images that have slightly different colors than the specified image. Can be 0 - 250, but should be as small as possible. Applied to each color component (red, green, blue) of each pixel.</param>
            <param name="also">
            Callback function. Called for each found image instance and receives its rectangle, match index and list index. Can return one of <see cref="T:Au.Types.IFAlso"/> values.
            
            Examples:
            - Skip some matching images if some condition if false: <c>also: o => condition ? IFAlso.OkReturn : IFAlso.FindOther</c>
            - Skip n matching images: <c>also: o => o.Skip(n)</c>
            - Get rectangles etc of all matching images: <c>also: o => { list.Add(o); return false; }</c>. Don't use this code in 'wait' functions.
            - Get rectangles etc of all matching images and stop waiting: <c>also: o => { list.Add(o); o.Found = true; return false; }</c>
            - Do different actions depending on which list images found: <c>var found = new BitArray(images.Length); uiimage.find(w, images, also: o => { found[o.ListIndex] = true; return IFAlso.OkFindMoreOfList; }); if(found[0]) print.it(0); if(found[1]) print.it(1);</c>
            </param>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the <i>area</i> argument).</exception>
            <exception cref="T:System.ArgumentException">An argument is/contains a null/invalid value.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Image file does not exist.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.more.loadImage(System.String)"/>.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
            <remarks>
            To create code for this function, use dialog "Find image or color in window".
            
            The speed mostly depends on:
            1. The size of the search area. Use the smallest possible area (control or UI element or rectangle in window like <c>(w, rectangle)</c>).
            2. Flags <see cref="F:Au.Types.IFFlags.WindowDC"/> (makes faster), <see cref="F:Au.Types.IFFlags.PrintWindow"/>. The speed depends on window.
            3. Video driver. Can be much slower if incorrect, generic or virtual PC driver is used. The above flags should help.
            4. <i>colorDiff</i>. Should be as small as possible.
            
            If flag <see cref="F:Au.Types.IFFlags.WindowDC"/> or <see cref="F:Au.Types.IFFlags.PrintWindow"/> not used, the search area must be visible on the screen, because this function then gets pixels from the screen.
            
            Can find only images that exactly match the specified image. With <i>colorDiff</i> can find images with slightly different colors and brightness. Cannot find images with different shapes.
            
            Transparent and partially transparent pixels are ignored. For example, when you capture a non-rectangular area image, the image actually is rectangular, but pixels outside of its captured area are transparent and therefore not compared. Also you can draw transparent areas with an image editor that supports it, for example Paint.NET.
            
            This function is not the best way to find objects when the script is intended for long use or for use on multiple computers or must be very reliable. Because it may fail to find the image after are changed some settings - system theme, application theme, text size (DPI), font smoothing (if the image contains text), etc. Also are possible various unexpected temporary conditions that may distort or hide the image, for example adjacent window shadow, a tooltip or some temporary window. If possible, in such scripts instead use other functions, eg find control or UI element.
            
            Flags <see cref="F:Au.Types.IFFlags.WindowDC"/> and <see cref="F:Au.Types.IFFlags.PrintWindow"/> cannot be used if <i>area</i> is <b>Bitmap</b> or <b>RECT</b>.
            </remarks>
            <example>
            Code created with dialog "Find image or color in window".
            <code><![CDATA[
            var w = +wnd.find("Window Name");
            string image = "image:iVBORw0KGgoAAAANSUhEUgAAABYAAAANCAYAAACtpZ5jAAAAAXNSR0IArs4c...";
            var wi = +uiimage.find(w, image);
            wi.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.uiimage.wait(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})">
            <summary>
            Finds image(s) or color(s) displayed in a window or other area. Waits until found.
            More info: <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <returns>Returns <see cref="T:Au.uiimage"/> object containing the rectangle of the found image. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.</exception>
        </member>
        <member name="M:Au.uiimage.waitNot(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})">
            <summary>
            Waits until image(s) or color(s) is not displayed in a window or other area.
            More info: <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.</exception>
        </member>
        <member name="M:Au.uiimage.waitChanged(System.Double,Au.Types.IFArea,Au.Types.IFFlags,System.Int32)">
            <summary>
            Waits until something visually changes in a window or other area.
            More info: <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.</exception>
            <remarks>
            The same as <see cref="M:Au.uiimage.waitNot(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>, but instead of <i>image</i> parameter this function captures the area image at the beginning.
            </remarks>
        </member>
        <member name="T:Au.uiimage.more">
            <summary>
            Miscellaneous rarely used image functions.
            </summary>
        </member>
        <member name="M:Au.uiimage.more.loadImage(System.String)">
            <summary>
            Loads image from file, resource or string.
            </summary>
            <param name="image">See <see cref="T:Au.Types.IFImage"/>.</param>
            <exception cref="T:System.IO.FileNotFoundException">Cannot find image file or resource.</exception>
            <exception cref="T:System.ArgumentException">Bad image or string format.</exception>
            <exception cref="T:System.Exception">Depending on <i>image</i> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, etc.</exception>
            <remarks>
            Calls <see cref="M:Au.More.ImageUtil.LoadGdipBitmapFromFileOrResourceOrString(System.String,System.Nullable{System.ValueTuple{System.Int32,System.Nullable{Au.Types.SIZE}}})"/>.
            </remarks>
        </member>
        <member name="M:Au.uiimage.more.bitmapFromHbitmap(System.IntPtr)">
            <summary>
            Creates Bitmap from a GDI bitmap.
            </summary>
            <param name="hbitmap">GDI bitmap handle. This function makes its copy.</param>
            <remarks>
            How this function is different from <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>:
            1. Image.FromHbitmap usually creates bottom-up bitmap, which is incompatible with <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>. This function creates normal top-down bitmap, like <c>new Bitmap(...)</c>, <c>Bitmap.FromFile(...)</c> etc do.
            2. This function always creates bitmap of PixelFormat Format32bppRgb.
            </remarks>
            <exception cref="T:Au.Types.AuException">Failed. For example hbitmap is default(IntPtr).</exception>
            <exception cref="T:System.Exception">Exceptions of Bitmap(int, int, PixelFormat) constructor.</exception>
        </member>
        <member name="M:Au.uiimage.capture(Au.Types.RECT)">
            <summary>
            Creates image from a rectangle of screen pixels.
            </summary>
            <param name="rect">A rectangle in screen coordinates.</param>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
            <example>
            <code><![CDATA[
            var file = folders.Temp + "notepad.png";
            wnd w = wnd.find("* Notepad");
            w.Activate();
            using(var b = uiimage.capture(w.Rect)) { b.Save(file); }
            run.it(file);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.uiimage.capture(Au.wnd,Au.Types.RECT,System.Boolean)">
            <summary>
            Creates image from a rectangle of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="rect">A rectangle in w client area coordinates. Use <c>w.ClientRect</c> to get whole client area.</param>
            <param name="usePrintWindow">Use flag <see cref="F:Au.Types.ICFlags.PrintWindow"/>.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid w.</exception>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            How this is different from <see cref="M:Au.uiimage.capture(Au.Types.RECT)"/>:
            1. Gets pixels from window's device context (DC), not from screen DC, unless the Aero theme is turned off (on Windows 7). The window can be under other windows. The image can be different.
            2. If the window is partially or completely transparent, gets non-transparent image.
            3. Does not work with Windows Store app windows, Chrome and some other windows. Creates black image.
            4. If the window is DPI-scaled, captures its non-scaled view. And <i>rect</i> must contain non-scaled coordinates.
            </remarks>
        </member>
        <member name="M:Au.uiimage.capture(System.Collections.Generic.List{Au.Types.POINT})">
            <summary>
            Creates image from a non-rectangular area of screen pixels.
            </summary>
            <param name="outline">The outline (shape) of the area in screen. If single element, captures single pixel.</param>
            <exception cref="T:System.ArgumentException"><i>outline</i> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
        </member>
        <member name="M:Au.uiimage.capture(Au.wnd,System.Collections.Generic.List{Au.Types.POINT},System.Boolean)">
            <summary>
            Creates image from a non-rectangular area of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="outline">The outline (shape) of the area in w client area coordinates. If single element, captures single pixel.</param>
            <param name="usePrintWindow">Use flag <see cref="F:Au.Types.ICFlags.PrintWindow"/>.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid <i>w</i>.</exception>
            <exception cref="T:System.ArgumentException"><i>outline</i> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>More info: <see cref="M:Au.uiimage.capture(Au.wnd,Au.Types.RECT,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:Au.uiimage.captureUI(Au.Types.ICResult@,Au.Types.ICFlags,Au.Types.AnyWnd)">
            <summary>
            Creates image from a user-selected area of screen pixels. Or gets single pixel color, or just rectangle.
            Returns false if cancelled.
            </summary>
            <param name="result">Receives results.</param>
            <param name="flags"></param>
            <param name="owner">Owner window. Temporarily hides it and its owner windows.</param>
            <remarks>
            Gets all screen pixels and shows in a full-screen topmost window, where the user can select an area.
            </remarks>
        </member>
        <member name="M:Au.uiimage._CapturingWindow.Show(System.Drawing.Bitmap,Au.Types.ICFlags,Au.Types.RECT)">
            <returns>0 Cancel, 1 OK, 2 Retry.</returns>
        </member>
        <member name="T:Au.uiimageFinder">
            <summary>
            Contains data and parameters of image(s) or color(s) to find. Finds them in a window or other area.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </remarks>
        </member>
        <member name="P:Au.uiimageFinder.Result">
            <summary>
            Returns <see cref="T:Au.uiimage"/> object that contains the rectangle of the found image and can click it etc.
            </summary>
        </member>
        <member name="M:Au.uiimageFinder.#ctor(Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})">
            <summary>
            Stores image/color data and search settings in this object. Loads images if need. See <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <exception cref="T:System.ArgumentException">An argument is/contains a null/invalid value.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Image file does not exist.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.more.loadImage(System.String)"/>.</exception>
        </member>
        <member name="M:Au.uiimageFinder.Find(Au.Types.IFArea)">
            <summary>
            Finds the image displayed in the specified window or other area. See <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <returns>Returns true if found. Then use <see cref="P:Au.uiimageFinder.Result"/>.</returns>
            <param name="area">See <see cref="M:Au.uiimage.find(Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
            <exception cref="T:System.ArgumentException">An argument of this function or of constructor is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
        </member>
        <member name="M:Au.uiimageFinder.Wait(System.Double,Au.Types.IFArea)">
            <summary>
            See <see cref="M:Au.uiimage.wait(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.wait(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>, except those of the constructor.</exception>
        </member>
        <member name="M:Au.uiimageFinder.WaitNot(System.Double,Au.Types.IFArea)">
            <summary>
            See <see cref="M:Au.uiimage.waitNot(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.uiimage.waitNot(System.Double,Au.Types.IFArea,Au.Types.IFImage,Au.Types.IFFlags,System.Int32,System.Func{Au.uiimage,Au.Types.IFAlso})"/>, except those of the constructor.</exception>
        </member>
        <member name="T:Au.wnd">
            <summary>
            A variable of <b>wnd</b> type represents a window or control. It is a window handle, also known as HWND.
            </summary>
            <remarks>
            <b>wnd</b> functions can be used with windows and controls of any process/thread. Also can be used with .NET form/control and WPF window class variables, like <c>wnd w=form.Hwnd(); w.Method(...);</c>.
            
            There are two main types of windows - top-level windows and controls. Controls are child windows of top-level windows.
            
            More functions are in the nested classes - <see cref="T:Au.wnd.more"/>, <see cref="T:Au.wnd.more.desktop"/> etc. They are used mostly in programming, rarely in automation scripts.
            
            What happens when a <b>wnd</b> member function fails:
            - Functions that get window properties don't throw exceptions. They return false/0/null/empty. Most of them support <see cref="T:Au.lastError"/>, and it is mentioned in function documentation.
            - Many functions that change window properties throw exception. Exceptions are listed in function documentation. Almost all these functions throw only <see cref="T:Au.Types.AuWndException"/>.
            - Other functions that change window properties return false. They are more often used in programming than in automation scripts.
            - When a 'find' function does not find the window or control, it returns <c>default(wnd)</c> (window handle 0). Then <see cref="P:Au.wnd.Is0"/> will return true.
            - If a function does not follow these rules, it is mentioned in function documentation.
            
            Many functions fail if the window's process has a higher [](xref:uac) integrity level (aministrator, uiAccess) than this process, unless this process has uiAccess level. Especially the functions that change window properties. Some functions that still work: <b>Activate</b>, <b>ActivateL</b>, <b>ShowMinimized</b>, <b>ShowNotMinimized</b>, <b>ShowNotMinMax</b>, <b>Close</b>.
            
            The <b>wnd</b> type can be used with native Windows API functions without casting. Use <b>wnd</b> for the parameter type in the declaration, like <c>[DllImport(...)] static extern bool NativeFunction(wnd hWnd, ...)</c>.
            
            See also: MSDN article <msdn>Window Features</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            wnd w = wnd.find("* - Notepad");
            if(w.Is0) { print.it("window not found"); return; }
            w.Activate();
            wnd c = w.Child(cn: "Button");
            print.it(c.Name);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.op_Implicit(Au.Types.SpecHWND)~Au.wnd">
            <summary>
            Converts from a special handle value.
            </summary>
            <param name="hwnd">See API <msdn>SetWindowPos</msdn>.</param>
        </member>
        <member name="M:Au.wnd.op_Equality(Au.wnd,Au.wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.wnd.op_Inequality(Au.wnd,Au.wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.wnd.op_UnaryPlus(Au.wnd)">
            <summary>
            Returns the same value if it is not default(wnd). Else throws <see cref="T:Au.Types.NotFoundException"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = +wnd.find("Example");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.Equals(System.Nullable{Au.wnd})">
            <summary>
            Returns true if w != null and w.Value == this.
            </summary>
        </member>
        <member name="M:Au.wnd.Equals(System.Object)">
            <summary>
            Returns true if obj is wnd and contains the same window handle.
            </summary>
        </member>
        <member name="M:Au.wnd.Equals(Au.wnd)">
            <summary>
            Returns true if other == this.
            Implements IEquatable. It prevents boxing when used as a key of a collection.
            </summary>
        </member>
        <member name="M:Au.wnd.CompareTo(Au.wnd)">
            <summary>
            Implements IComparable. It allows to sort a collection.
            </summary>
        </member>
        <member name="M:Au.wnd.GetHashCode">
            
        </member>
        <member name="P:Au.wnd.Handle">
            <summary>
            Gets window handle as IntPtr.
            Code <c>w.Handle</c> is the same as <c>(IntPtr)w</c> .
            </summary>
        </member>
        <member name="M:Au.wnd.ToString">
            <summary>
            Formats string <c>$"{handle}  {ClassName}  \"{Name}\"  {ProgramName}  {Rect}"</c>.
            </summary>
        </member>
        <member name="M:Au.wnd.Send(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Calls API <msdn>SendMessage</msdn>.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.Send(System.Int32,System.IntPtr,System.String)">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is string.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.Send(System.Int32,System.IntPtr,System.Void*)">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is any pointer.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.SendTimeout(System.Int32,System.IntPtr@,System.Int32,System.IntPtr,System.IntPtr,Au.Types.SMTFlags)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> and gets the result of the message processing.
            Returns its return value (false if failed). Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.SendTimeout(System.Int32,System.IntPtr@,System.Int32,System.IntPtr,System.String,Au.Types.SMTFlags)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is string.
            Returns its return value (false if failed). Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.SendTimeout(System.Int32,System.IntPtr@,System.Int32,System.IntPtr,System.Void*,Au.Types.SMTFlags)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> and gets the result of the message processing.
            Returns its return value (false if failed). Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.SendNotify(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Calls API <msdn>SendNotifyMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.Post(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Calls API <msdn>PostMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <seealso cref="M:Au.wnd.more.postThreadMessage(System.Int32,System.Int32,System.IntPtr,System.IntPtr)"/>
        </member>
        <member name="T:Au.wnd.more">
            <summary>
            Miscellaneous window-related functions and classes. Rarely used, or useful only for programmers.
            </summary>
        </member>
        <member name="M:Au.wnd.more.postThreadMessage(System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Posts a message to the message queue of the specified thread. Of this thread if <i>threadId</i> is 0.
            Calls API <msdn>PostThreadMessage</msdn>. 
            Returns false if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.more.waitForAnActiveWindow">
            <summary>
            Waits while there is no active window.
            It sometimes happens after closing, minimizing or switching the active window, briefly until another window becomes active.
            Waits max 500 ms, then returns false if there is no active window.
            Processes Windows messages that are in the message queue of this thread.
            Don't need to call this after calling functions of this library.
            </summary>
        </member>
        <member name="M:Au.wnd.more.enableActivate(System.Int32)">
            <summary>
            Temporarily enables this process to activate windows with API <msdn>SetForegroundWindow</msdn>.
            Returns false if fails.
            </summary>
            <param name="processId">Process id. If not 0, enables that process to activate windows too. If -1, all processes will be enabled.</param>
            <remarks>
            In some cases you may need this function because Windows often disables API <msdn>SetForegroundWindow</msdn> to not allow background applications to activate windows while the user is working (using keyboard/mouse) with the currently active window. Then <b>SetForegroundWindow</b> usually just makes the window's taskbar button flash.
            Usually you don't call <b>SetForegroundWindow</b> directly. It is called by some other functions.
            Don't need to call this function before calling <see cref="M:Au.wnd.Activate"/> and other functions of this library that activate windows.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.registerWindowClass(System.String,Au.Types.WNDPROC,Au.Types.RWCEtc)">
            <summary>
            Registers new window class in this process.
            </summary>
            <param name="className">Class name.</param>
            <param name="wndProc">
            Delegate of a window procedure. See <msdn>Window Procedures</msdn>.
            
            Use null when you need a different delegate (method or target object) for each window instance; create windows with <see cref="M:Au.wnd.more.createWindow(Au.Types.WNDPROC,System.Boolean,System.String,System.String,Au.Types.WS,Au.Types.WSE,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd,System.IntPtr,System.IntPtr,System.IntPtr)"/> or <see cref="M:Au.wnd.more.createMessageOnlyWindow(Au.Types.WNDPROC,System.String)"/>.
            If not null, it must be a static method; create windows with any other function, including API <msdn>CreateWindowEx</msdn>.
            </param>
            <param name="etc">
            Can be used to specify API <msdn>WNDCLASSEX</msdn> fields.
            To set cursor use field <b>mCursor</b> (standard cursor) or <b>hCursor</b> (native handle of a custom cursor).
            If null, this function sets arrow cursor and style CS_VREDRAW | CS_HREDRAW.
            </param>
            <exception cref="T:System.ArgumentException"><i>wndProc</i> is an instance method. Must be static method or null. If need instance method, use null here and pass <i>wndProc</i> to <see cref="M:Au.wnd.more.createWindow(Au.Types.WNDPROC,System.Boolean,System.String,System.String,Au.Types.WS,Au.Types.WSE,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd,System.IntPtr,System.IntPtr,System.IntPtr)"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The class already registered with this function and different <i>wndProc</i> (another method or another target object).</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example if the class already exists and was registered not with this function.</exception>
            <remarks>
            Calls API <msdn>RegisterClassEx</msdn>.
            The window class is registered until this process ends. Don't need to unregister.
            If called next time for the same window class, does nothing if <i>wndProc</i> is equal to the previous (or both null). Then ignores <i>etc</i>. Throws exception if different.
            Thread-safe.
            Protects the <i>wndProc</i> delegate from GC.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.createWindow(Au.Types.WNDPROC,System.Boolean,System.String,System.String,Au.Types.WS,Au.Types.WSE,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates native/unmanaged window (API <msdn>CreateWindowEx</msdn>) and sets its window procedure.
            </summary>
            <param name="wndProc">Window procedure.</param>
            <param name="keepAlive">
            Protect <i>wndProc</i> from GC (garbage collector) until the window is destroyed (message <msdn>WM_NCDESTROY</msdn> recived or thread ended).
            <note type="important">In some cases it may prevent destroying the window until thread ends, and it can be a big memory leak. For example WPF then does not destroy HwndHost-ed controls. Then let <i>keepAlive</i>=false and manually manage <i>wndProc</i> lifetime, for example keep it as a field of the wrapper class.</note>
            </param>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            If the class was registered with <see cref="M:Au.wnd.more.registerWindowClass(System.String,Au.Types.WNDPROC,Au.Types.RWCEtc)"/> with null <i>wndProc</i>, the <i>wndProc</i> function will receive all messages. Else will not receive messages sent before <b>CreateWindowEx</b> returns (WM_CREATE etc).
            
            To destroy the window can be used any function, including API <msdn>DestroyWindow</msdn>, <see cref="M:Au.wnd.more.destroyWindow(Au.wnd)"/>, <see cref="M:Au.wnd.Close(System.Boolean,System.Boolean)"/>, API <msdn>WM_CLOSE</msdn>.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.createWindow(System.String,System.String,Au.Types.WS,Au.Types.WSE,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates native/unmanaged window.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Calls API <msdn>CreateWindowEx</msdn>.
            To destroy the window can be used any function, including API <msdn>DestroyWindow</msdn>, <see cref="M:Au.wnd.more.destroyWindow(Au.wnd)"/>, <see cref="M:Au.wnd.Close(System.Boolean,System.Boolean)"/>, API <msdn>WM_CLOSE</msdn>.
            </remarks>
            <seealso cref="M:Au.wnd.more.registerWindowClass(System.String,Au.Types.WNDPROC,Au.Types.RWCEtc)"/>
        </member>
        <member name="M:Au.wnd.more.createMessageOnlyWindow(System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn>.
            </summary>
            <param name="className">Window class name. Can be any existing class.</param>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            To destroy the window can be used any function, including API <msdn>DestroyWindow</msdn>, <see cref="M:Au.wnd.more.destroyWindow(Au.wnd)"/>, <see cref="M:Au.wnd.Close(System.Boolean,System.Boolean)"/>, API <msdn>WM_CLOSE</msdn>.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.createMessageOnlyWindow(Au.Types.WNDPROC,System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn> and sets its window procedure.
            </summary>
            <param name="className">Window class name.</param>
            <param name="wndProc"></param>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            Calls <see cref="M:Au.wnd.more.createWindow(Au.Types.WNDPROC,System.Boolean,System.String,System.String,Au.Types.WS,Au.Types.WSE,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd,System.IntPtr,System.IntPtr,System.IntPtr)"/> with <i>keepAlive</i>=true.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.destroyWindow(Au.wnd)">
            <summary>
            Destroys a native window of this thread.
            Calls API <msdn>DestroyWindow</msdn>.
            Returns false if failed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <seealso cref="M:Au.wnd.Close(System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.more.setFont(Au.wnd,System.IntPtr)">
            <summary>
            Sets font.
            </summary>
            <param name="w"></param>
            <param name="font">
            Native font handle.
            If default(IntPtr), sets font that is used by most windows and controls on this computer, usually Segoe UI, 9, DPI-scaled for w screen.
            </param>
            <remarks>
            Sends <msdn>WM_SETFONT</msdn> message.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.getWindowsStoreAppId(Au.wnd,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns null if fails. Returns null if called on Windows 7 unless <i>getExePathIfNotWinStoreApp</i> true.
            </summary>
            <param name="w"></param>
            <param name="prependShellAppsFolder">Prepend <c>@"shell:AppsFolder\"</c> (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
            <remarks>
            Windows Store app window class name can be "Windows.UI.Core.CoreWindow" or "ApplicationFrameWindow".
            </remarks>
        </member>
        <member name="M:Au.wnd.more.getClassLong(Au.wnd,System.Int32)">
            <summary>
            Calls API <msdn>GetClassLongPtr</msdn>.
            </summary>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            For index can be used constants from <see cref="T:Au.Types.GCL"/>. All values are the same in 32-bit and 64-bit process.
            In 32-bit process actually calls <b>GetClassLong</b>, because <b>GetClassLongPtr</b> is unavailable.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.registerMessage(System.String,System.Boolean)">
            <summary>
            Calls API <msdn>RegisterWindowMessage</msdn>.
            </summary>
            <param name="name">Message name. Can be any unique string.</param>
            <param name="uacEnable">Also call API <msdn>ChangeWindowMessageFilter</msdn> for the message. More info: <see cref="M:Au.wnd.more.uacEnableMessages(System.Int32[])"/>.</param>
        </member>
        <member name="M:Au.wnd.more.uacEnableMessages(System.Int32[])">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> for each message in the list of messages.
            It allows processes of lower [](xref:uac) integrity level to send these messages to this process.
            </summary>
        </member>
        <member name="M:Au.wnd.more.printMsg(System.String@,Au.wnd,System.Int32,System.IntPtr,System.IntPtr,Au.Types.PrintMsgOptions,System.String)">
            <summary>
            Writes a Windows message to a string.
            If the message is specified in <i>options</i>, sets <c>s=null</c> and returns false.
            </summary>
        </member>
        <member name="M:Au.wnd.more.printMsg(Au.wnd,System.Int32,System.IntPtr,System.IntPtr,Au.Types.PrintMsgOptions,System.String)">
            <summary>
            Writes a Windows message to the output, unless it is specified in <i>options</i>.
            </summary>
        </member>
        <member name="M:Au.wnd.more.printMsg(System.String@,Au.Types.MSG@,Au.Types.PrintMsgOptions,System.String)">
            <summary>
            Writes a Windows message to a string.
            If the message is specified in <i>options</i>, sets <c>s=null</c> and returns false.
            </summary>
            <remarks>
            The <i>m</i> parameter also accepts <b>System.Windows.Interop.MSG</b> (WPF) and <b>System.Windows.Forms.Message</b>.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.printMsg(Au.Types.MSG@,Au.Types.PrintMsgOptions,System.String)">
            <summary>
            Writes a Windows message to the output, unless it is specified in <i>options</i>.
            </summary>
            <remarks>
            The <i>m</i> parameter also accepts <b>System.Windows.Interop.MSG</b> (WPF) and <b>System.Windows.Forms.Message</b>.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.dragLoop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Types.WDLArgs})">
            <summary>
            Simple non-OLE drag operation.
            Returns true if dropped, false if cancelled.
            </summary>
            <param name="window">Window or control that owns the drag operation. Must be of this thread.</param>
            <param name="mouseButton">Mouse button that is used for the drag operation: Left, Right, Middle.</param>
            <param name="onMouseKeyMessage">Callback function, called on each received mouse/key message. Optional.</param>
        </member>
        <member name="T:Au.wnd.more.SavedRect">
            <summary>
            Helps to save and restore window rectangle and state. Ensures in screen, per-monitor-DPI-aware, etc.
            </summary>
            <example>
            <code><![CDATA[
            class Form9 : Form {
            	const string c_rkey = @"HKEY_CURRENT_USER\Software\Au\Test", c_rvalue = @"Form9.Rect";
            	
            	public Form9() {
            		this.StartPosition = FormStartPosition.Manual;
            		if (wnd.more.SavedRect.FromString(Registry.GetValue(c_rkey, c_rvalue, null) as string, out var v)) {
            			this.Bounds = v.NormalizeRect();
            			if(v.Maximize) this.WindowState = FormWindowState.Maximized;
            		}
            		//the same:
            		//wnd.more.SavedRect.Restore(this, Registry.GetValue(c_rkey, c_rvalue, null) as string);
            	}
            
            	protected override void OnFormClosing(FormClosingEventArgs e) {
            		Registry.SetValue(c_rkey, c_rvalue, new wnd.more.SavedRect(this).ToString());
            		base.OnFormClosing(e);
            	}
            }
            ]]></code>
            The same in 2 lines.
            <code><![CDATA[
            class Form8 : Form {
            	const string c_rkey = @"HKEY_CURRENT_USER\Software\Au\Test", c_rvalue = @"Form8.Rect";
            	
            	public Form8() {
            		wnd.more.SavedRect.Restore(this, Registry.GetValue(c_rkey, c_rvalue, null) as string, s1 => Registry.SetValue(c_rkey, c_rvalue, s1.ToString()));
            	}
            }
            ]]></code>
            WPF window created with <see cref="T:Au.wpfBuilder"/>.
            <code><![CDATA[
            const string c_rkey = @"HKEY_CURRENT_USER\Software\Au\Test", c_rvalue = @"Wpf7.Rect";
            var b = new wpfBuilder("Window").WinSize(400).R.AddOkCancel().End();
            	
            wnd.more.SavedRect.Restore(b.Window, Registry.GetValue(c_rkey, c_rvalue, null) as string, s1 => Registry.SetValue(c_rkey, c_rvalue, s1));
            
            //the same
            //b.WinSaved(Registry.GetValue(c_rkey, c_rvalue, null) as string, s1 => Registry.SetValue(c_rkey, c_rvalue, s1));
            
            if (!b.ShowDialog()) return;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.wnd.more.SavedRect.RawRect">
            <summary>
            Window rectangle in normal state (not maximized/minimized), as retrieved by API <msdn>GetWindowPlacement</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.more.SavedRect.Dpi">
            <summary>
            <see cref="M:Au.More.Dpi.OfWindow(Au.wnd,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.wnd.more.SavedRect.Maximize">
            <summary>
            The window should be maximized.
            </summary>
        </member>
        <member name="P:Au.wnd.more.SavedRect.IsToolWindow">
            <summary>
            <see cref="P:Au.wnd.IsToolWindow"/>. If false, <see cref="P:Au.wnd.more.SavedRect.RawRect"/> may have an offset that depends on work area.
            </summary>
        </member>
        <member name="M:Au.wnd.more.SavedRect.ToString">
            <summary>
            Converts this object to string for saving.
            The string is very simple, like "1 2 3 4 5 6".
            </summary>
        </member>
        <member name="M:Au.wnd.more.SavedRect.FromString(System.String,Au.wnd.more.SavedRect@)">
            <summary>
            Creates <b>SavedRect</b> from string created by <see cref="M:Au.wnd.more.SavedRect.ToString"/>.
            Returns false if the string is null or invalid.
            </summary>
            <param name="saved">String created by <see cref="M:Au.wnd.more.SavedRect.ToString"/>.</param>
            <param name="x">Result.</param>
        </member>
        <member name="M:Au.wnd.more.SavedRect.#ctor(Au.wnd)">
            <summary>
            Gets window rectangle and state for saving. Usually called when closing the window.
            See also <see cref="M:Au.wnd.more.SavedRect.ToString"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed to get rectangle, probably invalid window handle.</exception>
        </member>
        <member name="M:Au.wnd.more.SavedRect.#ctor(System.Windows.Forms.Form)">
            <summary>
            Gets window rectangle and state for saving. Usually called when closing the window.
            See also <see cref="M:Au.wnd.more.SavedRect.ToString"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed to get rectangle, probably invalid window handle.</exception>
        </member>
        <member name="M:Au.wnd.more.SavedRect.#ctor(System.Windows.Window)">
            <summary>
            Gets window rectangle and state for saving. Usually called when closing the window.
            See also <see cref="M:Au.wnd.more.SavedRect.ToString"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed to get rectangle, probably invalid window handle.</exception>
        </member>
        <member name="M:Au.wnd.more.SavedRect.NormalizeRect">
            <summary>
            Gets real rectangle for restoring saved window rectangle.
            </summary>
            <remarks>
            It is recommended to call this before creating window, and create window with the returned rectangle. Also set maximized state if <see cref="P:Au.wnd.more.SavedRect.Maximize"/>.
            If it is not possible, can be called later, for example when window is created but still invisible. However then possible various problems, for example may need to set window rectangle two times, because the window may be for example DPI-scaled when moving to another screen etc.
            
            This function ensures the window is in screen, ensures correct size when screen DPI changed, etc.
            </remarks>
        </member>
        <member name="M:Au.wnd.more.SavedRect.Restore(System.Windows.Forms.Form,System.String,System.Action{System.String})">
            <summary>
            Calls <see cref="M:Au.wnd.more.SavedRect.FromString(System.String,Au.wnd.more.SavedRect@)"/>. If it returns true, sets <i>form</i> bounds = <see cref="M:Au.wnd.more.SavedRect.NormalizeRect"/>, maximizes if need, StartPosition=Manual, and returns true.
            Call this function before showing form, for example in constructor.
            </summary>
            <param name="form"></param>
            <param name="saved">String created by <see cref="M:Au.wnd.more.SavedRect.ToString"/>.</param>
            <param name="save">If not null, called when closing the window. Receives string for saving. Can save it in registry, file, anywhere.</param>
        </member>
        <member name="M:Au.wnd.more.SavedRect.Restore(System.Windows.Window,System.String,System.Action{System.String})">
            <summary>
            Calls <see cref="M:Au.wnd.more.SavedRect.FromString(System.String,Au.wnd.more.SavedRect@)"/>. If it returns true, calls <see cref="M:Au.wnd.more.SavedRect.NormalizeRect"/>, <see cref="M:Au.Types.ExtWpf.SetRect(System.Windows.Window,Au.Types.RECT)"/>, maximizes if need and returns true.
            Call this function before showing window.
            </summary>
            <param name="w"></param>
            <param name="saved">String created by <see cref="M:Au.wnd.more.SavedRect.ToString"/>.</param>
            <param name="save">If not null, called when closing the window. Receives string for saving. Can save it in registry, file, anywhere.</param>
            <exception cref="T:System.InvalidOperationException">Window is loaded.</exception>
        </member>
        <member name="T:Au.wnd.more.taskbarButton">
            <summary>
            Taskbar button flash, progress, add/delete.
            </summary>
        </member>
        <member name="M:Au.wnd.more.taskbarButton.flash(Au.wnd,System.Int32)">
            <summary>
            Starts or stops flashing the taskbar button.
            </summary>
            <param name="w">Window.</param>
            <param name="count">The number of times to flash. If 0, stops flashing.</param>
        </member>
        <member name="M:Au.wnd.more.taskbarButton.setProgressState(Au.wnd,Au.Types.WTBProgressState)">
            <summary>
            Sets the state of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressState</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="state">Progress indicator state and color.</param>
        </member>
        <member name="M:Au.wnd.more.taskbarButton.setProgressValue(Au.wnd,System.Int32,System.Int32)">
            <summary>
            Sets the value of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressValue</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="progressValue">Progress indicator value, 0 to progressTotal.</param>
            <param name="progressTotal">Max progress indicator value.</param>
        </member>
        <member name="M:Au.wnd.more.taskbarButton.add(Au.wnd)">
            <summary>
            Adds taskbar button.
            Calls <msdn>ITaskbarList.AddTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="M:Au.wnd.more.taskbarButton.delete(Au.wnd)">
            <summary>
            Deletes taskbar button.
            Calls <msdn>ITaskbarList.DeleteTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="T:Au.wnd.more.desktop">
            <summary>
            Arranges windows, shows/hides desktop. The same as the taskbar right-click menu commands.
            </summary>
        </member>
        <member name="M:Au.wnd.more.desktop.toggleShowDesktop">
            <summary>
            Shows or hides desktop.
            If there are non-minimized main windows, minimizes them. Else restores windows recently minimized by this function.
            </summary>
        </member>
        <member name="M:Au.wnd.more.desktop.minimizeWindows">
            <summary>
            Minimizes main windows.
            </summary>
        </member>
        <member name="M:Au.wnd.more.desktop.cascadeWindows">
            <summary>
            Cascades non-minimized main windows.
            </summary>
        </member>
        <member name="M:Au.wnd.more.desktop.tileWindows(System.Boolean)">
            <summary>
            Arranges non-minimized main windows horizontally or vertically.
            </summary>
        </member>
        <member name="M:Au.wnd.more.desktop.undoMinimizeEtc">
            <summary>
            Restores windows recently minimized, cascaded or tiled with other functions of this class.
            </summary>
        </member>
        <member name="T:Au.wnd.more.CopyData">
            <summary>
            Send/receive data to/from other process using message <msdn>WM_COPYDATA</msdn>.
            </summary>
            <remarks>
            This struct is <msdn>COPYDATASTRUCT</msdn>.
            <note>By default [](xref:uac) blocks messages sent from processes of lower integrity level. Call <see cref="M:Au.wnd.more.CopyData.EnableReceivingWM_COPYDATA"/> if need.</note>
            </remarks>
            <seealso cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/>
            <seealso cref="T:System.IO.Pipes.NamedPipeServerStream"/>
        </member>
        <member name="M:Au.wnd.more.CopyData.#ctor(System.IntPtr)">
            <summary>
            Initializes this variable from <i>lParam</i> of a received <msdn>WM_COPYDATA</msdn> message.
            Then you can call functions of this variable to get data in managed format.
            </summary>
            <param name="lParam"><i>lParam</i> of a <msdn>WM_COPYDATA</msdn> message received in a window procedure. It is <msdn>COPYDATASTRUCT</msdn> pointer.</param>
        </member>
        <member name="P:Au.wnd.more.CopyData.DataId">
            <summary>
            Data id. It is <msdn>COPYDATASTRUCT.dwData</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.more.CopyData.RawData">
            <summary>
            Unmanaged data pointer. It is <msdn>COPYDATASTRUCT.lpData</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.more.CopyData.RawDataSize">
            <summary>
            Unmanaged data size. It is <msdn>COPYDATASTRUCT.cbData</msdn>.
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.GetString">
            <summary>
            Gets received data as string.
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.GetBytes">
            <summary>
            Gets received data as byte[].
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.EnableReceivingWM_COPYDATA">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn>(<b>WM_COPYDATA</b>). Then windows of this process can receive this message from lower [](xref:uac) integrity level processes.
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.Send``1(Au.wnd,System.Int32,System.ReadOnlySpan{``0},System.IntPtr)">
            <summary>
            Sends string or other data to a window of any process. Uses API <msdn>SendMessage</msdn> <msdn>WM_COPYDATA</msdn>.
            </summary>
            <typeparam name="T">Type of data elements. For example, char for string, byte for byte[].</typeparam>
            <param name="w">The window.</param>
            <param name="dataId">Data id. It is <msdn>COPYDATASTRUCT.dwData</msdn>.</param>
            <param name="data">Data. For example string or byte[]. String can contain '\0' characters.</param>
            <param name="wParam">wParam. Can be any value. Optional.</param>
            <returns><b>SendMessage</b>'s return value.</returns>
        </member>
        <member name="T:Au.wnd.more.CopyData.ResultReader`1">
            <summary>
            Type of <see cref="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})"/> callback function.
            </summary>
            <param name="span">Received data buffer. The callback function can convert it to array, string, etc.</param>
        </member>
        <member name="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})">
            <summary>
            Sends string or other data to a window of any process. Uses API <msdn>SendMessage</msdn> <msdn>WM_COPYDATA</msdn>.
            Receives string or other data returned by that window with <see cref="M:Au.wnd.more.CopyData.Return(System.Void*,System.Int32,System.IntPtr)"/>.
            </summary>
            <typeparam name="TSend">Type of data elements. For example, char for string, byte for byte[]</typeparam>
            <typeparam name="TReceive">Type of received data elements. For example, char for string, byte for byte[].</typeparam>
            <param name="w">The window.</param>
            <param name="dataId">Data id. It is <msdn>COPYDATASTRUCT.dwData</msdn>.</param>
            <param name="send">Data to send. For example string or byte[]. String can contain '\0' characters.</param>
            <param name="receive">Callback function that can convert the received data to desired format.</param>
            <returns>false if failed.</returns>
        </member>
        <member name="M:Au.wnd.more.CopyData.SendReceive``1(Au.wnd,System.Int32,System.ReadOnlySpan{``0},System.Byte[]@)">
            <summary>
            Calls <see cref="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})"/> and gets the returned data as byte[].
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.SendReceive``1(Au.wnd,System.Int32,System.ReadOnlySpan{``0},System.String@)">
            <summary>
            Calls <see cref="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})"/> and gets the returned string.
            </summary>
        </member>
        <member name="M:Au.wnd.more.CopyData.Return(System.Void*,System.Int32,System.IntPtr)">
            <summary>
            Returns data to <see cref="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})"/>.
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <param name="wParam"><i>wParam</i> of the received <b>WM_COPYDATA</b> message. Important, pass unchanged.</param>
            <returns>Your window procedure must return this value.</returns>
        </member>
        <member name="M:Au.wnd.more.CopyData.Return``1(System.ReadOnlySpan{``0},System.IntPtr)">
            <summary>
            Returns string or other data to <see cref="M:Au.wnd.more.CopyData.SendReceive``2(Au.wnd,System.Int32,System.ReadOnlySpan{``0},Au.wnd.more.CopyData.ResultReader{``1})"/>.
            </summary>
            <typeparam name="T">Type of data elements. For example, char for string, byte for byte[]</typeparam>
            <param name="data"></param>
            <param name="wParam"><i>wParam</i> of the received <b>WM_COPYDATA</b> message. Important, pass unchanged.</param>
            <returns>Your window procedure must return this value.</returns>
        </member>
        <member name="M:Au.wnd.ThrowIf0">
            <summary>
            If <see cref="P:Au.wnd.Is0"/>, throws <see cref="T:Au.Types.AuWndException"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowIfInvalid">
            <summary>
            If <see cref="P:Au.wnd.Is0"/> or !<see cref="P:Au.wnd.IsAlive"/>, throws <see cref="T:Au.Types.AuWndException"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowUseNative">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowUseNative(System.Int32)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses the specified Windows API error code and its message.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowUseNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowUseNative(System.Int32,System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and the specified Windows API error code.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.wnd.ThrowNoNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and does not use the last Windows API error.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="P:Au.wnd.Is0">
            <summary>
            Returns true if the window handle is 0 (this variable == default(wnd)).
            </summary>
            <example>
            <code><![CDATA[
            wnd w = wnd.find("Window*");
            if(w.Is0) { print.it("window not found"); return; }
            ]]></code>
            </example>
            <seealso cref="P:Au.wnd.IsAlive"/>
        </member>
        <member name="P:Au.wnd.IsAlive">
            <summary>
            Returns true if the window exists (the window handle is valid).
            Returns false if the handle is 0 or invalid.
            Invalid non-0 handle usually means that the window is closed/destroyed.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.Is0"/> and API <msdn>IsWindow</msdn>.
            Although a <b>wnd</b> variable holds a window handle, which is like a reference to a window, it does not prevent closing that window and making the handle invalid. After closing the window, the OS can even assign the same handle value to a new window, although normally it can happen only after long time.
            <note>Use this carefully with windows of other applications or threads. The window can be closed at any moment, even when your thread is still in this function.</note>
            </remarks>
        </member>
        <member name="P:Au.wnd.IsVisible">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            Calls API <msdn>IsWindowVisible</msdn>. Does not call <see cref="P:Au.wnd.IsCloaked"/>.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked, on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.wnd.IsCloaked"/>
            <seealso cref="P:Au.wnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.wnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.wnd.Activate"/>
        </member>
        <member name="P:Au.wnd.IsVisibleAndNotCloaked">
            <summary>
            Returns true if <see cref="P:Au.wnd.IsVisible"/> returns true and <see cref="P:Au.wnd.IsCloaked"/> returns false.
            </summary>
        </member>
        <member name="M:Au.wnd.IsVisibleIn_(Au.wnd)">
            <summary>
            Returns true if this window is visible in the specified parent or ancestor window.
            Like <see cref="P:Au.wnd.IsVisible"/>, but does not check the visibility of the specified parent/ancestor window.
            </summary>
            <param name="wParent">Parent or ancestor window.</param>
        </member>
        <member name="M:Au.wnd.Show(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            </summary>
            <remarks>
            Does not activate/deactivate/zorder.
            This window can be of any thread. If you know it is of this thread, use <see cref="M:Au.wnd.ShowL(System.Boolean)"/>. This function calls it.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.wnd.ShowL(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            </summary>
            <returns>Returns false if fails. Supports <see cref="T:Au.lastError"/>.</returns>
            <remarks>
            Does not activate/deactivate/zorder.
            
            There are two similar functions to show/hide a window: 
            - <see cref="M:Au.wnd.Show(System.Boolean)"/> is better to use in automation scripts, with windows of any process/thread. It calls <b>ShowL</b>, and throws exception if it fails. Adds a small delay if the window is of another thread.
            - <b>ShowL</b> is better to use in programming, with windows of current thread. It is more lightweight. Does not throw exceptions. Does not add a delay. But both functions can be used with windows of any thread.
            </remarks>
        </member>
        <member name="M:Au.wnd.IsEnabled(System.Boolean)">
            <summary>
            Returns true if the window is enabled for mouse and keyboard input.
            Returns false if disabled. Also false if failed (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="ancestorsToo">Check whether all ancestors of this control are enabled too. If false (default), this function simply calls API <msdn>IsWindowEnabled</msdn>, which usualy returns true for controls in disabled windows.</param>
        </member>
        <member name="M:Au.wnd.Enable(System.Boolean)">
            <summary>
            Enables or disables.
            Calls API <msdn>EnableWindow</msdn>.
            </summary>
            <param name="enable">Enable or disable.</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="P:Au.wnd.IsCloakedGetState">
            <summary>
            Gets the cloaked state.
            Returns 0 if not cloaked or if failed.
            Else returns flags: 1 cloaked by its application, 2 cloaked by Windows, 4 cloaked because its owner window is cloaked.
            On Windows 7 returns 0 because there is no "cloaked window" feature.
            </summary>
            <seealso cref="P:Au.wnd.IsCloaked"/>
        </member>
        <member name="P:Au.wnd.IsCloaked">
            <summary>
            Returns true if the window is cloaked.
            Returns false if not cloaked or if failed.
            On Windows 7 returns false because there is no "cloaked window" feature.
            Windows 10 uses window cloaking mostly to hide windows on inactive desktops. Windows 8 - mostly to hide Windows Store app windows.
            </summary>
            <seealso cref="P:Au.wnd.IsCloakedGetState"/>
        </member>
        <member name="P:Au.wnd.IsMinimized">
            <summary>
            Returns true if minimized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            Calls API <msdn>IsIconic</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.IsMaximized">
            <summary>
            Returns true if maximized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            Calls API <msdn>IsZoomed</msdn>.
            </summary>
        </member>
        <member name="M:Au.wnd.ShowMinimized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.wnd.ShowMaximized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.wnd.ShowNotMinMax(System.Boolean)">
            <summary>
            If maximized or minimized, makes normal (not min/max).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.wnd.ShowNotMinimized(System.Boolean)">
            <summary>
            If minimized, restores previous non-minimized state (maximized or normal).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.wnd._MinMaxRes(System.Int32,System.Boolean)">
            <summary>
            Sets window min/max/normal/restore state.
            Also unhides.
            </summary>
            <param name="state">Must be SW_MINIMIZE, SW_RESTORE (restores to normal/max if minimized), SW_SHOWNORMAL or SW_SHOWMAXIMIZED.</param>
            <param name="noAnimation">Use SetWindowPlacement (no animation).</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.wnd.GetWindowPlacement_(Au.Types.Api.WINDOWPLACEMENT@,System.Boolean,System.String)">
            <summary>
            Initializes a WINDOWPLACEMENT struct and calls API <msdn>GetWindowPlacement</msdn>.
            </summary>
            <param name="wp"></param>
            <param name="rectInScreen">Remove workarea thickness from wp.rcNormalPosition.</param>
            <param name="errStr">If not null, throws it if fails.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
            <exception cref="T:Au.Types.AuWndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="M:Au.wnd.SetWindowPlacement_(Au.Types.Api.WINDOWPLACEMENT@,System.Boolean,System.String)">
            <summary>
            Sets WINDOWPLACEMENT <b>length</b> field and calls API <msdn>SetWindowPlacement</msdn>.
            </summary>
            <param name="wp"></param>
            <param name="rectInScreen">wp.rcNormalPosition is without workarea thickness.</param>
            <param name="errStr">If not null, throws it if fails.</param>
            <exception cref="T:Au.Types.AuWndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="T:Au.wnd.Internal_">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.EnableActivate(System.Boolean)">
            <summary>
            No exceptions.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_._EnableActivate_SendKey(System.Boolean)">
            <summary>
            Sends a key (VK_0 up). It allows to activate now.
            Later this process can always activate easily (without key etc). It works even with higher IL windows.
            Don't know why is this behavior. Tested on all OS from XP to 10.
            Does not work if the foreground process has higher UAC IL.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_._EnableActivate_MinRes">
            <summary>
            Creates a temporary minimized window and restores it. It activates the window and allows us to activate.
            Then sets 'no active window' to prevent auto-activating another window when destroying the temporary window.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_._EnableActivate_AllowSetFore">
            <summary>
            Calls Api.AllowSetForegroundWindow(Api.GetCurrentProcessId()).
            </summary>
        </member>
        <member name="F:Au.wnd.Internal_.ActivateFlags.NoThrowIfInvalid">
            <summary>
            Don't call ThrowIfInvalid (ie caller ensures it is valid).
            </summary>
        </member>
        <member name="F:Au.wnd.Internal_.ActivateFlags.NoGetWindow">
            <summary>
            Don't try to get top-level window (ie caller ensures it's a top-level window, not control).
            </summary>
        </member>
        <member name="F:Au.wnd.Internal_.ActivateFlags.IgnoreIfNoActivateStyleEtc">
            <summary>
            Don't activate if has WS_EX_NOACTIVATE style or is toolwindow without caption, unless cloaked.
            Then just calls ZorderTop(), which in most cases does not work (inactive window).
            </summary>
        </member>
        <member name="F:Au.wnd.Internal_.ActivateFlags.ForScreenCapture">
            <summary>
            Wait for window animations to end. Eg when switching Win10 desktops.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.MoveInScreen(System.Boolean,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.wnd,Au.Types.RECT@,Au.screen,System.Boolean,System.Boolean,System.Nullable{Au.Types.RECT})">
            <summary>
            Used directly by MoveInScreen, EnsureInScreen, RECT.MoveInScreen, RECT.EnsureInScreen. With inRect used by RECT.MoveInRect.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.EnumWindows2(Au.wnd.Internal_.EnumAPI,System.Boolean,System.Boolean,Au.wnd,System.Boolean,System.Int32,System.Func{Au.wnd,System.Object,System.Boolean},System.Object,System.Collections.Generic.List{Au.wnd})">
            <summary>
            This version creates much less garbage.
            The caller must dispose the returned ArrayBuilder_, unless list is not null.
            If list is not null, adds windows there (clears at first) and returns default(ArrayBuilder_).
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.GetWindowsStoreAppId(Au.wnd,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns 1 if gets user model id, 2 if gets path, 0 if fails.
            </summary>
            <param name="w">Window.</param>
            <param name="appId">Receives app ID.</param>
            <param name="prependShellAppsFolder">Prepend <c>@"shell:AppsFolder\"</c> (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
        </member>
        <member name="T:Au.wnd.Internal_.WinFlags">
            <summary>
            Calls API SetProp/GetProp to set/get misc flags for a window.
            Currently unused.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.CreateWindowDWP(System.Boolean,Au.Types.WNDPROC)">
            <summary>
            Auto-registers window class "Au.DWP" with wndproc = DefWindowProc and creates hidden window.
            </summary>
            <param name="messageOnly"></param>
            <param name="wndProcUnsafe">If not null, replaces window procedure (SetWindowLongPtr). The caller must protect the delegate from GC.</param>
        </member>
        <member name="P:Au.wnd.Internal_.WindowClassDWP">
            <summary>
            Auto-registers window class "Au.DWP" with wndproc = DefWindowProc and returns "Au.DWP".
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.SubclassUnsafe(Au.wnd,Au.Types.WNDPROC)">
            <summary>
            Replaces window procedure (SetWindowLongPtr). Returns previous window procedure.
            The caller must protect the delegate from GC.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.IsSpecHwnd(Au.wnd)">
            <summary>
            Returns true if w contains a non-zero special handle value (<see cref="T:Au.Types.SpecHWND"/>).
            Note: <b>SpecHWND.TOP</b> is 0.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.FromObject(System.Object)">
            <summary>
            Converts object to wnd.
            Object can contain null, wnd, Control, or System.Windows.DependencyObject (must be in element 0 of object[]).
            Avoids loading Forms and WPF dlls when not used.
            </summary>
        </member>
        <member name="M:Au.wnd.Internal_.ToWpfElement(Au.wnd)">
            <summary>
            If w is handle of a WPF element (Window, Popup, HwndHost-ed control, HwndSource.RootVisual), returns that element, else null.
            Slow if HwndHost-ed control.
            w can be default.
            </summary>
        </member>
        <member name="T:Au.wnd.Internal_.WndList_">
            <summary>
            An enumerable list of wnd for <see cref="M:Au.wndFinder._FindOrMatch(Au.wnd.Internal_.WndList_,System.Action{Au.wnd},Au.Types.WFCache)"/> and <see cref="M:Au.wndChildFinder._FindInList(Au.wnd,Au.wnd.Internal_.WndList_,System.Action{Au.wnd})"/>.
            Holds ArrayBuilder_ or IEnumerator or single wnd or none.
            Must be disposed if it is ArrayBuilder_ or IEnumerator, else disposing is optional.
            </summary>
        </member>
        <member name="M:Au.wnd.Activate_(Au.wnd.Internal_.ActivateFlags)">
            <summary>
            Activates this window (brings to the foreground).
            The same as <see cref="M:Au.wnd.Activate"/>, but has some options.
            Returns false if does not activate because of flag IgnoreIfNoActivateStyleEtc.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.wnd.Activate">
            <summary>
            Activates this window. Also makes it visible and not minimized.
            The active window is in the foreground and receives keyboard and mouse input.
            </summary>
            <remarks>
            Activating a window usually also uncloaks it, for example switches to its virtual desktop on Windows 10.
            Fails (throws exception) if cannot activate this window, except:
            - If this is a control. Then activates its top-level parent window.
            - If this is <see cref="P:Au.wnd.getwnd.root"/>. Then just deactivates the currently active window.
            - When the target application instead activates another window of the same thread.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="M:Au.wnd.ActivateL"/>
            <seealso cref="P:Au.wnd.IsActive"/>
            <seealso cref="P:Au.wnd.active"/>
            <seealso cref="M:Au.wnd.switchActiveWindow"/>
        </member>
        <member name="M:Au.wnd.ActivateL">
            <summary>
            Lightweight version of <see cref="M:Au.wnd.Activate"/>.
            Just calls <see cref="M:Au.wnd.more.enableActivate(System.Int32)"/>, API <msdn>SetForegroundWindow</msdn> and makes sure that it actually worked, but does not check whether it activated exactly this window.
            No exceptions, does not unhide, does not restore minimized, does not check is it a top-level window or control, etc.
            Returns false if fails.
            </summary>
        </member>
        <member name="M:Au.wnd.Focus">
            <summary>
            Sets the keyboard input focus to this control.
            Also activetes its top-level parent window (see <see cref="M:Au.wnd.Activate"/>).
            </summary>
            <remarks>
            The control can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="M:Au.wnd.thisThread.focus(Au.wnd)"/>.
            Works not with all windows. For example, does not work with Windows Store apps. Then use <see cref="M:Au.elm.Focus(System.Boolean)"/>.
            Can instead focus a child control. For example, if this is a ComboBox, it will focus its child Edit control. Then does not throw exception.
            This can be control or top-level window. Top-level windows also can have focus.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">
            - Invalid handle.
            - Disabled.
            - Failed to set focus.
            - Failed to activate parent window.
            Fails to set focus when the target process is admin or uiAccess and this process isn't. See [](xref:uac).
            </exception>
            <seealso cref="P:Au.wnd.focused"/>
            <seealso cref="P:Au.wnd.IsFocused"/>
            <seealso cref="M:Au.elm.Focus(System.Boolean)"/>
        </member>
        <member name="P:Au.wnd.focused">
            <summary>
            Gets the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            The control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="P:Au.wnd.thisThread.focused"/>.
            Calls API <msdn>GetGUIThreadInfo</msdn>.
            </remarks>
            <seealso cref="M:Au.wnd.Focus"/>
            <seealso cref="P:Au.wnd.IsFocused"/>
        </member>
        <member name="P:Au.wnd.IsFocused">
            <summary>
            Returns true if this is the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            This control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="M:Au.wnd.thisThread.isFocused(Au.wnd)"/>.
            Calls <see cref="P:Au.wnd.focused"/>.
            </remarks>
            <seealso cref="M:Au.wnd.Focus"/>
        </member>
        <member name="T:Au.wnd.thisThread">
            <summary>
            Functions that can be used only with windows/controls of this thread.
            </summary>
        </member>
        <member name="M:Au.wnd.thisThread.focus(Au.wnd)">
            <summary>
            Calls API <msdn>SetFocus</msdn>. It sets the keyboard input focus to the specified control or window, which must be of this thread.
            Returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            Fails if the control/window belongs to another thread or is invalid or disabled.
            Can instead focus a child control. For example, if ComboBox, will focus its child Edit control. Then returns true.
            </remarks>
        </member>
        <member name="P:Au.wnd.thisThread.focused">
            <summary>
            Gets the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="M:Au.wnd.thisThread.isFocused(Au.wnd)">
            <summary>
            Returns true if w is the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="P:Au.wnd.thisThread.active">
            <summary>
            Gets the active window of this thread.
            Calls API <msdn>GetActiveWindow</msdn>.
            </summary>
        </member>
        <member name="M:Au.wnd.GetRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="withoutExtendedFrame">Don't include the transparent part of window border. For it is used API <msdn>DwmGetWindowAttribute</msdn>(DWMWA_EXTENDED_FRAME_BOUNDS); it is less reliable.</param>
            <remarks>
            The same as the <see cref="P:Au.wnd.Rect"/> property.
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.Rect">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <remarks>
            Calls <see cref="M:Au.wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.GetClientRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets client area rectangle.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="inScreen">
            Get rectangle in screen coordinates; like <see cref="M:Au.wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)"/> but faster.
            If false (default), calls API <msdn>GetClientRect</msdn>; the same as <see cref="P:Au.wnd.ClientRect"/>.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ClientRect">
            <summary>
            Gets client area rectangle (width and height).
            </summary>
            <remarks>
            The left and top fields are always 0.
            Calls <see cref="M:Au.wnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.wnd.ClientRectInScreen">
            <summary>
            Gets client area rectangle (width and height) in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.wnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.wnd.ResizeClient(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Resizes this window to match specifient client area size.
            Calls <see cref="M:Au.wnd.ResizeL(System.Int32,System.Int32)"/>.
            </summary>
            <param name="width">Client area width. Use null to not change.</param>
            <param name="height">Client area height. Use null to not change.</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.wnd.GetWindowInfo_(Au.Types.Api.WINDOWINFO@)">
            <summary>
            Calls API <msdn>GetWindowInfo</msdn>.
            </summary>
            <param name="wi">Receives window/client rectangles, styles etc.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)">
            <summary>
            Gets window rectangle and client area rectangle, both in screen coordinates.
            </summary>
            <param name="rWindow">Receives window rectangle.</param>
            <param name="rClient">Receives client area rectangle.</param>
            <remarks>Calls API <msdn>GetWindowInfo</msdn>. Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToClientOf(Au.wnd,Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToClientOf(Au.wnd,Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapScreenToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapScreenToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToWindow(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapClientToWindow(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapWindowToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapWindowToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapWindowToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.MapWindowToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.GetRectIn(Au.wnd,Au.Types.RECT@)">
            <summary>
            Gets rectangle of this window (usually control) relative to the client area of another window (usually parent).
            </summary>
            <param name="w">Parent, ancestor or any other window or control. If <c>default(wnd)</c>, gets rectangle in screen.</param>
            <param name="r">Receives the rectangle.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
            <seealso cref="P:Au.wnd.RectInDirectParent"/>
            <seealso cref="P:Au.wnd.RectInWindow"/>
        </member>
        <member name="P:Au.wnd.RectInDirectParent">
            <summary>
            Gets child window rectangle in the client area of the direct parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.getwnd.DirectParent"/> and <see cref="M:Au.wnd.GetRectIn(Au.wnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.wnd.RectInWindow">
            <summary>
            Gets child window rectangle in the client area of the top-level parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.Window"/> and <see cref="M:Au.wnd.GetRectIn(Au.wnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.wnd.GetRectNotMinMax(Au.Types.RECT@)">
            <summary>
            Gets rectangle of normal (restored) window even if currently it is minimized or maximized.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.MouseClientXY">
            <summary>
            Returns mouse pointer position relative to the client area of this window.
            </summary>
        </member>
        <member name="M:Au.wnd.ContainsScreenXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this window (its rectangle) contains the specified point.
            </summary>
            <param name="x">X coordinate in screen. Not used if default(Coord).</param>
            <param name="y">Y coordinate in screen. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.wnd.ContainsWindowXY(Au.wnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this control (its rectangle) contains the specified point in parent window.
            </summary>
            <param name="parent">
            Direct or indirect parent window. The coordinates are relative to its client area.
            Actually this and parent can be any windows or controls, the function does not check whether this is a child of parent.
            </param>
            <param name="x">X coordinate. Not used if default(Coord).</param>
            <param name="y">Y coordinate. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.wnd.ContainsWindowXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            This overload calls <see cref="M:Au.wnd.ContainsWindowXY(Au.wnd,Au.Types.Coord,Au.Types.Coord)"/>(Window, x, y).
            </summary>
        </member>
        <member name="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)">
            <summary>
            Calls API <msdn>SetWindowPos</msdn>.
            </summary>
            <param name="swpFlags"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="cx"></param>
            <param name="cy"></param>
            <param name="zorderAfter">A window or <see cref="T:Au.Types.SpecHWND"/>.<b>TOP</b>, <b>BOTTOM</b>, <b>TOPMOST</b>, <b>NOTOPMOST</b>.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.MoveL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.SWPFlags)">
            <summary>
            Moves and resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max, does not support SWP flags.
            This function is more lightweight, it just calls API <msdn>SetWindowPos</msdn> with flags NOZORDER|NOOWNERZORDER|NOACTIVATE|swpFlagsToAdd. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.lastError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)"/>
        </member>
        <member name="M:Au.wnd.MoveL(Au.Types.RECT,Au.Types.SWPFlags)">
            <summary>
            Moves and resizes. Same as <see cref="M:Au.wnd.MoveL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.SWPFlags)"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.MoveL(System.Int32,System.Int32)">
            <summary>
            Moves.
            </summary>
            <remarks>
            See also <see cref="M:Au.wnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is more lightweight, it just calls API <msdn>SetWindowPos</msdn> with flags NOSIZE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.lastError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)"/>
        </member>
        <member name="M:Au.wnd.ResizeL(System.Int32,System.Int32)">
            <summary>
            Resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.wnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is more lightweight, it just calls API <msdn>SetWindowPos</msdn> with flags NOMOVE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
            <seealso cref="M:Au.wnd.SetWindowPos(Au.Types.SWPFlags,System.Int32,System.Int32,System.Int32,System.Int32,Au.wnd)"/>
        </member>
        <member name="M:Au.wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)">
            <summary>
            Moves and/or resizes.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea"><i>x y width height</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y width height</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window. Example: <c>screen.index(1)</c>.</param>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client area coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.wnd.MoveL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.SWPFlags)"/>.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.wnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)">
            <summary>
            Moves.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="workArea"><i>x y</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window. Example: <c>screen.index(1)</c>.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.wnd.MoveL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen)">
            <summary>
            Resizes.
            </summary>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea">For <see cref="M:Au.Types.Coord.Fraction(System.Double)"/> etc use width/height of the work area. Not used when this is a child window.</param>
            <param name="screen">For <b>Coord.Fraction</b> etc use width/height of this screen. Default - primary. Not used when this is a child window. Example: <c>screen.index(1)</c>.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            With windows of current thread usually it's better to use <see cref="M:Au.wnd.ResizeL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)">
            <summary>
            Moves this window to coordinates x y in specified screen, and ensures that entire window is in screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="screen">Move to this screen (see <see cref="T:Au.screen"/>). If default, uses screen of this window. Example: <c>screen.index(1)</c>.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of window is not in screen, move and/or resize it so that entire window would be in screen. Default true.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately, except when moving maximized to another screen.
            </remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.EnsureInScreen(Au.screen,System.Boolean)">
            <summary>
            Moves this window if need, to ensure that entire window is in screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.screen"/>). If default, uses screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately.
            </remarks>
            <seealso cref="M:Au.Types.RECT.EnsureInScreen(Au.screen,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.MoveToScreenCenter(Au.screen)">
            <summary>
            Moves this window to the center of the screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.screen"/>). If default, uses screen of this window.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>Calls <c>ShowNotMinMax(true)</c> and <c>MoveInScreen(default, default, screen, true)</c>.</remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.screen,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.wnd.Screen">
            <summary>
            Gets <see cref="T:Au.screen"/> of the screen that contains this window (the biggest part of it) or is nearest to it.
            If this window handle is default(wnd) or invalid, gets the primary screen.
            Calls <see cref="M:Au.screen.of(Au.wnd,Au.Types.SODefault,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.ZorderAbove(Au.wnd,System.Boolean)">
            <summary>
            Places this window above window w in the Z order.
            </summary>
            <param name="w"></param>
            <param name="ownerToo">Change Z order of owner window too.</param>
            <remarks>
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            If w is default(wnd), calls <see cref="M:Au.wnd.ZorderBottom"/>.
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; it depends on many documented and undocumented conditions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ZorderBelow(Au.wnd,System.Boolean)">
            <summary>
            Places this window below window w in the Z order.
            </summary>
            <param name="w"></param>
            <param name="ownerToo">Change Z order of owner window too.</param>
            <remarks>
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            If w is default(wnd), calls <see cref="M:Au.wnd.ZorderTop(System.Boolean)"/>.
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; its behavior depends on many documented and undocumented conditions and changes with new OS versions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ZorderTop(System.Boolean)">
            <summary>
            Places this window or control at the top of the Z order. Does not activate.
            If the window was topmost, it will be at the top of topmost windows, else at the top of non-topmost windows.
            </summary>
            <param name="ownerToo">Change Z order of owner window too.</param>
            <remarks>
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; its behavior depends on many documented and undocumented conditions and changes with new OS versions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ZorderBottom">
            <summary>
            Places this window or control at the bottom of the Z order.
            If the window was topmost, makes it and its owner window non-topmost.
            </summary>
            <remarks>
            Changes Z order of owner window too.
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; its behavior depends on many documented and undocumented conditions and changes with new OS versions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ZorderTopmost(System.Boolean)">
            <summary>
            Makes this window topmost (always on top of non-topmost windows in the Z order). Does not activate.
            </summary>
            <param name="ownerToo">Change Z order of owner window too.</param>
            <remarks>
            This cannot be a control.
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; its behavior depends on many documented and undocumented conditions and changes with new OS versions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ZorderNoTopmost(System.Boolean)">
            <summary>
            Makes this window non-topmost.
            </summary>
            <param name="afterActiveWindow">Also place this window below the active nontopmost window in the Z order, unless the active window is this or owner.</param>
            <remarks>
            Changes Z order of owner window too.
            This cannot be a control.
            Uses API <msdn>SetWindowPos</msdn>. It may refuse to change Z order of top-level windows; its behavior depends on many documented and undocumented conditions and changes with new OS versions; can even return true when failed.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.IsTopmost">
            <summary>
            Returns true if this is a topmost (always-on-top) window.
            </summary>
        </member>
        <member name="M:Au.wnd.ZorderIsAbove(Au.wnd)">
            <summary>
            Returns true if this window is above window w in the Z order.
            </summary>
        </member>
        <member name="P:Au.wnd.Style">
            <summary>
            Gets window style.
            </summary>
            <value>One or more <see cref="T:Au.Types.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</value>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
            <seealso cref="M:Au.wnd.HasStyle(Au.Types.WS,System.Boolean)"/>
            <seealso cref="M:Au.wnd.SetStyle(Au.Types.WS,Au.Types.WSFlags)"/>
        </member>
        <member name="P:Au.wnd.ExStyle">
            <summary>
            Gets window extended style.
            </summary>
            <value>One or more <see cref="T:Au.Types.WSE"/> flags. Reference: <msdn>extended window styles</msdn>.</value>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
            <seealso cref="M:Au.wnd.HasExStyle(Au.Types.WSE,System.Boolean)"/>
            <seealso cref="M:Au.wnd.SetExStyle(Au.Types.WSE,Au.Types.WSFlags)"/>
        </member>
        <member name="M:Au.wnd.HasStyle(Au.Types.WS,System.Boolean)">
            <summary>
            Returns true if the window has all specified style flags (see <see cref="P:Au.wnd.Style"/>).
            </summary>
            <param name="style">One or more styles.</param>
            <param name="any">
            Return true if has any (not necessary all) of the specified styles.
            Note: don't use <see cref="F:Au.Types.WS.CAPTION"/>, because it consists of two other styles - BORDER and DLGFRAME.
            </param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.HasExStyle(Au.Types.WSE,System.Boolean)">
            <summary>
            Returns true if the window has all specified extended style flags (see <see cref="P:Au.wnd.ExStyle"/>).
            </summary>
            <param name="exStyle">One or more extended styles.</param>
            <param name="any">Return true if has any (not necessary all) of the specified styles.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.SetStyle(Au.Types.WS,Au.Types.WSFlags)">
            <summary>
            Changes window style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="P:Au.wnd.Style"/>
        </member>
        <member name="M:Au.wnd.SetExStyle(Au.Types.WSE,Au.Types.WSFlags)">
            <summary>
            Changes window extended style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.WSE"/> flags. Reference: <msdn>extended window styles</msdn>.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="P:Au.wnd.ExStyle"/>
        </member>
        <member name="P:Au.wnd.IsPopupWindow">
            <summary>
            Returns true if has WS.POPUP style.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.IsToolWindow">
            <summary>
            Returns true if has WSE.TOOLWINDOW style.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.IsResizable">
            <summary>
            Returns true if has WS.THICKFRAME style.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.GetWindowLong(System.Int32)">
            <summary>
            Calls API <msdn>GetWindowLongPtr</msdn>.
            </summary>
            <param name="index">A constant from <see cref="T:Au.Types.GWL"/>, or an offset in window memory reserved when registering window class.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            In 32-bit process actually calls <b>GetWindowLong</b>, because <b>GetWindowLongPtr</b> is unavailable.
            </remarks>
        </member>
        <member name="M:Au.wnd.SetWindowLong(System.Int32,System.IntPtr)">
            <summary>
            Calls API <msdn>SetWindowLongPtr</msdn>.
            </summary>
            <param name="index">A constant from <see cref="T:Au.Types.GWL"/>, or an offset in window memory reserved when registering window class.</param>
            <param name="newValue">New value.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            See also API <msdn>SetWindowSubclass</msdn>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ControlId">
            <summary>
            Gets or sets id of this control.
            The 'get' function supports <see cref="T:Au.lastError"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.wnd.Prop">
            <summary>
            Returns an object that manages window properties using API <msdn>SetProp</msdn> and co.
            </summary>
            <example>
            <code><![CDATA[
            var w = wnd.find("* Explorer");
            w.Prop.Set("example", 5);
            print.it(w.Prop["example"]);
            print.it(w.Prop); //all w properties
            w.Prop.Remove("example"); //you should always remove window properties if don't want to see unrelated applications crashing after some time. And don't use many unique property names.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.GetThreadProcessId(System.Int32@)">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns thread id and also gets process id.
            Returns 0 if fails. Supports <see cref="T:Au.lastError"/>.
            <note>It is native thread id, not Thread.ManagedThreadId.</note>
            </summary>
        </member>
        <member name="P:Au.wnd.ThreadId">
            <summary>
            Gets native thread id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ProcessId">
            <summary>
            Gets native process id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="P:Au.wnd.IsOfThisThread">
            <summary>
            Returns true if this window belongs to the current thread, false if to another thread.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.IsOfThisProcess">
            <summary>
            Returns true if this window belongs to the current process, false if to another process.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.IsUnicode">
            <summary>
            Returns true if the window is a Unicode window, false if ANSI.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            Calls API <msdn>IsWindowUnicode</msdn>.
            </summary>
        </member>
        <member name="P:Au.wnd.Is32Bit">
            <summary>
            Returns true if the window is of a 32-bit process, false if of a 64-bit process.
            Also returns false if fails. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            <note>If you know that the window belongs to current process, instead use <c>IntPtr.Size==4</c>. This function is much slower.</note>
            </remarks>
        </member>
        <member name="P:Au.wnd.IsHung">
            <summary>
            Returns true if thread of this window is considered hung (not responding).
            Calls API <msdn>IsHungAppWindow</msdn>.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.IsHungGhost">
            <summary>
            Returns true if the window is a ghost window that the system creates over a hung (not responding) window to allow the user to minimally interact with it.
            </summary>
        </member>
        <member name="P:Au.wnd.IsConsole">
            <summary>
            Returns true if this is a console window (class name "ConsoleWindowClass").
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.Uac">
            <summary>
            Gets UAC info of the process.
            </summary>
        </member>
        <member name="P:Au.wnd.UacAccessDenied">
            <summary>
            Returns true if [](xref:uac) would not allow to automate the window.
            It happens when current process has lower UAC integrity level and is not uiAccess, unless UAC is turned off.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.IsMessageOnly">
            <summary>
            Returns true if this is a <msdn>message-only window</msdn>.
            </summary>
            <remarks>
            To find message-only windows use <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ClassName">
            <summary>
            Gets window class name.
            Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.lastError"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.ClassNameIs(System.String)">
            <summary>
            Returns true if the class name of this window matches cn. Else returns false.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="cn">Class name. Case-insensitive wildcard. See <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>. Cannot be null.</param>
            <seealso cref="M:Au.wnd.IsMatch(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>
        </member>
        <member name="M:Au.wnd.ClassNameIs(System.String[])">
            <summary>
            If window class name matches one of strings in <i>classNames</i>, returns 1-based string index. Else returns 0.
            Also returns 0 if fails to get class name (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="classNames">Class names. Case-insensitive wildcard. See <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.wnd.Name">
            <summary>
            Gets name.
            Returns "" if no name. Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            Top-level window name usually its title bar text.
            Control name usually is its text that does not change, for example button or static (label) control text.
            Unlike <see cref="P:Au.wnd.ControlText"/>, this function usually does not get variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            Calls <see cref="M:Au.wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(false, true).
            </remarks>
            <seealso cref="M:Au.wnd.SetText(System.String)"/>
            <seealso cref="P:Au.wnd.ControlText"/>
            <seealso cref="P:Au.wnd.NameElm"/>
            <seealso cref="P:Au.wnd.NameWinforms"/>
        </member>
        <member name="M:Au.wnd.NameIs(System.String[])">
            <summary>
            If window name matches one of strings in <i>names</i>, returns 1-based string index. Else returns 0.
            Also returns 0 if fails to get name (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="names">Window names. Case-insensitive wildcard. See <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.wnd.NameTL_">
            <summary>
            Gets window name using API InternalGetWindowText. The same as GetText(false, false).
            This should be a top-level window, because does not process ampersands.
            </summary>
        </member>
        <member name="P:Au.wnd.ControlText">
            <summary>
            Gets control text.
            Returns "" if no text. Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.lastError"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.wnd.Name"/>, this function prefers variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            For controls that cannot have such text (eg button, static), it usually gets the same text as <b>Name</b>. For example button and static (label) controls.
            Much slower than <b>Name</b>. Fails if the window is hung.
            Calls <see cref="M:Au.wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(true, false).
            </remarks>
            <seealso cref="M:Au.wnd.SetText(System.String)"/>
            <seealso cref="P:Au.wnd.Name"/>
        </member>
        <member name="M:Au.wnd.GetText(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets window/control name or control text.
            Returns "" if it is empty.
            Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.lastError"/>.
            This is a low-level function. You can instead use <see cref="P:Au.wnd.Name"/> and <see cref="P:Au.wnd.ControlText"/>.
            </summary>
            <param name="getText">
            How to get text:
            - false - use API <msdn>InternalGetWindowText</msdn>. This is used by <see cref="P:Au.wnd.Name"/>.
            - true - use API <msdn>WM_GETTEXT</msdn>. It is slow and prefers editable text. This is used by <see cref="P:Au.wnd.ControlText"/>. Fails if the window is hung.
            - null - try <b>InternalGetWindowText</b>. If it gets "" and this is a control, then try WM_GETTEXT.
            </param>
            <param name="removeUnderlineAmpersand">
            Remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            Removes only if this is a control (has style WS.CHILD).
            Calls <see cref="M:Au.More.StringUtil.RemoveUnderlineChar(System.String,System.Char)"/>.
            </param>
            <seealso cref="M:Au.wnd.SetText(System.String)"/>
            <seealso cref="P:Au.wnd.NameElm"/>
            <seealso cref="P:Au.wnd.NameWinforms"/>
        </member>
        <member name="M:Au.wnd._GetTextFast(System.Boolean)">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="T:Au.lastError"/>.
            Calls API InternalGetWindowText. If it fails, and getControlTextIfEmpty==true, and this is a control, calls _GetTextSlow, which uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.wnd._GetTextSlow">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="T:Au.lastError"/>.
            Uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.wnd.SetText(System.String)">
            <summary>
            Sets window/control name or control text.
            </summary>
            <param name="text">Text. Can be null, it is the same as "".</param>
            <remarks>
            Uses API <msdn>WM_SETTEXT</msdn>.
            Top-level window name usually its title bar text.
            For variable-text controls (edit, combo box, status bar, ...) this usually is the text that <see cref="P:Au.wnd.ControlText"/> would get.
            For other controls (button, static, ...) and top-level windows this usually is the text that <see cref="P:Au.wnd.Name"/> would get.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">Failed, for example the window is closed.</exception>
            <seealso cref="M:Au.wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>
            <seealso cref="P:Au.wnd.Name"/>
            <seealso cref="P:Au.wnd.ControlText"/>
        </member>
        <member name="P:Au.wnd.NameElm">
            <summary>
            Gets <see cref="P:Au.elm.Name"/> of the UI element (role WINDOW) of this window or control.
            Returns "" if the object has no name or failed to get it. Returns null if invalid window handle.
            </summary>
        </member>
        <member name="P:Au.wnd.NameWinforms">
            <summary>
            Gets Control.Name property of a .NET Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <remarks>
            <note>Use this with controls of other processes. Don't use with your controls, when you have a Control object.</note>
            
            <note>Slow when getting names of multiple controls in a window. Instead create an <see cref="T:Au.More.WinformsControlNames"/> instance and call its <see cref="M:Au.More.WinformsControlNames.GetControlName(Au.wnd)"/> method for each control.</note>
            </remarks>
            <seealso cref="M:Au.More.WinformsControlNames.IsWinformsControl(Au.wnd)"/>
        </member>
        <member name="P:Au.wnd.ProgramName">
            <summary>
            Gets filename of process executable file, like "notepad.exe".
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.ProcessId"/> and <see cref="M:Au.process.getName(System.Int32,System.Boolean,System.Boolean)"/>.
            This function is much slower than getting window name or class name. Don't use code like <c>if(w.ProgramName=="A" || w.ProgramName=="B")</c>. Instead use <c>var s=w.ProgramName; if(s=="A" || s=="B")</c>.
            </remarks>
        </member>
        <member name="M:Au.wnd.ProgramNameIs(System.String[])">
            <summary>
            If window program name matches one of strings in <i>programNames</i>, returns 1-based string index. Else returns 0.
            Also returns 0 if fails to get program name (probably window closed or 0 handle). Supports <see cref="T:Au.lastError"/>.
            </summary>
            <param name="programNames">Program names, like "notepad.exe". Case-insensitive wildcard. See <see cref="M:Au.ExtString.Like(System.String,System.String,System.Boolean)"/>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.wnd.ProgramPath">
            <summary>
            Gets full path of process executable file.
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.ProcessId"/> and <see cref="M:Au.process.getName(System.Int32,System.Boolean,System.Boolean)"/>.
            This function is much slower than getting window name or class name. Don't use code like <c>if(w.ProgramPath=="A" || w.ProgramPath=="B")</c>. Instead use <c>var s=w.ProgramPath; if(s=="A" || s=="B")</c>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ProgramDescription">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.wnd.ProcessId"/> and <see cref="M:Au.process.getDescription(System.Int32)"/>.
            This function is slow. Much slower than <see cref="P:Au.wnd.ProgramName"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the window.
            Returns true if successfuly closed or if it was already closed (the handle is 0 or invalid) or if <i>noWait</i>==true.
            </summary>
            <param name="noWait">
            If true, does not wait until the window is closed.
            If false, waits about 1 s (depends on window type etc) until the window is destroyed or disabled.
            </param>
            <param name="useXButton">
            If false (default), uses API message <msdn>WM_CLOSE</msdn>.
            If true, uses API message <msdn>WM_SYSCOMMAND SC_CLOSE</msdn>, like when the user clicks the X button in the title bar.
            Most windows can be closed with any of these messages, but some respond properly only to one of them. For example, some applications on WM_CLOSE don't exit, although the main window is closed. Some applications don't respond to WM_SYSCOMMAND if it is posted soon after opening the window, for example Internet Explorer.
            </param>
            <remarks>
            The window may refuse to be closed. For example, it may be hung, or hide itself instead, or display a "Save?" message box, or is a dialog without X button, or just need more time to close it.
            If the window is of this thread, just calls <see cref="M:Au.wnd.Send(System.Int32,System.IntPtr,System.IntPtr)"/> or <see cref="M:Au.wnd.Post(System.Int32,System.IntPtr,System.IntPtr)"/> (if <i>noWait</i>==true) and returns true.
            </remarks>
            <seealso cref="M:Au.wnd.WaitForClosed(System.Double,System.Boolean)"/>
            <example>
            <code><![CDATA[
            //close all Notepad windows
            wnd.findAll("* Notepad", "Notepad").ForEach(t => t.Close());
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)">
            <summary>
            Finds a child control and returns its handle as wnd.
            </summary>
            <returns>Returns <c>default(wnd)</c> if not found. See also: <see cref="P:Au.wnd.Is0"/>, <see cref="M:Au.wnd.op_UnaryPlus(Au.wnd)"/>.</returns>
            <param name="name">
            Control name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. "" means 'no name'.
            
            By default to get control names this function uses <see cref="P:Au.wnd.Name"/>.
            Can start with these prefix strings:
            - <c>"***text "</c> - use <see cref="P:Au.wnd.ControlText"/>. Slower and less reliable because can get editable text. If a character can be underlined with Alt, insert '&amp;' before it.
            - <c>"***elmName "</c> - use <see cref="P:Au.wnd.NameElm"/>. Slower.
            - <c>"***wfName "</c> - use .NET Forms control name (see <see cref="T:Au.More.WinformsControlNames"/>). Slower and can fail because of [](xref:uac).
            - <c>"***id "</c> like <c>"***id 15"</c> - use control id (<see cref="P:Au.wnd.ControlId"/>). See also <see cref="M:Au.wnd.ChildById(System.Int32,Au.Types.WCFlags)"/>.
            </param>
            <param name="cn">
            Control class name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "".
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching control.
            It can evaluate more properties of the control and return true when they match.
            Example: <c>also: t =&gt; t.IsEnabled</c>
            </param>
            <param name="skip">
            0-based index of matching control.
            For example, if 1, the function skips the first matching control and returns the second.
            </param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <exception cref="T:System.ArgumentException">
            - <i>name</i> starts with <c>"***"</c>, but the prefix is invalid.
            - <i>cn</i> is "". To match any, use null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
            <remarks>
            To create code for this function, use dialog "Find window or control".
            </remarks>
        </member>
        <member name="M:Au.wnd.HasChild(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            <note>
            Using this function many times with same parameters is inefficient. Instead create new <see cref="T:Au.wndChildFinder"/> and call <see cref="M:Au.wndChildFinder.Find(Au.wnd)"/> or <see cref="M:Au.wnd.HasChild(Au.wndChildFinder)"/>. See example.
            </note>
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:System.ArgumentException"/>
            <example>
            <code><![CDATA[
            //find window that contains certain control, and get the control too
            var f = new wndChildFinder("Password*", "Static"); //control properties
            wnd w = wnd.find(cn: "#32770", also: t => t.HasChild(f));
            print.it(w);
            print.it(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.HasChild(Au.wndChildFinder)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.wndChildFinder.Find(Au.wnd)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var cf = new wndChildFinder("Password*", "Static"); //control properties
            wnd w = wnd.find(cn: "#32770", also: t => t.HasChild(cf));
            print.it(w);
            print.it(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.HasElm(Au.elmFinder)">
            <summary>
            Returns true if this window contains the specified UI element.
            Calls <see cref="M:Au.elmFinder.Find(Au.wnd,Au.wndChildFinder)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <example>
            Find window that contains certain UI element, and get the UI element too.
            <code><![CDATA[
            var ef = new elmFinder("BUTTON", "OK"); //UI element properties
            wnd w = wnd.find(cn: "#32770", also: t => t.HasElm(ef));
            print.it(w);
            print.it(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.ChildById(System.Int32,Au.Types.WCFlags)">
            <summary>
            Finds a child control by its id and returns its handle as wnd.
            </summary>
            <returns>Returns <c>default(wnd)</c> if not found. See also: <see cref="P:Au.wnd.Is0"/>, <see cref="M:Au.wnd.op_UnaryPlus(Au.wnd)"/>.</returns>
            <param name="id">Control id.</param>
            <param name="flags">This function supports flags DirectChild and HiddenToo. If both are set, it is much faster because uses API <msdn>GetDlgItem</msdn>. Else uses API <msdn>EnumChildWindows</msdn>, like <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.</param>
            <remarks>
            To create code for this function, use dialog "Find window or control".
            
            Not all controls have a useful id. If control id is not unique or is different in each window instance, this function is not useful.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean})">
            <summary>
            Finds all matching child controls.
            Returns List containing 0 or more control handles as wnd.
            Everything except the return type is the same as with <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:System.ArgumentException"/>
            <remarks>
            In the returned list, hidden controls (when using WCFlags.HiddenToo) are always after visible controls.
            </remarks>
            <seealso cref="M:Au.wnd.getwnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.ChildFast(System.String,System.String,Au.wnd)">
            <summary>
            Finds a direct child control and returns its handle as wnd.
            </summary>
            <returns>Returns <c>default(wnd)</c> if not found. See also: <see cref="P:Au.wnd.Is0"/>, <see cref="M:Au.wnd.op_UnaryPlus(Au.wnd)"/>. Supports <see cref="T:Au.lastError"/>.</returns>
            <param name="name">
            Name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. "" means 'no name'.
            Must include the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </param>
            <param name="cn">
            Class name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="wAfter">If used, starts searching from the next control in the Z order.</param>
            <remarks>
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>, which uses API <msdn>EnumChildWindows</msdn>.
            Can be used only when you know full name and/or class name.
            Finds hidden controls too.
            </remarks>
        </member>
        <member name="T:Au.wnd.getwnd">
            <summary>
            Static functions of this class are used to get special windows (used like <c>wnd w = wnd.getwnd.top;</c>) and all windows.
            Instances of this class are used to get related windows and controls, like <c>wnd w2 = w1.Get.FirstChild;</c> (here w1 is a <b>wnd</b> variable).
            </summary>
        </member>
        <member name="M:Au.wnd.getwnd.Children(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls, including all descendants.
            Returns array containing 0 or more control handles as wnd.
            </summary>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <param name="directChild">Need only direct children, not all descendants.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Calls API <msdn>EnumChildWindows</msdn>.
            </remarks>
            <seealso cref="M:Au.wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean})"/>
        </member>
        <member name="M:Au.wnd.getwnd.Children(System.Collections.Generic.List{Au.wnd}@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls, including all descendants.
            </summary>
            <param name="a">Receives window handles as wnd. If null, this function creates new List, else clears before adding items.</param>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <param name="directChild">Need only direct children, not all descendants.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Use this overload to avoid much garbage when calling frequently with the same List variable. Other overload always allocates new array. This overload in most cases reuses memory allocated for the list variable.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            Returns array containing window handles as <b>wnd</b>.
            </summary>
            <param name="onlyVisible">
            Need only visible windows.
            Note: this function does not check whether windows are cloaked, as it is rather slow. Use <see cref="P:Au.wnd.IsCloaked"/> if need.
            </param>
            <param name="sortFirstVisible">
            Place hidden windows at the end of the array. If false, the order of array elements matches the Z order.
            Not used when <i>onlyVisible</i> is true.</param>
            <remarks>
            Calls API <msdn>EnumWindows</msdn>.
            <note>The array can be bigger than you expect, because there are many invisible windows, tooltips, etc. See also <see cref="M:Au.wnd.getwnd.mainWindows(System.Boolean)"/>.</note>
            Skips message-only windows; use <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/> if need.
            On Windows 8 and later may skip Windows Store app Metro-style windows (on Windows 10 few such windows exist). It happens if this program does not have disableWindowFiltering true in its manifest and is not uiAccess; to find such windows you can use <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/>.
            Tip: To get top-level and child windows in single array: <c>var a = wnd.getwnd.root.Get.Children();</c>.
            </remarks>
            <seealso cref="M:Au.wnd.getwnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>
            <seealso cref="M:Au.wnd.findAll(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>
        </member>
        <member name="M:Au.wnd.getwnd.allWindows(System.Collections.Generic.List{Au.wnd}@,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            </summary>
            <param name="a">Receives window handles as <b>wnd</b>. If null, this function creates new List, else clears before adding items.</param>
            <param name="onlyVisible"></param>
            <param name="sortFirstVisible"></param>
            <remarks>
            Use this overload to avoid much garbage when calling frequently with the same List variable. Other overload always allocates new array. This overload in most cases reuses memory allocated for the list variable.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.threadWindows(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            Returns array containing 0 or more window handles as <b>wnd</b>.
            </summary>
            <param name="threadId">
            Unmanaged thread id.
            See <see cref="P:Au.process.thisThreadId"/>, <see cref="P:Au.wnd.ThreadId"/>.
            If 0, throws exception. If other invalid value (ended thread?), returns empty list. Supports <see cref="T:Au.lastError"/>.
            </param>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <exception cref="T:System.ArgumentException">0 threadId.</exception>
            <remarks>
            Calls API <msdn>EnumThreadWindows</msdn>.
            </remarks>
            <seealso cref="M:Au.process.thisThreadHasMessageLoop(System.Boolean@)"/>
        </member>
        <member name="M:Au.wnd.getwnd.threadWindows(System.Collections.Generic.List{Au.wnd}@,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            </summary>
            <remarks>This overload can be used to avoid much garbage when caling frequently.</remarks>
        </member>
        <member name="M:Au.wnd.getwnd.TopThreadWindow_(System.Boolean)">
            <summary>
            Gets the first in Z order window of this thread.
            </summary>
            <param name="onlyVisible"></param>
        </member>
        <member name="M:Au.wnd.getwnd.#ctor(Au.wnd)">
            
        </member>
        <member name="M:Au.wnd.getwnd.SiblingLeft">
            <summary>
            Gets nearest visible sibling control to the left from this.
            Returns default(wnd) if not found.
            </summary>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too. Skips maximized/minimized windows and desktop.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingRight">
            <summary>
            Gets nearest visible sibling control to the right from this.
            Returns default(wnd) if not found.
            </summary>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too. Skips maximized/minimized windows and desktop.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingAbove">
            <summary>
            Gets nearest visible sibling control above this.
            Returns default(wnd) if not found.
            </summary>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too. Skips maximized/minimized windows and desktop.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingBelow">
            <summary>
            Gets nearest visible sibling control to below this.
            Returns default(wnd) if not found.
            </summary>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too. Skips maximized/minimized windows and desktop.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingLeft(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a visible sibling control to the left from this.
            Returns default(wnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the left of this control.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingRight(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a visible sibling control to the right from this.
            Returns default(wnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the right of this control.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingAbove(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a visible sibling control above this.
            Returns default(wnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the top of this control.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.SiblingBelow(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a visible sibling control below this.
            Returns default(wnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the bottom of this control.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.Next(System.Int32)">
            <summary>
            Gets next sibling window or control in the Z order.
            Returns default(wnd) if this is the last or if fails.
            </summary>
            <param name="skip">How many next windows to skip.</param>
            <remarks>
            If this is a top-level window, gets next top-level window, else gets next control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDNEXT).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.Previous(System.Int32)">
            <summary>
            Gets previous sibling window or control in the Z order.
            Returns default(wnd) if this is the first or if fails.
            </summary>
            <param name="skip">How many previous windows to skip.</param>
            <remarks>
            If this is a top-level window, gets previous top-level window, else gets previous control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDPREV).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.FirstSibling">
            <summary>
            Gets the first sibling window or control in the Z order.
            If this is the first, returns this.
            </summary>
            <remarks>
            If this is a top-level window, gets the first top-level window, else gets the first control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDFIRST).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.LastSibling">
            <summary>
            Gets the last sibling window or control in the Z order.
            If this is the last, returns this, not default(wnd).
            </summary>
            <remarks>
            If this is a top-level window, gets the last top-level window, else gets the last control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDLAST).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.FirstChild">
            <summary>
            Gets the first direct child control in the Z order.
            Returns default(wnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>(GW_CHILD).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.LastChild">
            <summary>
            Gets the last direct child control in the Z order.
            Returns default(wnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.Child(System.Int32)">
            <summary>
            Gets a direct child control by index.
            Returns default(wnd) if no children or if index is invalid or if fails.
            </summary>
            <param name="index">0-based index of the child control in the Z order.</param>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.Owner">
            <summary>
            Gets the owner window of this top-level window.
            Returns default(wnd) if this window isn't owned or if fails.
            </summary>
            <remarks>
            A window that has an owner window is always on top of it.
            Controls don't have an owner window.
            Supports <see cref="T:Au.lastError"/>.
            This function is the same as <see cref="P:Au.wnd.OwnerWindow"/>, which also allows to change owner.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this.
            Returns default(wnd) if fails.
            </summary>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            This function is the same as <see cref="P:Au.wnd.Window"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.DirectParent">
            <summary>
            Gets the direct parent window of this control. It can be the top-level window or another control.
            Returns default(wnd) if this is a top-level window or if fails.
            </summary>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            Unlike API <msdn>GetParent</msdn>, this function never returns the owner window.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.EnabledOwned(System.Boolean)">
            <summary>
            Gets the first (in Z order) enabled window owned by this window.
            </summary>
            <param name="orThis">Return this window if there are no enabled owned windows. If false, then returns default(wnd).</param>
            <remarks>
            Calls API <msdn>GetWindow</msdn>(GW_ENABLEDPOPUP).
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.LastActiveOwnedOrThis(System.Boolean)">
            <summary>
            Gets the most recently active window in the chain of windows owned by this window, or this window itself if there are no such windows.
            Returns default(wnd) if fails.
            </summary>
            <param name="includeOwners">Can return an owner (or owner's owner and so on) of this window too.</param>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.RootOwnerOrThis(System.Boolean)">
            <summary>
            Gets the bottom-most owner window in the chain of owner windows of this window.
            If this window is not owned, returns this window.
            Returns default(wnd) if fails.
            </summary>
            <param name="supportControls">If this is a child window, use its top-level parent window instead.</param>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="M:Au.wnd.getwnd.Owners(System.Boolean,System.Boolean)">
            <summary>
            Gets all owner windows (owner, its owner and so on) of this window, optionally including this window.
            </summary>
            <param name="andThisWindow">Add this window (or its top-level parent if control) as the first list element.</param>
            <param name="onlyVisible">Skip invisible windows.</param>
            <remarks>
            This window can be top-level window or control.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.top">
            <summary>
            Gets the first top-level window in the Z order.
            </summary>
            <remarks>
            Probably it is a topmost window. To get the first non-topmost window, use <see cref="M:Au.wnd.getwnd.top2(Au.wnd@)"/>.
            Calls API <msdn>GetTopWindow</msdn>(default(wnd)).
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.top2(Au.wnd@)">
            <summary>
            Finds and returns the first non-topmost window in the Z order.
            </summary>
            <param name="lastTopmost">Receives the last topmost window.</param>
            <remarks>
            This function is slower than <see cref="P:Au.wnd.getwnd.top"/> etc. Enumerates windows, because there is no API to get directly.
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.root">
            <summary>
            Calls API <msdn>GetDesktopWindow</msdn>. It gets the virtual parent window of all top-level windows.
            </summary>
            <remarks>
            <note>It is not the desktop window (see <see cref="M:Au.wnd.getwnd.desktop(Au.wnd@,Au.wnd@)"/>) that displays icons and wallpaper.</note>
            </remarks>
        </member>
        <member name="P:Au.wnd.getwnd.shellWindow">
            <summary>
            Calls API <msdn>GetShellWindow</msdn>. It gets a window of the shell process (usually process "explorer", class name "Progman").
            Returns default(wnd) if there is no shell process, for example Explorer process killed/crashed and still not restarted, or if using a custom shell that does not register a shell window.
            </summary>
            <remarks>
            It can be the window that contains desktop icons (see <see cref="M:Au.wnd.getwnd.desktop(Au.wnd@,Au.wnd@)"/>) or other window of the same thread.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.desktop(Au.wnd@,Au.wnd@)">
            <summary>
            Gets the desktop window and its child control that displays desktop icons and wallpaper.
            Returns false if fails.
            </summary>
            <param name="desktopWindow">Receives the top-level desktop window. Class name "Progman" or "WorkerW".</param>
            <param name="control">Receives the control of "SysListView32" class that contains icons and wallpaper.</param>
            <remarks>
            This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.
            Fails if there is no shell process, for example Explorer process killed/crashed and still not restarted, or if using a custom shell that does not register a shell window.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.isMainWindow(Au.wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns true if window w is considered a main window, ie probably is in the Windows taskbar.
            Returns false if it is invisible, cloaked, owned, toolwindow, menu, etc.
            </summary>
            <param name="w"></param>
            <param name="allDesktops">On Windows 10 include (return true for) windows on all virtual desktops. On Windows 8 include Windows Store apps if possible; read more: <see cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>.</param>
            <param name="skipMinimized">Return false if w is minimized.</param>
        </member>
        <member name="M:Au.wnd.getwnd.mainWindows(System.Boolean)">
            <summary>
            Gets main windows, ie those that probably are in the Windows taskbar.
            Returns array containing 0 or more wnd.
            </summary>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps if possible; read more: <see cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Uses <see cref="M:Au.wnd.getwnd.isMainWindow(Au.wnd,System.Boolean,System.Boolean)"/>.
            Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="M:Au.wnd.getwnd.nextMain(Au.wnd,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets next window in the Z order, skipping invisible and other windows that probably are not in the Windows taskbar.
            Returns default(wnd) if there are no such windows.
            </summary>
            <param name="w">Start from this window. If default(wnd), starts from the top of the Z order.</param>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps if possible; read more: <see cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>.</param>
            <param name="skipMinimized">Skip minimized windows.</param>
            <param name="retryFromTop">If w is not default(wnd) and there are no matching windows after it, retry from the top of the Z order. Then can return w.</param>
            <remarks>
            Uses <see cref="M:Au.wnd.getwnd.isMainWindow(Au.wnd,System.Boolean,System.Boolean)"/>.
            This function is quite slow. Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="P:Au.wnd.AsButton">
            <summary>
            Casts this to <see cref="T:Au.Types.WndButton"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.ButtonClick(System.Int32,System.Boolean)">
            <summary>
            Finds a child button by id and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Types.WndButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonId">Control id of the button. This function calls <see cref="M:Au.wnd.ChildById(System.Int32,Au.Types.WCFlags)"/> to find the button.</param>
            <param name="useElm">Use <see cref="M:Au.elm.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.ChildById(System.Int32,Au.Types.WCFlags)"/> and <see cref="M:Au.Types.WndButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            wnd.find("Options").ButtonClick(2);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.ButtonClick(System.String,System.String,System.Boolean)">
            <summary>
            Finds a child button by name and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Types.WndButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonName">Button name. This function calls <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/> to find the button.</param>
            <param name="cn">Button class name to pass to <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.</param>
            <param name="useElm">Use <see cref="M:Au.elm.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/> and <see cref="M:Au.Types.WndButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            wnd.find("Options").ButtonClick("Cancel");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.MenuClick(System.Int32,System.Boolean)">
            <summary>
            Posts a "menu item clicked" notification (<msdn>WM_COMMAND</msdn>) as if that menu item was clicked. Does not use the mouse.
            </summary>
            <param name="itemId">Menu item id. Must be in range 1 to 0xffff.</param>
            <param name="systemMenu">The menu item is in the title bar's context menu, not in the menu bar. Posts <msdn>WM_SYSCOMMAND</msdn> instead.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid itemId.</exception>
            <remarks>
            Works only with standard (classic) menus. The drop-down menu window class name must be "#32768". Works with menu items in window menu bar, system menu and some context menus.
            Does not use the menu itself. Just posts WM_COMMAND or WM_SYSCOMMAND message. Even if a menu item with this id does not exist.
            This variable is the window that contains the menu bar or system menu. Or the drop-down menu window (class "#32768") that contains the menu item.
            </remarks>
        </member>
        <member name="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Finds a top-level window and returns its handle as <b>wnd</b>.
            </summary>
            <returns>Returns <c>default(wnd)</c> if not found. See also: <see cref="P:Au.wnd.Is0"/>, <see cref="M:Au.wnd.op_UnaryPlus(Au.wnd)"/>.</returns>
            <param name="name">
            Window name. Usually it is the title bar text.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. "" means 'no name'.
            </param>
            <param name="cn">
            Window class name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "".
            </param>
            <param name="of">
            Program file name, like <c>"notepad.exe"</c>.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "". Cannot be path.
            
            Or <see cref="M:Au.Types.WOwner.Process(System.Int32)"/>(process id), <see cref="M:Au.Types.WOwner.Thread(System.Int32)"/>(thread id), <see cref="M:Au.Types.WOwner.Window(Au.Types.AnyWnd)"/>(owner window).
            See <see cref="P:Au.wnd.ProcessId"/>, <see cref="P:Au.process.thisProcessId"/>, <see cref="P:Au.wnd.ThreadId"/>, <see cref="P:Au.process.thisThreadId"/>, <see cref="P:Au.wnd.OwnerWindow"/>.
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching window.
            It can evaluate more properties of the window and return true when they match.
            Example: <c>also: t =&gt; !t.IsPopupWindow</c>.
            Called after evaluating all other parameters except <i>contains</i>.
            </param>
            <param name="contains">
            Defines an object that must be in the client area of the window:
            - UI element: <see cref="T:Au.elmFinder"/> or string like <c>"name"</c> or <c>"e 'role' name"</c> or <c>"e 'role'"</c>.
            - Child control: <see cref="T:Au.wndChildFinder"/> or string like <c>"c 'cn' name"</c> or <c>"c '' name"</c> or <c>"c 'cn'"</c>.
            - Image(s) or color(s): <see cref="T:Au.uiimageFinder"/> or string <c>"image:..."</c> (uses <b>uiimage.find</b> with flag <see cref="F:Au.Types.IFFlags.WindowDC"/>).
            </param>
            <remarks>
            To create code for this function, use dialog "Find window or control".
            
            If there are multiple matching windows, gets the first in the Z order matching window, preferring visible windows.
            
            On Windows 8 and later may skip Windows Store app Metro-style windows (on Windows 10 few such windows exist). It happens if this program does not have disableWindowFiltering true in its manifest and is not uiAccess; to find such windows you can use <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/>.
            
            To find message-only windows use <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            - <i>cn</i> is "". To match any, use null.
            - <i>of</i> is "" or 0 or contains character \ or /. To match any, use null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
            <example>
            Try to find Notepad window. Return if not found.
            <code>
            wnd w = wnd.find("* Notepad");
            if(w.Is0) { print.it("not found"); return; }
            </code>
            Try to find Notepad window. Throw NotFoundException if not found.
            <code>
            wnd w1 = +wnd.find("* Notepad");
            </code>
            </example>
        </member>
        <member name="M:Au.wnd.findAll(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Finds all matching windows.
            Returns array containing 0 or more window handles as wnd.
            Parameters etc are the same as <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <remarks>
            The list is sorted to match the Z order, however hidden windows (when using <see cref="F:Au.Types.WFlags.HiddenToo"/>) are always after visible windows.
            </remarks>
            <seealso cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>
            <seealso cref="M:Au.wnd.getwnd.mainWindows(System.Boolean)"/>
            <seealso cref="M:Au.wnd.getwnd.threadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)">
            <summary>
            Finds a top-level window and returns its handle as <b>wnd</b>.
            </summary>
            <returns>Returns <c>default(wnd)</c> if not found. See also: <see cref="P:Au.wnd.Is0"/>, <see cref="M:Au.wnd.op_UnaryPlus(Au.wnd)"/>.</returns>
            <param name="name">
            Name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. "" means 'no name'.
            </param>
            <param name="cn">
            Class name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="messageOnly">Search only message-only windows.</param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>, which uses API <msdn>EnumWindows</msdn>.
            Finds hidden windows too.
            Supports <see cref="T:Au.lastError"/>.
            It is not recommended to use this function in a loop to enumerate windows. It would be unreliable because window positions in the Z order can be changed while enumerating. Also then it would be slower than <b>Find</b> and <b>FindAll</b>.
            </remarks>
        </member>
        <member name="M:Au.wnd.Cached_.FindFast(System.String,System.String,System.Boolean)">
            <summary>
            Calls/returns <see cref="M:Au.wnd.findFast(System.String,System.String,System.Boolean,Au.wnd)"/> and stores found hwnd and time. Returns the cached hwnd if called frequently and it's still valid.
            </summary>
        </member>
        <member name="M:Au.wnd.findOrRun(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains,System.Action,System.Double,System.Boolean)">
            <summary>
            Finds a top-level window (calls <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>). If found, activates (optionally), else calls callback function and waits for the window. The callback should open the window, for example call <see cref="M:Au.run.it(System.String,System.String,Au.Types.RFlags,Au.Types.ROptions)"/>.
            Returns window handle as <b>wnd</b>. Returns <c>default(wnd)</c> if not found (if <i>runWaitS</i> is negative; else exception).
            </summary>
            <param name="name">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="cn">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="of">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="flags">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="also">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="contains">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="run">Callback function. See example.</param>
            <param name="runWaitS">How long to wait for the window after calling the callback function. Seconds. Default 60. See <see cref="M:Au.wnd.wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="needActiveWindow">Finally the window must be active. Default: true.</param>
            <exception cref="T:System.TimeoutException"><i>runWaitS</i> time has expired. Not thrown if <i>runWaitS</i> &lt;= 0.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <remarks>
            The algorithm is:
            <code>
            var w=wnd.find(...);
            if(w.Is0) { run(); w=wnd.wait(runWaitS, needActiveWindow, ...); }
            else if(needActiveWindow) w.Activate();
            return w;
            </code>
            </remarks>
            <example>
            <code><![CDATA[
            wnd w = wnd.findOrRun("* Notepad", run: () => run.it("notepad.exe"));
            print.it(w);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.IsMatch(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Compares window name and other properties like <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> does.
            Returns true if all specified (non-null/default) properties match.
            </summary>
            <param name="name">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="cn">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="of">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="flags">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="also">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <param name="contains">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <remarks>
            Creates new <see cref="T:Au.wndFinder"/> and calls <see cref="M:Au.wndFinder.IsMatch(Au.wnd,Au.Types.WFCache)"/>.
            To compare single parameter, use more lightweight code. Examples: <c>if (w.Name.Like("* Notepad"))</c>, <c>if (w.ClassNameIs("CabinetWClass"))</c>.
            </remarks>
            <seealso cref="P:Au.wnd.Name"/>
            <seealso cref="P:Au.wnd.ClassName"/>
            <seealso cref="M:Au.wnd.ClassNameIs(System.String)"/>
            <seealso cref="P:Au.wnd.ProgramName"/>
        </member>
        <member name="M:Au.wnd.fromXY(Au.Types.POINT,Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from point.
            </summary>
            <param name="p">
            Coordinates.
            Tip: To specify coordinates relative to the right, bottom, work area or a non-primary screen, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.screen,System.Boolean,System.Boolean)"/>, like in the example.
            </param>
            <param name="flags"></param>
            <remarks>
            Unlike API <msdn>WindowFromPhysicalPoint</msdn> etc, this function: does not skip disabled controls; always skips transparent control like group box if a smaller sibling is there. All this is not true with flag Raw.
            </remarks>
            <example>
            Find window at 100 200.
            <code><![CDATA[
            var w = wnd.FromXY((100, 200), WXYFlags.NeedWindow);
            print.it(w);
            ]]></code>
            
            Find window or control at 50 from left and 100 from bottom of the work area.
            <code><![CDATA[
            var w = wnd.FromXY(Coord.Normalize(50, Coord.Reverse(100), true));
            print.it(w);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.fromMouse(Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from mouse cursor position.
            More info: <see cref="M:Au.wnd.fromXY(Au.Types.POINT,Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="M:Au.wnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYCFlags)">
            <summary>
            Gets descendant control from point.
            By default returns default(wnd) if the point is not in a child control; it depends on <i>flags</i>.
            </summary>
            <param name="x">X coordinate in client area or screen (if flag <b>ScreenXY</b>). Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.wnd.ChildFromXY(Au.Types.POINT,Au.Types.WXYCFlags)">
            <summary>
            Gets descendant control from point.
            By default returns default(wnd) if the point is not in a child control; it depends on <i>flags</i>.
            </summary>
            <param name="p">Coordinates in client area or screen (if flag <b>ScreenXY</b>).</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.wnd._FromXY(Au.Types.POINT,System.Boolean@)">
            <summary>
            Gets window or control from point.
            Returns default(wnd) if failed (unlikely).
            </summary>
            <param name="p">Point in screen.</param>
            <param name="isChild">Receives true if control, false if top-level or failed.</param>
        </member>
        <member name="M:Au.wnd._ChildFromXY(Au.Types.POINT,Au.Types.WXYCFlags)">
            <summary>
            Gets descendant control from point. This can be top-level window or control.
            If there is no descendant, the return value depends on <i>flags</i>.
            </summary>
            <param name="p">Point in client area or screen (if flag <b>ScreenXY</b>).</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.wnd._SiblingXY(Au.wnd._SibXY,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets sibling control in space: left, right, above or below.
            Returns default(wnd) if there is no sibling.
            </summary>
            <param name="direction"></param>
            <param name="distance">Distance from this control (from its edge) in the specified direction.</param>
            <param name="edgeOffset">
            Distance in perpendicular direction, along the specified edge. Default 5.
            If <i>direction</i> is <b>Left</b> or <b>Right</b>, 0 is the top edge, 1 is 1 pixel down, -1 is 1 pixel up, and so on.
            If <i>direction</i> is <b>Above</b> or <b>Below</b>, 0 is the left edge, 1 is 1 pixel to the right, -1 is 1 pixel to the left, and so on.
            </param>
            <param name="topChild">If at that point is a visible child or descendant of the sibling, get that child/descendant. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="P:Au.wnd.Get">
            <summary>
            Gets related windows and controls.
            Use like <c>wnd w2 = w1.Get.Owner;</c> (here w1 is a <b>wnd</b> variable).
            </summary>
        </member>
        <member name="M:Au.wnd.switchActiveWindow">
            <summary>
            Activates next non-minimized main window, like with Alt+Tab.
            Returns true if activated, false if there is no such window or failed to activate.
            </summary>
            <remarks>
            Uses <see cref="M:Au.wnd.getwnd.nextMain(Au.wnd,System.Boolean,System.Boolean,System.Boolean)"/>, <see cref="M:Au.wnd.getwnd.LastActiveOwnedOrThis(System.Boolean)"/>, <see cref="M:Au.wnd.Activate"/>.
            An alternative way - send Alt+Tab keys, but it works not everywhere.
            </remarks>
        </member>
        <member name="P:Au.wnd.OwnerWindow">
            <summary>
            Gets or sets the owner window of this top-level window.
            </summary>
            <exception cref="T:Au.Types.AuWndException">The 'set' function failed.</exception>
            <remarks>
            A window that has an owner window is always on top of it.
            Don't call this for controls, they don't have an owner window.
            The 'get' function returns default(wnd) if this window isn't owned or is invalid. Supports <see cref="T:Au.lastError"/>.
            The 'set' function can fail, eg if the owner's process has higher [](xref:uac) integrity level or is a Store app.
            </remarks>
        </member>
        <member name="P:Au.wnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this. Returns default(wnd) if this window is invalid.
            </summary>
            <remarks>Supports <see cref="T:Au.lastError"/>.</remarks>
        </member>
        <member name="P:Au.wnd.IsChild">
            <summary>
            Returns true if this is a child window (control), false if top-level window.
            </summary>
            <remarks>
            Supports <see cref="T:Au.lastError"/>.
            Another way is <c>w.HasStyle(WS.CHILD)</c>. It is faster but less reliable, because some top-level windows have WS_CHILD style and some child windows don't.
            </remarks>
            <seealso cref="P:Au.wnd.getwnd.DirectParent"/>
        </member>
        <member name="M:Au.wnd.IsChildOf(Au.wnd)">
            <summary>
            Returns true if this is a child or descendant of window w.
            </summary>
            <remarks>
            Calls API <msdn>IsChild</msdn>.
            Supports <see cref="T:Au.lastError"/>.
            </remarks>
        </member>
        <member name="P:Au.wnd.ParentGWL_">
            <summary>
            Returns <c>(wnd)GetWindowLong(GWL.HWNDPARENT)</c>.
            </summary>
        </member>
        <member name="P:Au.wnd.active">
            <summary>
            Gets the active (foreground) window.
            Calls API <msdn>GetForegroundWindow</msdn>.
            Returns default(wnd) if there is no active window; more info: <see cref="M:Au.wnd.more.waitForAnActiveWindow"/>.
            </summary>
        </member>
        <member name="P:Au.wnd.IsActive">
            <summary>
            Returns true if this window is the active (foreground) window.
            </summary>
        </member>
        <member name="P:Au.wnd.IsActiveOrNoActiveAndThisIsWndRoot_">
            <summary>
            Returns true if this window is the active (foreground) window.
            If this is <see cref="P:Au.wnd.getwnd.root"/>, returns true if there is no active window.
            </summary>
        </member>
        <member name="M:Au.wnd.SetTransparency(System.Boolean,System.Nullable{System.Int32},System.Nullable{Au.Types.ColorInt})">
            <summary>
            Sets opacity and/or transparent color.
            </summary>
            <param name="allowTransparency">Set or remove WS_EX_LAYERED style that is required for transparency. If false, other parameters are not used.</param>
            <param name="opacity">Opacity from 0 (completely transparent) to 255 (opaque). Does not change if null. If less than 0 or greater than 255, makes 0 or 255.</param>
            <param name="colorKey">Make pixels of this color completely transparent. Does not change if null. The alpha byte is not used.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            Uses API <msdn>SetLayeredWindowAttributes</msdn>.
            On Windows 7 works only with top-level windows, on newer OS also with controls.
            Does not work with WPF windows, class name "HwndWrapper*".
            </remarks>
        </member>
        <member name="P:Au.wnd.IsFullScreen">
            <summary>
            Returns true if this is a full-screen window and not desktop.
            </summary>
        </member>
        <member name="P:Au.wnd.IsOfShellThread_">
            <summary>
            Returns true if this belongs to GetShellWindow's thread (usually it is the desktop window).
            </summary>
        </member>
        <member name="P:Au.wnd.IsOfShellProcess_">
            <summary>
            Returns true if this belongs to GetShellWindow's process (eg a folder window, desktop, taskbar).
            </summary>
        </member>
        <member name="P:Au.wnd.IsWindows8MetroStyle">
            <summary>
            Returns true if this window has Metro style, ie is not a classic desktop window.
            On Windows 8/8.1 most Windows Store app windows and many shell windows have Metro style.
            On Windows 10 few windows have Metro style.
            On Windows 7 there are no Metro style windows.
            </summary>
            <seealso cref="M:Au.wnd.more.getWindowsStoreAppId(Au.wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.wnd.IsUwpApp">
            <summary>
            On Windows 10 and later returns non-zero if this is a UWP app window: 1 if class name is "ApplicationFrameWindow", 2 if "Windows.UI.Core.CoreWindow".
            </summary>
            <seealso cref="M:Au.wnd.more.getWindowsStoreAppId(Au.wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.wnd.MinimalSleepIfOtherThread_">
            <summary>
            if(!IsOfThisThread) { Thread.Sleep(15); SendTimeout(1000, 0); }
            </summary>
        </member>
        <member name="M:Au.wnd.MinimalSleepNoCheckThread_">
            <summary>
            Thread.Sleep(15); SendTimeout(1000, 0);
            </summary>
        </member>
        <member name="M:Au.wnd._WindowsStoreAppFrameChild(Au.wnd)">
            <summary>
            On Win10+, if w is "ApplicationFrameWindow", returns the real app window "Windows.UI.Core.CoreWindow" hosted by w.
            If w is minimized, cloaked (eg on other desktop) or the app is starting, the "Windows.UI.Core.CoreWindow" is not its child. Then searches for a top-level window named like w. It is unreliable, but MS does not provide API for this.
            Info: "Windows.UI.Core.CoreWindow" windows hosted by "ApplicationFrameWindow" belong to separate processes. All "ApplicationFrameWindow" windows belong to a single process.
            </summary>
        </member>
        <member name="M:Au.wnd.wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            Waits until window exists, is visible (optionally) and active (optionally).
            Returns window handle. On timeout returns default(wnd) if <i>secondsTimeout</i> is negative; else exception.
            Parameters etc are the same as <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="active">The window must be the active window (<see cref="P:Au.wnd.active"/>), and not minimized.</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <remarks>
            By default ignores invisible and cloaked windows. Use flags if need.
            If you have a window's wnd variable, to wait until it is active/visible/etc use <see cref="M:Au.wnd.WaitForCondition(System.Double,System.Func{Au.wnd,System.Boolean},System.Boolean)"/> instead.
            </remarks>
            <example>
            <code><![CDATA[
            wnd w = wnd.wait(10, false, "* Notepad");
            print.it(w);
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (_, _) =>
              {
            	  print.it("waiting for Notepad...");
            	  wnd w = await Task.Run(() => wnd.wait(-10, false, "* Notepad"));
            	  if(w.Is0) print.it("timeout"); else print.it(w);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.waitAny(System.Double,System.Boolean,Au.wndFinder[])">
            <summary>
            Waits until any of specified windows exists, is visible (optionally) and active (optionally).
            Returns 1-based index and window handle. On timeout returns <c>(0, default(wnd))</c> if <i>secondsTimeout</i> is negative; else exception.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="active">The window must be the active window (<see cref="P:Au.wnd.active"/>), and not minimized.</param>
            <param name="windows">One or more variables containing window properties. Can be strings, see <see cref="M:Au.wndFinder.op_Implicit(System.String)~Au.wndFinder"/>.</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            By default ignores invisible and cloaked windows. Use <b>wndFinder</b> flags if need.
            </remarks>
            <example>
            <code><![CDATA[
            var (i, w) = wnd.waitAny(10, true, "* Notepad", new wndFinder("* Word"));
            print.it(i, w);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.WaitForCondition(System.Double,System.Func{Au.wnd,System.Boolean},System.Boolean)">
            <summary>
            Waits for a user-defined state/condition of this window. For example active, visible, enabled, closed, contains control.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true.</param>
            <param name="dontThrowIfClosed">
            Do not throw exception when the window handle is invalid or the window was closed while waiting.
            In such case the callback function must return false, like in the examples with <see cref="P:Au.wnd.IsAlive"/>. Else exception is thrown (with a small delay) to prevent infinite waiting.
            </param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">The window handle is invalid or the window was closed while waiting.</exception>
            <example>
            <code><![CDATA[
            wnd w = wnd.find("* Notepad");
            
            //wait max 30 s until window w is active. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsActive);
            print.it("active");
            
            //wait max 30 s until window w is enabled. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsEnabled);
            print.it("enabled");
            
            //wait until window w is closed
            w.WaitForCondition(0, t => !t.IsAlive, true); //same as w.WaitForClosed()
            print.it("closed");
            
            //wait until window w is minimized or closed
            w.WaitForCondition(0, t => t.IsMinimized || !t.IsAlive, true);
            if(!w.IsAlive) { print.it("closed"); return; }
            print.it("minimized");
            
            //wait until window w contains focused control classnamed "Edit"
            var c = new wndChildFinder(cn: "Edit");
            w.WaitForCondition(10, t => c.Find(t) && c.Result.IsFocused);
            print.it("control focused");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wnd.WaitForName(System.Double,System.String)">
            <summary>
            Waits until this window has the specified name.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="name">
            Window name. Usually it is the title bar text.
            String format: [](xref:wildcard_expression).
            </param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">The window handle is invalid or the window was closed while waiting.</exception>
            <exception cref="T:System.ArgumentException">Invalid wildcard expression.</exception>
        </member>
        <member name="M:Au.wnd.WaitForClosed(System.Double,System.Boolean)">
            <summary>
            Waits until this window is closed/destroyed or until its process ends.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="waitUntilProcessEnds">Wait until the process of this window ends.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle when <i>waitUntilProcessEnds</i> is true.</exception>
            <remarks>
            If the window is already closed, immediately returns true.
            </remarks>
        </member>
        <member name="T:Au.wndChildFinder">
            <summary>
            Contains control (child window) properties and is used to find the control.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/> or <see cref="M:Au.wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean})"/>.
            Also can be used to find window that contains certain control, like in the example.
            </remarks>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var f = new wndChildFinder("Password*", "Static"); //control properties
            wnd w = wnd.find(cn: "#32770", also: t => f.Find(t));
            print.it(w);
            print.it(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.wndChildFinder.#ctor(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)">
            <summary>
            See <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.</exception>
        </member>
        <member name="P:Au.wndChildFinder.Result">
            <summary>
            The found control.
            </summary>
        </member>
        <member name="M:Au.wndChildFinder.Find(Au.wnd)">
            <summary>
            Finds the specified child control, like <see cref="M:Au.wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean},System.Int32)"/>.
            Returns true if found.
            The <see cref="P:Au.wndChildFinder.Result"/> property will be the control.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.wndChildFinder.FindInList(System.Collections.Generic.IEnumerable{Au.wnd},Au.wnd)">
            <summary>
            Finds the specified control in a list of controls.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.wndChildFinder.Result"/> property will be the control.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.wnd.getwnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.wndChildFinder.FindAll(Au.wnd)">
            <summary>
            Finds all matching child controls, like <see cref="M:Au.wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.wnd,System.Boolean})"/>.
            Returns array containing 0 or more control handles as wnd.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.wndChildFinder.FindAllInList(System.Collections.Generic.IEnumerable{Au.wnd},Au.wnd)">
            <summary>
            Finds all matching controls in a list of controls.
            Returns array containing 0 or more control handles as wnd.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.wnd.getwnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.wndChildFinder._FindInList(Au.wnd,Au.wnd.Internal_.WndList_,System.Action{Au.wnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="wParent">Parent window. Can be default(wnd) if inList is true and no DirectChild flag and not using winforms name.</param>
            <param name="a">List of wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.wndChildFinder.IsMatch(Au.wnd,Au.wnd)">
            <summary>
            Returns true if control c properties match the specified properties.
            </summary>
            <param name="c">A control. Can be 0/invalid, then returns false.</param>
            <param name="wParent">Direct or indirect parent window. If used, returns false if it isn't parent (also depends on flag DirectChild).</param>
        </member>
        <member name="T:Au.wndFinder">
            <summary>
            Contains top-level window properties and can be used to find the window.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/> or <see cref="M:Au.wnd.findAll(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            These codes are equivalent:
            <code>wnd w = wnd.find(a, b, c, d, e); if(!w.Is0) print.it(w);</code>
            <code>var p = new wnd.wndFinder(a, b, c, d, e); if(p.Find()) print.it(p.Result);</code>
            Also can find in a list of windows.
            </remarks>
        </member>
        <member name="P:Au.wndFinder.Props">
            <summary>
            Parsed parameter values. All read-only.
            </summary>
        </member>
        <member name="P:Au.wndFinder.TProps.DoesNotMatch">
            <summary>
            After unsuccesful <see cref="M:Au.wndFinder.IsMatch(Au.wnd,Au.Types.WFCache)"/> indicates the parameter that does not match.
            </summary>
        </member>
        <member name="M:Au.wndFinder.#ctor(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)">
            <summary>
            See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
        </member>
        <member name="M:Au.wndFinder.op_Implicit(System.String)~Au.wndFinder">
            <summary>
            Implicit conversion from string that can contain window name, class name, program and/or a <i>contains</i> object.
            Examples: <c>"name,cn,program"</c>, <c>"name"</c>, <c>",cn"</c>, <c>",,program"</c>, <c>"name,cn"</c>, <c>"name,,program"</c>, <c>",cn,program"</c>, <c>"name,,,object"</c>.
            </summary>
            <param name="s">
            One or more comma-separated window properties: name, class, program and/or a <i>contains</i> object. Empty parts are considered null.
            The same as parameters of <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>. The first 3 parts are <i>name</i>, <i>cn</i> and <i>of</i>. The last part is <i>contains</i> as string; can specify a UI element, control or image.
            The first 3 comma-separated parts cannot contain commas. Alternatively, parts can be separated by '\0' characters, like <c>"name\0"+"cn\0"+"program\0"+"object"</c>. Then parts can contain commas. Example: <c>"*one, two, three*\0"</c> (name with commas).
            </param>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.</exception>
            <exception cref="T:System.Exception">If specifies a <i>contains</i> object: exceptions of constructor of <see cref="T:Au.wndChildFinder"/> or <see cref="T:Au.elmFinder"/> or <see cref="T:Au.uiimageFinder"/>.</exception>
        </member>
        <member name="P:Au.wndFinder.Result">
            <summary>
            The found window.
            </summary>
        </member>
        <member name="M:Au.wndFinder.Find">
            <summary>
            Finds the specified window, like <see cref="M:Au.wnd.find(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            Returns true if found.
            The <see cref="P:Au.wndFinder.Result"/> property will be the window.
            </summary>
        </member>
        <member name="M:Au.wndFinder.FindInList(System.Collections.Generic.IEnumerable{Au.wnd})">
            <summary>
            Finds the specified window in a list of windows.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.wndFinder.Result"/> property will be the window.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.wndFinder.FindAll">
            <summary>
            Finds all matching windows, like <see cref="M:Au.wnd.findAll(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>.
            Returns array containing 0 or more window handles as <b>wnd</b>.
            </summary>
        </member>
        <member name="M:Au.wndFinder.FindAllInList(System.Collections.Generic.IEnumerable{Au.wnd})">
            <summary>
            Finds all matching windows in a list of windows.
            Returns array containing 0 or more window handles as <b>wnd</b>.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.wnd.getwnd.allWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.wndFinder._FindOrMatch(Au.wnd.Internal_.WndList_,System.Action{Au.wnd},Au.Types.WFCache)">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="a">List of wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
            <param name="cache"></param>
        </member>
        <member name="M:Au.wndFinder.IsMatch(Au.wnd,Au.Types.WFCache)">
            <summary>
            Returns true if window w properties match the specified properties.
            </summary>
            <param name="w">A top-level window. If 0 or invalid, returns false.</param>
            <param name="cache">Can be used to make faster when multiple <b>wndFinder</b> variables are used with same window. The function gets window name/class/program once, and stores in <i>cache</i>; next time it gets these strings from <i>cache</i>.</param>
            <seealso cref="M:Au.wnd.IsMatch(System.String,System.String,Au.Types.WOwner,Au.Types.WFlags,System.Func{Au.wnd,System.Boolean},Au.Types.WContains)"/>
        </member>
        <member name="T:System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute">
            
        </member>
        <member name="M:System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute.#ctor(System.String)">
            
        </member>
        <member name="P:System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute.AssemblyName">
            
        </member>
    </members>
</doc>
